<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>Javrania</title>
        <link>http://javran.github.io/</link>
        <description><![CDATA[Javran's blog]]></description>
        <atom:link href="http://javran.github.io//rss.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Mon, 25 May 2015 00:00:00 UT</lastBuildDate>
        <item>
    <title>Building ghc-7.8.4 on RHEL5</title>
    <link>http://javran.github.io//posts/2015-05-25-building-ghc-7.8.4-on-RHEL5.html</link>
    <description><![CDATA[<span class="blog-date">
    2015-05-25 - 
</span>
<span class="blog-tag">
    
        [ 
        <a href="/tags/haskell.html">haskell</a>, <a href="/tags/ghc.html">ghc</a>, <a href="/tags/linux.html">linux</a>
        ]
    
</span>
<br />
<br />
<div class="blog-main">
<p>For some reasons I need to run haskell programs on a RHEL5 machine. Sadly the system packages were too old to support the latest binary, and I don't have the root privilege to install any software so have to build it from source.</p>
<p>Here I want to share my experience of building ghc-7.8 from source in a rather old operating system.</p>
<p>I also want to say thanks to Tim Docker, who posted <a href="https://twdkz.wordpress.com/2011/12/21/installing-ghc-7-0-3-and-the-haskell-platform-on-rhel-5-6/">an article</a> without which my post might not be possible.</p>
<p>Basically, you need to first have a working ghc binary before you can build a newer one yourself. Please refer to <a href="https://ghc.haskell.org/trac/ghc/wiki/Building/Preparation/Tools">GHC Wiki</a> for details.</p>
<p>We will begin with ghc-6.8.3, bootstrap ghc-6.10, ghc-7.0, ghc-7.4 and finally ghc-7.8.</p>
<h1 id="download-related-files">Download related files</h1>
<p>We need all the files above. For items marked with <code>(latest)</code>, just downloading the latest version instead should also work.</p>
<p>I assume you have set the environment variable <code>SOURCES</code> (in your <code>.bashrc</code>) to the directory containing all your tarball files. (it is recommended here to use absolute path), which will also be our working directory for building up everything related.</p>
<ul>
<li><p>ghc</p>
<p>If any of the following link does not work, go to <a href="https://www.haskell.org/ghc/download">this download page</a> and download them accordingly.</p>
<ul>
<li><a href="https://www.haskell.org/ghc/dist/6.8.3/ghc-6.8.3-x86_64-unknown-linux.tar.bz2">ghc-6.8.3-x86_64-unknown-linux.tar.bz2</a></li>
<li><a href="https://www.haskell.org/ghc/dist/6.10.4/ghc-6.10.4-src.tar.bz2">ghc-6.10.4-src.tar.bz2</a></li>
<li><a href="https://www.haskell.org/ghc/dist/7.0.3/ghc-7.0.3-src.tar.bz2">ghc-7.0.3-src.tar.bz2</a></li>
<li><a href="https://www.haskell.org/ghc/dist/7.4.2/ghc-7.4.2-src.tar.bz2">ghc-7.4.2-src.tar.bz2</a></li>
<li><a href="https://www.haskell.org/ghc/dist/7.8.4/ghc-7.8.4-src.tar.bz2">ghc-7.8.4-src.tar.bz2</a></li>
</ul></li>
<li><p>gcc</p>
<p>Choose your preferred GCC mirror site on <a href="https://gcc.gnu.org/mirrors.html">this page</a>. And download the corresponding version from directory <code>releases/gcc-x.y.z</code>.</p>
<p>All links above are based on <a href="http://mirrors.concertpass.com/">ConcertPass.com Mirror Server</a>.</p>
<ul>
<li><a href="http://mirrors.concertpass.com/gcc/releases/gcc-4.4.3/gcc-4.4.3.tar.bz2">gcc-4.4.3</a></li>
<li><a href="http://mirrors.concertpass.com/gcc/releases/gcc-4.9.2/gcc-4.9.2.tar.bz2">gcc-4.9.2</a> (latest)</li>
</ul></li>
<li><p><a href="http://ftp.gnu.org/gnu/binutils/binutils-2.25.tar.bz2">binutils-2.25.tar.bz2</a> (latest)</p></li>
<li><p>Checksum:</p>
<pre><code>  $ (cd $SOURCES; sha256sum *)
  22defc65cfa3ef2a3395faaea75d6331c6e62ea5dfacfed3e2ec17b08c882923  binutils-2.25.tar.bz2
  97ed664694b02b4d58ac2cafe443d02a388f9cb3645e7778843b5086a5fec040  gcc-4.4.3.tar.bz2
  2020c98295856aa13fda0f2f3a4794490757fc24bcca918d52cc8b4917b972dd  gcc-4.9.2.tar.bz2
  d66a8e52572f4ff819fe5c4e34c6dd1e84a7763e25c3fadcc222453c0bd8534d  ghc-6.10.4-src.tar.bz2
  07d06efa9222638c80b72ceda957d3c7bcbdc2665a9738dd6ef6c0751a05e8ed  ghc-6.8.3-x86_64-unknown-linux.tar.bz2
  156169c28dab837922260a0fbfcc873c679940d805a736dc78aeb1b60c13ccd9  ghc-7.0.3-src.tar.bz2
  f2ee1289a33cc70539287129841acc7eaf16112bb60c59b5a6ee91887bfd836d  ghc-7.4.2-src.tar.bz2
  59e3bd514a1820cc1c03e1808282205c0b8518369acae12645ceaf839e6f114b  ghc-7.8.4-src.tar.bz2</code></pre></li>
</ul>
<p>Note: I can only confirm that I got a working ghc-7.8.4 following these steps in this specific order. It is likely that these early versions of ghc has troubles with the latest gcc and binutils.</p>
<h1 id="install-ghc-6.8.3">Install ghc-6.8.3</h1>
<p>In order to get a clean installation, I will isolate each package by using a different prefix directory. But it is still okay to share the same prefix directory if you want. The major difference is that if you share prefix directory between packages, the old files might not be overwritten and thus remain there and become junk.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1"></a>$ <span class="bu">cd</span> <span class="va">$SOURCES</span></span>
<span id="cb2-2"><a href="#cb2-2"></a>$ <span class="fu">tar</span> -xf ghc-6.8.3-x86_64-unknown-linux.tar.bz2</span>
<span id="cb2-3"><a href="#cb2-3"></a>$ <span class="bu">cd</span> ghc-6.8.3</span>
<span id="cb2-4"><a href="#cb2-4"></a>$ <span class="fu">mkdir</span> prefix</span>
<span id="cb2-5"><a href="#cb2-5"></a>$ <span class="ex">./configure</span> --prefix <span class="va">$SOURCES</span>/ghc-6.8.3/prefix</span>
<span id="cb2-6"><a href="#cb2-6"></a>$ <span class="fu">make</span> install</span></code></pre></div>
<h1 id="install-ghc-6.10.4">Install ghc-6.10.4</h1>
<p>From now on, whenever you see a <code>make</code> command without explicit goal, feel free to pass <code>-j N</code> to <code>make</code> to speed up compilation (where <code>N</code> is usually set to the number of available CPU cores plus one). If something fails, just rerun <code>make</code> (maybe with a smaller <code>N</code>), do <code>make clean</code> only if you are getting the same error message through different runs.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1"></a>$ <span class="bu">cd</span> <span class="va">$SOURCES</span></span>
<span id="cb3-2"><a href="#cb3-2"></a>$ <span class="fu">tar</span> -xf ghc-6.10.4-src.tar.bz2</span>
<span id="cb3-3"><a href="#cb3-3"></a>$ <span class="bu">cd</span> ghc-6.10.4</span>
<span id="cb3-4"><a href="#cb3-4"></a>$ <span class="fu">mkdir</span> prefix</span>
<span id="cb3-5"><a href="#cb3-5"></a>$ <span class="va">PATH=</span><span class="st">&quot;</span><span class="va">$SOURCES</span><span class="st">/ghc-6.8.3/prefix/bin:</span><span class="va">$PATH</span><span class="st">&quot;</span> <span class="ex">./configure</span> --prefix <span class="va">$SOURCES</span>/ghc-6.10.4/prefix</span>
<span id="cb3-6"><a href="#cb3-6"></a>$ <span class="va">PATH=</span><span class="st">&quot;</span><span class="va">$SOURCES</span><span class="st">/ghc-6.8.3/prefix/bin:</span><span class="va">$PATH</span><span class="st">&quot;</span> <span class="fu">make</span></span>
<span id="cb3-7"><a href="#cb3-7"></a>$ <span class="fu">make</span> install</span></code></pre></div>
<h1 id="install-gcc-4.4.3">Install gcc-4.4.3</h1>
<p>Now you need to install a newer version of gcc. The gcc shipped with RHEL5 is gcc-4.1.2, which is too old to get ghc-7.0 compiled.</p>
<p>The reason why we do not use the latest version of gcc is that it cannot compile ghc-7.0 either…</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1"></a>$ <span class="bu">cd</span> <span class="va">$SOURCES</span></span>
<span id="cb4-2"><a href="#cb4-2"></a>$ <span class="fu">tar</span> -xf gcc-4.4.3.tar.bz2</span>
<span id="cb4-3"><a href="#cb4-3"></a>$ <span class="fu">tar</span> -xf gcc-4.9.2.tar.bz2</span></code></pre></div>
<p>Copy a script from gcc-4.9.2 to gcc-4.4.3:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1"></a>$ <span class="fu">cp</span> gcc-4.9.2/contrib/download_prerequisites gcc-4.4.3/contrib/</span></code></pre></div>
<p>And edit the one under gcc-4.4.3 (feel free to replace <code>$EDITOR</code> with whatever text editor you like):</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1"></a>$ <span class="va">$EDITOR</span> <span class="ex">gcc-4.4.3/contrib/download_prerequisites</span></span></code></pre></div>
<p>Find and comment out the following line:</p>
<pre><code># GRAPHITE_LOOP_OPT=yes</code></pre>
<p>Go into the directory, it's time to retrieve some dependencies:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb8-1"><a href="#cb8-1"></a>$ <span class="bu">cd</span> gcc-4.4.3</span>
<span id="cb8-2"><a href="#cb8-2"></a>$ <span class="ex">./contrib/download_prerequisites</span></span></code></pre></div>
<p>Now create another directory under gcc-4.4.3. To compile gcc you need to make your working directory different from gcc’s. Proceed with routines, remember to set prefix and enable only the necessary language. (P.S. <code>--enable-languages=c,c++</code> is necessary because to bootstrap newer versions of gcc, you will need both <code>gcc</code> and <code>g++</code>).</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb9-1"><a href="#cb9-1"></a>$ <span class="fu">mkdir</span> prefix</span>
<span id="cb9-2"><a href="#cb9-2"></a>$ <span class="fu">mkdir</span> gcc-build</span>
<span id="cb9-3"><a href="#cb9-3"></a>$ <span class="bu">cd</span> gcc-build</span>
<span id="cb9-4"><a href="#cb9-4"></a>$ <span class="ex">../configure</span> --prefix <span class="va">$SOURCES</span>/gcc-4.4.3/prefix --enable-languages=c,c++</span>
<span id="cb9-5"><a href="#cb9-5"></a>$ <span class="fu">make</span></span>
<span id="cb9-6"><a href="#cb9-6"></a>$ <span class="fu">make</span> install</span></code></pre></div>
<p>And now gcc-4.4.3 should be ready, here we can set it permanently. Put the following line to the bottom of your <code>~/.bashrc</code> file:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb10-1"><a href="#cb10-1"></a><span class="co"># if you want to unset $SOURCES afterwards,</span></span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="co"># remember to replace it with the real location.</span></span>
<span id="cb10-3"><a href="#cb10-3"></a><span class="bu">export</span> <span class="va">PATH=</span><span class="st">&quot;</span><span class="va">$SOURCES</span><span class="st">/gcc-4.4.3/prefix/bin:</span><span class="va">$PATH</span><span class="st">&quot;</span></span></code></pre></div>
<p>Now verify:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb11-1"><a href="#cb11-1"></a>$ <span class="bu">source</span> ~/.bashrc</span>
<span id="cb11-2"><a href="#cb11-2"></a>$ <span class="fu">gcc</span> --version</span>
<span id="cb11-3"><a href="#cb11-3"></a><span class="fu">gcc</span> (GCC) <span class="ex">4.4.3</span></span>
<span id="cb11-4"><a href="#cb11-4"></a><span class="ex">Copyright</span> (C) <span class="ex">2010</span> Free Software Foundation, Inc.</span>
<span id="cb11-5"><a href="#cb11-5"></a><span class="ex">This</span> is free software<span class="kw">;</span> <span class="ex">see</span> the source for copying conditions.  There is NO</span>
<span id="cb11-6"><a href="#cb11-6"></a><span class="ex">warranty</span><span class="kw">;</span> <span class="ex">not</span> even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span></code></pre></div>
<h1 id="install-ghc-7.0.3">Install ghc-7.0.3</h1>
<div class="sourceCode" id="cb12"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb12-1"><a href="#cb12-1"></a>$ <span class="bu">cd</span> <span class="va">$SOURCES</span></span>
<span id="cb12-2"><a href="#cb12-2"></a>$ <span class="fu">tar</span> -xf ghc-7.0.3-src.tar.bz2</span>
<span id="cb12-3"><a href="#cb12-3"></a>$ <span class="bu">cd</span> ghc-7.0.3</span>
<span id="cb12-4"><a href="#cb12-4"></a>$ <span class="fu">mkdir</span> prefix</span>
<span id="cb12-5"><a href="#cb12-5"></a>$ <span class="va">PATH=</span><span class="st">&quot;</span><span class="va">$SOURCES</span><span class="st">/ghc-6.10.4/prefix/bin:</span><span class="va">$PATH</span><span class="st">&quot;</span> <span class="ex">./configure</span> --prefix <span class="va">$SOURCES</span>/ghc-7.0.3/prefix</span>
<span id="cb12-6"><a href="#cb12-6"></a>$ <span class="va">PATH=</span><span class="st">&quot;</span><span class="va">$SOURCES</span><span class="st">/ghc-6.10.4/prefix/bin:</span><span class="va">$PATH</span><span class="st">&quot;</span> <span class="fu">make</span></span>
<span id="cb12-7"><a href="#cb12-7"></a>$ <span class="fu">make</span> install</span></code></pre></div>
<h1 id="install-ghc-7.4.2">Install ghc-7.4.2</h1>
<div class="sourceCode" id="cb13"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb13-1"><a href="#cb13-1"></a>$ <span class="bu">cd</span> <span class="va">$SOURCES</span></span>
<span id="cb13-2"><a href="#cb13-2"></a>$ <span class="fu">tar</span> -xf ghc-7.4.2-src.tar.bz2</span>
<span id="cb13-3"><a href="#cb13-3"></a>$ <span class="bu">cd</span> ghc-7.4.2</span>
<span id="cb13-4"><a href="#cb13-4"></a>$ <span class="fu">mkdir</span> prefix</span>
<span id="cb13-5"><a href="#cb13-5"></a>$ <span class="va">PATH=</span><span class="st">&quot;</span><span class="va">$SOURCES</span><span class="st">/ghc-7.0.3/prefix/bin:</span><span class="va">$PATH</span><span class="st">&quot;</span> <span class="ex">./configure</span> --prefix <span class="va">$SOURCES</span>/ghc-7.4.2/prefix</span>
<span id="cb13-6"><a href="#cb13-6"></a>$ <span class="va">PATH=</span><span class="st">&quot;</span><span class="va">$SOURCES</span><span class="st">/ghc-7.0.3/prefix/bin:</span><span class="va">$PATH</span><span class="st">&quot;</span> <span class="fu">make</span></span>
<span id="cb13-7"><a href="#cb13-7"></a>$ <span class="fu">make</span> install</span></code></pre></div>
<h1 id="optional-update-gcc-and-binutils">(Optional) Update gcc and binutils</h1>
<p>This step might not be necessary.</p>
<p>Some packages from hackage (for example ciper-aes) would fail because of the out-dated binutils.</p>
<p>So before we get to 7.8.4, I want to make sure we have a newer version of toolchain, by using which we might also benefit from new optimization techniques.</p>
<p>First we build the latest version of gcc from source.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb14-1"><a href="#cb14-1"></a>$ <span class="bu">source</span> ~/.bashrc</span>
<span id="cb14-2"><a href="#cb14-2"></a>$ <span class="bu">cd</span> <span class="va">$SOURCES</span></span>
<span id="cb14-3"><a href="#cb14-3"></a><span class="co"># should have been extracted when we were compiling gcc-4.4.3</span></span>
<span id="cb14-4"><a href="#cb14-4"></a>$ <span class="bu">cd</span> gcc-4.9.2</span>
<span id="cb14-5"><a href="#cb14-5"></a>$ <span class="ex">./contrib/download_prerequisites</span></span>
<span id="cb14-6"><a href="#cb14-6"></a>$ <span class="fu">mkdir</span> prefix</span>
<span id="cb14-7"><a href="#cb14-7"></a>$ <span class="fu">mkdir</span> gcc-build</span>
<span id="cb14-8"><a href="#cb14-8"></a>$ <span class="bu">cd</span> gcc-build</span>
<span id="cb14-9"><a href="#cb14-9"></a>$ <span class="ex">../configure</span> --prefix <span class="va">$SOURCES</span>/gcc-4.9.2/prefix --enable-languages=c,c++</span>
<span id="cb14-10"><a href="#cb14-10"></a>$ <span class="fu">make</span></span>
<span id="cb14-11"><a href="#cb14-11"></a>$ <span class="fu">make</span> install</span></code></pre></div>
<p>Then we can change the last few lines added to our <code>~/.bashrc</code> to:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb15-1"><a href="#cb15-1"></a><span class="bu">export</span> <span class="va">PATH=</span><span class="st">&quot;</span><span class="va">$SOURCES</span><span class="st">/gcc-4.9.2/prefix/bin:</span><span class="va">$PATH</span><span class="st">&quot;</span></span></code></pre></div>
<p>Then we build binutils:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb16-1"><a href="#cb16-1"></a>$ <span class="bu">source</span> ~/.bashrc</span>
<span id="cb16-2"><a href="#cb16-2"></a>$ <span class="bu">cd</span> <span class="va">$SOURCES</span></span>
<span id="cb16-3"><a href="#cb16-3"></a>$ <span class="fu">tar</span> -xf binutils-2.25.tar.bz2</span>
<span id="cb16-4"><a href="#cb16-4"></a>$ <span class="bu">cd</span> binutils-2.25</span>
<span id="cb16-5"><a href="#cb16-5"></a>$ <span class="fu">mkdir</span> prefix</span>
<span id="cb16-6"><a href="#cb16-6"></a>$ <span class="ex">./configure</span> --prefix <span class="va">$SOURCES</span>/binutils-2.25/prefix</span>
<span id="cb16-7"><a href="#cb16-7"></a>$ <span class="fu">make</span></span>
<span id="cb16-8"><a href="#cb16-8"></a>$ <span class="fu">make</span> install</span></code></pre></div>
<p>And add it to <code>PATH</code> by appending these lines to your <code>~/.bashrc</code>:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb17-1"><a href="#cb17-1"></a><span class="bu">export</span> <span class="va">PATH=</span><span class="st">&quot;</span><span class="va">$SOURCES</span><span class="st">/binutils-2.25/prefix/bin:</span><span class="va">$PATH</span><span class="st">&quot;</span></span></code></pre></div>
<p>And don’t forget to source your <code>bashrc</code>:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb18-1"><a href="#cb18-1"></a>$ <span class="bu">source</span> ~/.bashrc</span></code></pre></div>
<h1 id="install-ghc-7.8.4">Install ghc-7.8.4</h1>
<div class="sourceCode" id="cb19"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb19-1"><a href="#cb19-1"></a>$ <span class="bu">cd</span> <span class="va">$SOURCES</span></span>
<span id="cb19-2"><a href="#cb19-2"></a>$ <span class="fu">tar</span> -xf ghc-7.8.4-src.tar.bz2</span>
<span id="cb19-3"><a href="#cb19-3"></a>$ <span class="bu">cd</span> ghc-7.8.4</span>
<span id="cb19-4"><a href="#cb19-4"></a>$ <span class="fu">mkdir</span> prefix</span>
<span id="cb19-5"><a href="#cb19-5"></a>$ <span class="va">PATH=</span><span class="st">&quot;</span><span class="va">$SOURCES</span><span class="st">/ghc-7.4.2/prefix/bin:</span><span class="va">$PATH</span><span class="st">&quot;</span> <span class="ex">./configure</span> --prefix <span class="va">$SOURCES</span>/ghc-7.8.4/prefix</span>
<span id="cb19-6"><a href="#cb19-6"></a>$ <span class="va">PATH=</span><span class="st">&quot;</span><span class="va">$SOURCES</span><span class="st">/ghc-7.4.2/prefix/bin:</span><span class="va">$PATH</span><span class="st">&quot;</span> <span class="fu">make</span></span>
<span id="cb19-7"><a href="#cb19-7"></a>$ <span class="fu">make</span> install</span></code></pre></div>
<h1 id="add-ghc-to-path-and-clean-up-.bashrc">Add ghc to PATH and Clean up <code>.bashrc</code></h1>
<p>By now you might have a quite messy <code>$PATH</code>, don’t worry, here we will clean it up.</p>
<p>The last few lines in your <code>.bashrc</code> will look like:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb20-1"><a href="#cb20-1"></a><span class="bu">export</span> <span class="va">SOURCES=</span><span class="st">&quot;</span><span class="va">${HOME}</span><span class="st">/sources&quot;</span></span>
<span id="cb20-2"><a href="#cb20-2"></a></span>
<span id="cb20-3"><a href="#cb20-3"></a><span class="co"># if you want to unset $SOURCES afterwards,</span></span>
<span id="cb20-4"><a href="#cb20-4"></a><span class="co"># remember to replace it with the real location.</span></span>
<span id="cb20-5"><a href="#cb20-5"></a><span class="bu">export</span> <span class="va">PATH=</span><span class="st">&quot;</span><span class="va">$SOURCES</span><span class="st">/gcc-4.9.2/prefix/bin:</span><span class="va">$PATH</span><span class="st">&quot;</span></span>
<span id="cb20-6"><a href="#cb20-6"></a><span class="bu">export</span> <span class="va">PATH=</span><span class="st">&quot;</span><span class="va">$SOURCES</span><span class="st">/binutils-2.25/prefix/bin:</span><span class="va">$PATH</span><span class="st">&quot;</span></span></code></pre></div>
<p>Here we add one line for ghc-7.8.4, and replace <code>$SOURCES</code> with the corresponding value (here I assume <code>SOURCE="${HOME}/sources"</code>, but you need to change it accordingly).</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb21-1"><a href="#cb21-1"></a><span class="co">#export SOURCES=&quot;${HOME}/sources&quot;</span></span>
<span id="cb21-2"><a href="#cb21-2"></a></span>
<span id="cb21-3"><a href="#cb21-3"></a><span class="co"># if you want to unset $SOURCES afterwards,</span></span>
<span id="cb21-4"><a href="#cb21-4"></a><span class="co"># remember to replace it with the real location.</span></span>
<span id="cb21-5"><a href="#cb21-5"></a><span class="bu">export</span> <span class="va">PATH=</span><span class="st">&quot;</span><span class="va">${HOME}</span><span class="st">/sources/gcc-4.9.2/prefix/bin:</span><span class="va">$PATH</span><span class="st">&quot;</span></span>
<span id="cb21-6"><a href="#cb21-6"></a><span class="bu">export</span> <span class="va">PATH=</span><span class="st">&quot;</span><span class="va">${HOME}</span><span class="st">/sources/binutils-2.25/prefix/bin:</span><span class="va">$PATH</span><span class="st">&quot;</span></span>
<span id="cb21-7"><a href="#cb21-7"></a><span class="bu">export</span> <span class="va">PATH=</span><span class="st">&quot;</span><span class="va">${HOME}</span><span class="st">/sources/ghc-7.8.4/prefix/bin:</span><span class="va">$PATH</span><span class="st">&quot;</span></span></code></pre></div>
<p>Now everything is done, just logout and relogin, then you should have ghc-7.8.4 ready.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb22-1"><a href="#cb22-1"></a><span class="co"># login</span></span>
<span id="cb22-2"><a href="#cb22-2"></a>$ <span class="fu">ld</span> --version</span>
<span id="cb22-3"><a href="#cb22-3"></a><span class="ex">GNU</span> ld (GNU Binutils) <span class="ex">2.25</span></span>
<span id="cb22-4"><a href="#cb22-4"></a><span class="ex">Copyright</span> (C) <span class="ex">2014</span> Free Software Foundation, Inc.</span>
<span id="cb22-5"><a href="#cb22-5"></a><span class="ex">This</span> program is free software<span class="kw">;</span> <span class="ex">you</span> may redistribute it under the terms of</span>
<span id="cb22-6"><a href="#cb22-6"></a><span class="ex">the</span> GNU General Public License version 3 or (at your option) <span class="ex">a</span> later version.</span>
<span id="cb22-7"><a href="#cb22-7"></a><span class="ex">This</span> program has absolutely no warranty.</span>
<span id="cb22-8"><a href="#cb22-8"></a>$ <span class="fu">gcc</span> --version</span>
<span id="cb22-9"><a href="#cb22-9"></a><span class="fu">gcc</span> (GCC) <span class="ex">4.9.2</span></span>
<span id="cb22-10"><a href="#cb22-10"></a><span class="ex">Copyright</span> (C) <span class="ex">2014</span> Free Software Foundation, Inc.</span>
<span id="cb22-11"><a href="#cb22-11"></a><span class="ex">This</span> is free software<span class="kw">;</span> <span class="ex">see</span> the source for copying conditions.  There is NO</span>
<span id="cb22-12"><a href="#cb22-12"></a><span class="ex">warranty</span><span class="kw">;</span> <span class="ex">not</span> even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span>
<span id="cb22-13"><a href="#cb22-13"></a></span>
<span id="cb22-14"><a href="#cb22-14"></a>$ <span class="ex">ghc</span> --version</span>
<span id="cb22-15"><a href="#cb22-15"></a><span class="ex">The</span> Glorious Glasgow Haskell Compilation System, version 7.8.4</span></code></pre></div>
<h1 id="afterthoughts">Afterthoughts</h1>
<p>I hope this article might be helpful in case you want to do something similar. I like the idea of bootstrapping, but sometimes it is painful to walk through the process, especially when the working binary version is too old and you need to bootstrap multiple times.</p>
<p>Lesson learned: backward compatibility is not always reliable. If you want some old software to work, prefering tools with version relatively recent to that software over ones with the latest version usually help.</p>
</div>
]]></description>
    <pubDate>Mon, 25 May 2015 00:00:00 UT</pubDate>
    <guid>http://javran.github.io//posts/2015-05-25-building-ghc-7.8.4-on-RHEL5.html</guid>
    <dc:creator>Javran Cheng</dc:creator>
</item>
<item>
    <title>Get Rid of XMonad Focus Thief</title>
    <link>http://javran.github.io//posts/2014-11-27-get-rid-of-xmonad-focus-thief.html</link>
    <description><![CDATA[<span class="blog-date">
    2014-11-27 - 
</span>
<span class="blog-tag">
    
        [ 
        <a href="/tags/xmonad.html">xmonad</a>, <a href="/tags/haskell.html">haskell</a>
        ]
    
</span>
<br />
<br />
<div class="blog-main">
<p>I've been using xmonad for a while. One annoyance found when enabling <a href="http://xmonad.org/xmonad-docs/xmonad-contrib/XMonad-Hooks-EwmhDesktops.html">EWMH</a> (see resources in the last section of my post if you don't know what EWMH does) is that pidgin (and maybe some other programs as well) will try to request for window focus whenever xmonad starts / restarts, resulting in your focus moved to the workspace that pidgin belongs to. Today I spent some time to investigate this issue and would like to share my workaround in this post.</p>
<h1 id="the-problem-and-my-workaround">The Problem and My Workaround</h1>
<p>The problem arises immediately after xmonad gets started / restarted. I guess there might be some interaction to notify running X11 programs that xmonad is up. And some of these programs would respond to this nofication by sending some requests to xmonad. And the solution is simple: <strong>we make xmonad ignore focus requesting messages when xmonad just get started</strong>.</p>
<p>This can be done by modifying xmonad state to include the time when it got started, and wrap the EWMH event handler to check if the message is “too early” before performing the action. By “too early” I meant the time difference between xmonad startup and when the message get received is below a threshold (just leave few seconds as threshold to allow your xmonad startup script gets fully executed).</p>
<h1 id="working-on-code">Working on Code</h1>
<p>First we use <a href="http://xmonad.org/xmonad-docs/xmonad/XMonad-Core.html#t:XState"><code>XState</code></a> to make xmonad record its startup time. This can be done easily using <a href="http://xmonad.org/xmonad-docs/xmonad-contrib/XMonad-Util-ExtensibleState.html"><code>XMonad.Util.ExtensibleState</code></a> from <a href="http://xmonad.org/xmonad-docs/xmonad-contrib/">xmonad-contrib</a>.</p>
<p>What we need is a new type of data so that we can put it into <code>XState</code>. And the data we need is just the startup time:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="ot">{-# LANGUAGE DeriveDataTypeable #-}</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="kw">import</span> <span class="dt">XMonad.Core</span></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">XMonad.Util.ExtensibleState</span> <span class="kw">as</span> <span class="dt">XS</span></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="kw">import</span> <span class="dt">Data.Time.Clock</span></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="kw">import</span> <span class="dt">Data.Typeable</span></span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="kw">import</span> <span class="dt">Data.Time.Calendar</span></span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="kw">newtype</span> <span class="dt">StartupTime</span> <span class="ot">=</span></span>
<span id="cb1-8"><a href="#cb1-8"></a>    <span class="dt">StartupTime</span> <span class="dt">UTCTime</span></span>
<span id="cb1-9"><a href="#cb1-9"></a>        <span class="kw">deriving</span> <span class="dt">Typeable</span></span>
<span id="cb1-10"><a href="#cb1-10"></a></span>
<span id="cb1-11"><a href="#cb1-11"></a><span class="kw">instance</span> <span class="dt">ExtensionClass</span> <span class="dt">StartupTime</span> <span class="kw">where</span></span>
<span id="cb1-12"><a href="#cb1-12"></a>    initialValue <span class="ot">=</span> <span class="dt">StartupTime</span> <span class="op">$</span> <span class="dt">UTCTime</span> d dt</span>
<span id="cb1-13"><a href="#cb1-13"></a>        <span class="kw">where</span></span>
<span id="cb1-14"><a href="#cb1-14"></a>            d <span class="ot">=</span> fromGregorian <span class="dv">1970</span> <span class="dv">1</span> <span class="dv">1</span></span>
<span id="cb1-15"><a href="#cb1-15"></a>            dt <span class="ot">=</span> secondsToDiffTime <span class="dv">0</span></span></code></pre></div>
<p>We don't have to deal with <code>extensionType</code>, as it is default to <code>StateExtension</code>. Of course we want the startup time updated after an xmonad restart. And actually we would never use <code>initialValue</code> since we will update it immediately after xmonad gets started, but we need to put some value here to make compiler happy, we could have put an <code>undefined</code> or <code>error "msg"</code> here, but I chose the safest way.</p>
<p>Next, we modify <code>startupHook</code> to record its startup time:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">import</span> <span class="dt">Control.Applicative</span></span>
<span id="cb2-2"><a href="#cb2-2"></a></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="ot">myStartupHook ::</span> <span class="dt">X</span> ()</span>
<span id="cb2-4"><a href="#cb2-4"></a>myStartupHook <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb2-5"><a href="#cb2-5"></a>    <span class="co">-- &lt;your original startupHook, can leave this part blank&gt;</span></span>
<span id="cb2-6"><a href="#cb2-6"></a>    <span class="dt">StartupTime</span> <span class="op">&lt;$&gt;</span> liftIO getCurrentTime <span class="op">&gt;&gt;=</span> XS.put</span></code></pre></div>
<p>And EWMH is enabled by passing your config into <a href="http://xmonad.org/xmonad-docs/xmonad-contrib/XMonad-Hooks-EwmhDesktops.html#v:ewmh"><code>ewmh</code></a> function so that it adds few more hooks to do its job. We make our own <code>myEwmh</code> to take care of the event handler:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">import</span> <span class="dt">Data.Monoid</span></span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="kw">import</span> import <span class="dt">XMonad.Hooks.EwmhDesktops</span></span>
<span id="cb3-3"><a href="#cb3-3"></a></span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="ot">myEwmh ::</span> <span class="dt">XConfig</span> a <span class="ot">-&gt;</span> <span class="dt">XConfig</span> a</span>
<span id="cb3-5"><a href="#cb3-5"></a>myEwmh c <span class="ot">=</span> c { startupHook     <span class="ot">=</span> startupHook c     <span class="op">&lt;&gt;</span> ewmhDesktopsStartup</span>
<span id="cb3-6"><a href="#cb3-6"></a>             , handleEventHook <span class="ot">=</span> handleEventHook c <span class="op">&lt;&gt;</span> myEwmhDesktopsEventHook</span>
<span id="cb3-7"><a href="#cb3-7"></a>             , logHook         <span class="ot">=</span> logHook c         <span class="op">&lt;&gt;</span> ewmhDesktopsLogHook</span>
<span id="cb3-8"><a href="#cb3-8"></a>             }</span></code></pre></div>
<p>And finally we wrap <code>ewmhDesktopsEventHook</code> in our <code>myEwmhDesktopsEventHook</code> to add an extra guard: if the request is sent right after xmonad gets started (less than 5 seconds in my code), the request gets ignored:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a><span class="ot">myEwmhDesktopsEventHook ::</span> <span class="dt">Event</span> <span class="ot">-&gt;</span> <span class="dt">X</span> <span class="dt">All</span></span>
<span id="cb4-2"><a href="#cb4-2"></a>myEwmhDesktopsEventHook e<span class="op">@</span>(<span class="dt">ClientMessageEvent</span></span>
<span id="cb4-3"><a href="#cb4-3"></a>    {ev_message_type <span class="ot">=</span> mt}) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb4-4"><a href="#cb4-4"></a>    a_aw <span class="ot">&lt;-</span> getAtom <span class="st">&quot;_NET_ACTIVE_WINDOW&quot;</span></span>
<span id="cb4-5"><a href="#cb4-5"></a>    curTime <span class="ot">&lt;-</span> liftIO getCurrentTime</span>
<span id="cb4-6"><a href="#cb4-6"></a>    <span class="dt">StartupTime</span> starupTime <span class="ot">&lt;-</span> XS.get</span>
<span id="cb4-7"><a href="#cb4-7"></a>    <span class="kw">if</span>    mt <span class="op">==</span> a_aw</span>
<span id="cb4-8"><a href="#cb4-8"></a>       <span class="op">&amp;&amp;</span> curTime <span class="ot">`diffUTCTime`</span> starupTime <span class="op">&lt;=</span> <span class="fl">5.0</span></span>
<span id="cb4-9"><a href="#cb4-9"></a>       <span class="kw">then</span> <span class="fu">return</span> (<span class="dt">All</span> <span class="dt">True</span>)</span>
<span id="cb4-10"><a href="#cb4-10"></a>       <span class="kw">else</span> ewmhDesktopsEventHook e</span>
<span id="cb4-11"><a href="#cb4-11"></a>myEwmhDesktopsEventHook e <span class="ot">=</span> ewmhDesktopsEventHook e</span></code></pre></div>
<p>Now you might recompile xmonad and enjoy the change.</p>
<h1 id="resources">Resources</h1>
<p><strong>About my config</strong></p>
<p><a href="https://github.com/Javran/xmonad-javran">My xmonad config</a> is on github, and the changes related to my workaround is visualized <a href="https://github.com/Javran/xmonad-javran/compare/031b99ed70867697...ec2fdb2afe869a62">here</a>.</p>
<p><strong>About EWMH</strong></p>
<p>Googling <code>EWMH</code> would just give you a “tl;dr” specification which is not useful for most of the user.</p>
<p>Simply put, <code>EWMH</code> allows your X11 programs to request for window focus. <a href="https://www.haskell.org/pipermail/xmonad/2013-December/013920.html">One of my old post</a> and <a href="https://www.haskell.org/pipermail/xmonad/2013-December/013921.html">the response</a> provides a little more simple explanation.</p>
</div>
]]></description>
    <pubDate>Thu, 27 Nov 2014 00:00:00 UT</pubDate>
    <guid>http://javran.github.io//posts/2014-11-27-get-rid-of-xmonad-focus-thief.html</guid>
    <dc:creator>Javran Cheng</dc:creator>
</item>
<item>
    <title>Comonad, Zipper and Conway's Game of Life (Part 2)</title>
    <link>http://javran.github.io//posts/2014-08-22-comonad-zipper-and-conways-game-of-life.html</link>
    <description><![CDATA[<span class="blog-date">
    2014-08-22 - 
</span>
<span class="blog-tag">
    
        [ 
        <a href="/tags/haskell.html">haskell</a>, <a href="/tags/comonad.html">comonad</a>, <a href="/tags/zipper.html">zipper</a>, <a href="/tags/type-tetris.html">type-tetris</a>
        ]
    
</span>
<br />
<br />
<div class="blog-main">
<h1 id="intro">Intro</h1>
<p>In the <a href="2014-04-13-comonad-and-conways-game-of-life.html">previous post</a>, We' ve discussed a little bit about comonad. But these abstract concepts are useless without practical usage.</p>
<p>Forget about comonad and Conway's Game of Life for a while. Today I want to show you an interesting example, which will give you some ideas about what it means by saying “the value of one place depends on the value of its neighborhoods”. And these examples will be connect to the concept of comonad in a future post.</p>
<h1 id="d-wave-propagation">2D Wave Propagation</h1>
<p>This example simulates a simple wave propagation by ASCII art.</p>
<p>The “world” is represented by a list of characters, each of which has a special meaning, namely:</p>
<ul>
<li><code>&lt;space&gt;</code> : Just the medium. Air, water, etc.</li>
<li><code>&gt;</code> : a wave moving right.</li>
<li><code>&lt;</code> : a wave moving left.</li>
<li><code>X</code> : two waves with opposite direction meeting each other.</li>
<li><code>*</code> : a wave source which will disappear at the next moment, producing waves in both directions.</li>
</ul>
<p>The simulation of wave propagation will be archieved by continuously printing the next generation of the “world”.</p>
<p>For example, if we are given a string: <code>"*  &gt;  *   *  &lt;  **&lt;"</code>, the output would be the following:</p>
<pre><code>*  &gt;  *   *  &lt;  **&lt;  
 &gt;  &gt;&lt; &gt; &lt; &gt;&lt;  &lt;&lt;X&gt;  
  &gt; &lt;&gt;  X  &lt;&gt; &lt;&lt;&lt; &gt;&gt; 
   X  &gt;&lt; &gt;&lt;  X&lt;&lt;   &gt;&gt;
  &lt; &gt; &lt;&gt; &lt;&gt; &lt;&lt;X     &gt;
 &lt;   X  X  X&lt;&lt; &gt;     
&lt;   &lt; &gt;&lt; &gt;&lt;&lt;X   &gt;
...</code></pre>
<h1 id="propagation-rules">Propagation Rules</h1>
<p>I believe it's easy to see the pattern. And you can write a function to describe the rule. At the first glance you might think the state of a fixed position in the “world” only depends on its previous state and the previous states of its neighborhoods. But it turns out the previous state of itself isn't necessary, but we just leave it as an argument (Simply because I think it looks better).</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="ot">waveRule ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Char</span></span>
<span id="cb2-2"><a href="#cb2-2"></a>waveRule _ l r</span>
<span id="cb2-3"><a href="#cb2-3"></a>    <span class="op">|</span> fromL <span class="op">&amp;&amp;</span> fromR <span class="ot">=</span> <span class="ch">&#39;X&#39;</span></span>
<span id="cb2-4"><a href="#cb2-4"></a>    <span class="op">|</span> fromL          <span class="ot">=</span> <span class="ch">&#39;&gt;&#39;</span></span>
<span id="cb2-5"><a href="#cb2-5"></a>    <span class="op">|</span> fromR          <span class="ot">=</span> <span class="ch">&#39;&lt;&#39;</span></span>
<span id="cb2-6"><a href="#cb2-6"></a>    <span class="op">|</span> <span class="fu">otherwise</span>      <span class="ot">=</span> <span class="ch">&#39; &#39;</span></span>
<span id="cb2-7"><a href="#cb2-7"></a>    <span class="kw">where</span></span>
<span id="cb2-8"><a href="#cb2-8"></a>        fromL <span class="ot">=</span> l <span class="ot">`elem`</span> <span class="st">&quot;&gt;*X&quot;</span></span>
<span id="cb2-9"><a href="#cb2-9"></a>        fromR <span class="ot">=</span> r <span class="ot">`elem`</span> <span class="st">&quot;&lt;*X&quot;</span></span></code></pre></div>
<h1 id="first-solution">First Solution</h1>
<p>(This part is not about zippers or comonads, feel free to skip it) It is not hard to come up with a solution involving only basic list manipulations. I think it would be a good exercise. My solution can be found <a href="https://gist.github.com/Javran/eed695b4f837cc8ea214">here</a>.</p>
<p>The output should be:</p>
<pre><code>*  &gt;  *   *  &lt;  **&lt;
 &gt;  &gt;&lt; &gt; &lt; &gt;&lt;  &lt;&lt;X&gt;
  &gt; &lt;&gt;  X  &lt;&gt; &lt;&lt;&lt; &gt;
   X  &gt;&lt; &gt;&lt;  X&lt;&lt;   
  &lt; &gt; &lt;&gt; &lt;&gt; &lt;&lt;X    
 &lt;   X  X  X&lt;&lt; &gt;   
&lt;   &lt; &gt;&lt; &gt;&lt;&lt;X   &gt;  
   &lt;  &lt;&gt; &lt;X&lt; &gt;   &gt; 
  &lt;  &lt;  X&lt;&lt;&gt;  &gt;   &gt;
 &lt;  &lt;  &lt;&lt;X  &gt;  &gt;   
&lt;  &lt;  &lt;&lt;&lt; &gt;  &gt;  &gt;  
  &lt;  &lt;&lt;&lt;   &gt;  &gt;  &gt; 
 &lt;  &lt;&lt;&lt;     &gt;  &gt;  &gt;
&lt;  &lt;&lt;&lt;       &gt;  &gt;  
  &lt;&lt;&lt;         &gt;  &gt; 
 &lt;&lt;&lt;           &gt;  &gt;
&lt;&lt;&lt;             &gt;  
&lt;&lt;               &gt; 
&lt;                 &gt;
                   </code></pre>
<h1 id="a-limited-view-of-the-world">A Limited View of the World</h1>
<p>Now suppose this 2D world is infinite on both directions, and we introduce the obvious coordinate system into this world. We will no longer see the whole world, but only a portion of it.</p>
<p>Now we are given two coordinates, and we can only observe the world in between these coordinates, can we still work out the problem?</p>
<p>It turns out pretty difficult to reuse the previous approach because:</p>
<ul>
<li><p>Lists can only be infinite in one direction while we need a world representation that can be infinite in both directions so that we are allowed to theoretically view the world in between two arbitrary coordinates.</p></li>
<li><p>Given a world and its previous generation, it is hard to find the “old cell state” or “old neighboring cell states” unless we can introduce something like coordinates to establish the corrspondence between cells.</p></li>
<li><p>We don't know where to start generating the next iteration as the world can be infinite in both directions. We can't simply walk through it from left to right, which might not terminate.</p></li>
</ul>
<p>I'd recommend to use a list <a href="http://en.wikipedia.org/wiki/Zipper_%28data_structure%29">zipper</a> to overcome these problems.</p>
<h1 id="list-zippers">List Zippers</h1>
<p>Zippers are a way to efficiently walk back and forth or update values in certain data structures like lists and trees. Those data structures can usually be traversed in a deterministic way.</p>
<p>A zipper of a certain data structure usually consists of two parts: a stack of data contexts (each data context is an incompete data structure with a “hole” in it), and a value that can fill a “hole”.</p>
<p>Here we are only interested in list zippers. But there are plenty of useful tutorials about zippers like <a href="http://learnyouahaskell.com/zippers">this one</a> from <a href="http://learnyouahaskell.com/chapters">LYAH</a>.</p>
<p>To explain what we just said about zippers, we take a random list <code>[1,2,3]</code> (you should recall that <code>[1,2,3]</code> is just a shorthand for <code>1:2:3:[]</code>) and traverse it to demonstrate list zippers.</p>
<table>
<thead>
<tr class="header">
<th>Stack</th>
<th>Focus</th>
<th>Zipper = (Stack,Focus)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>[]</code></td>
<td><code>[1,2,3]</code></td>
<td><code>([],[1,2,3])</code></td>
</tr>
<tr class="even">
<td><code>[1:&lt;hole&gt;]</code></td>
<td><code>[2,3]</code></td>
<td><code>([1],[2,3])</code></td>
</tr>
<tr class="odd">
<td><code>[2:&lt;hole&gt;, 1:&lt;hole&gt;]</code></td>
<td><code>[3]</code></td>
<td><code>([2,1],[3])</code></td>
</tr>
<tr class="even">
<td><code>[3:&lt;hole&gt;, 2:&lt;hole&gt;, 1:&lt;hole&gt;]</code></td>
<td><code>[]</code></td>
<td><code>([3,2,1],[])</code></td>
</tr>
</tbody>
</table>
<p>A list zipper changes as we are walking in the data structure, the table above shows how the list zipper changes as we walk though a list from left to right. Note that since the data context for a list is always something like <code>(&lt;value&gt;:&lt;hole&gt;)</code>, we can simply represent it as <code>&lt;value&gt;</code>. That is why a list zipper are usually represented as a pair of two lists, or to be more precise, a stack and a list.</p>
<p>The data context stack makes it possible to traverse backwards. Whenever we want to do so, pop one data context from the stack, and fill in its hole by using the current focus. For example, to go backwards when the list zipper is <code>([2,1],[3])</code>, we pop the data context to get <code>2:&lt;hole&gt;</code>, fill in the hole with our current focus, namely <code>[3]</code> and we end up with <code>([1],2:[3])</code> whose focus is changed from <code>[3]</code> to <code>[2,3]</code>.</p>
<p>We can also change the value at the focus efficiently. For example, when the list zipper is <code>([2,1],[3])</code>, we modify the focus to <code>[4,5,6]</code>. And then we keep going backwards to recover the list. We will end up with <code>1:2:[4,5,6]</code> and as you can see the part we were focusing on (namely <code>[3]</code>) is now replaced by <code>[4,5,6]</code>.</p>
<h1 id="list-zippers-to-the-rescue">List Zippers to the Rescue</h1>
<p>With some introduction of zippers, I can now explain how can list zippers solve our problem.</p>
<ul>
<li><p>List zippers can be infinite in both directions by using a simple trick: make the context stack infinite. It is an importation observation that the stack in the list zipper are actually the reversed left part of the list and the focus the right part. By making both the reversed left part and right part infinite, we end up with a list zipper that is infinite in both directions.</p></li>
<li><p>It's quite easy to find “old cell state” and “old neighboring cell states” given the list zipper. The old cell is the <code>head</code> of the current focus, the cells right next to it are the top of the stack and the second element of the current focus, respectively. Therefore for any given list zipper, we can yield the next cell state of the <code>head</code> of the current focusing list.</p></li>
<li><p>We don't need to worry about where to start generating the next world, given a list zipper, we know how to iteratively move the focus to the left or to the right. So as long as we can pin one position to the origin point of the world, we can take steps based on the original zipper by moving either left or right to focus on the coordinate in question. And a list zipper contains sufficient information to calculate the next cell state in question.</p></li>
</ul>
<h1 id="implementation">Implementation</h1>
<h2 id="zippers">Zippers</h2>
<p>First let's begin with zipper implementations. Since the world can never be empty, it is totally safe to break the focusing data (<code>[a]</code>) into its components (<code>(a,[a])</code>). By rearranging the order of arguments (<code>([a],[a])</code> … <code>([a],(a,[a]))</code> … <code>LZipper a [a] [a]</code>) we have our final version of <code>LZipper</code> here:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a><span class="ot">{-# LANGUAGE DeriveFunctor #-}</span></span>
<span id="cb4-2"><a href="#cb4-2"></a></span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="co">-- | LZipper &lt;current&gt; &lt;left (reversed)&gt; &lt;right&gt;</span></span>
<span id="cb4-4"><a href="#cb4-4"></a><span class="kw">data</span> <span class="dt">LZipper</span> a <span class="ot">=</span> <span class="dt">LZipper</span> a [a] [a]</span>
<span id="cb4-5"><a href="#cb4-5"></a>    <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Functor</span>)</span></code></pre></div>
<p>Here the old focus would be <code>&lt;current&gt;:&lt;right&gt;</code> but we can break the focusing list to make it looks nicer: now a list zipper in our case consists of three parts, a current focus <code>&lt;current&gt;</code>, everything to the left of it <code>&lt;left (reversed)&gt;</code> and everything to the right of it <code>&lt;right&gt;</code>.</p>
<p>With the list zipper definition given, it's easy to define basic operations:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1"></a><span class="co">-- | shift left and right</span></span>
<span id="cb5-2"><a href="#cb5-2"></a>zipperMoveL,<span class="ot"> zipperMoveR ::</span> <span class="dt">LZipper</span> a <span class="ot">-&gt;</span> <span class="dt">LZipper</span> a</span>
<span id="cb5-3"><a href="#cb5-3"></a>zipperMoveL (<span class="dt">LZipper</span> a (x<span class="op">:</span>xs&#39;) ys) <span class="ot">=</span> <span class="dt">LZipper</span> x xs&#39; (a<span class="op">:</span>ys)</span>
<span id="cb5-4"><a href="#cb5-4"></a>zipperMoveL _ <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;Invalid move&quot;</span></span>
<span id="cb5-5"><a href="#cb5-5"></a>zipperMoveR (<span class="dt">LZipper</span> a xs (y<span class="op">:</span>ys&#39;)) <span class="ot">=</span> <span class="dt">LZipper</span> y (a<span class="op">:</span>xs) ys&#39;</span>
<span id="cb5-6"><a href="#cb5-6"></a>zipperMoveR _ <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;Invalid move&quot;</span></span>
<span id="cb5-7"><a href="#cb5-7"></a></span>
<span id="cb5-8"><a href="#cb5-8"></a><span class="co">-- | get the current focusing element</span></span>
<span id="cb5-9"><a href="#cb5-9"></a><span class="ot">current ::</span> <span class="dt">LZipper</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb5-10"><a href="#cb5-10"></a>current (<span class="dt">LZipper</span> v _ _) <span class="ot">=</span> v</span></code></pre></div>
<h2 id="conversion-between-limited-worlds-and-infinite-worlds">Conversion between Limited Worlds and Infinite Worlds</h2>
<p>To initialize the world we need to convert from a list of cells to a zipper which represents the infinite world. This can be achieved by padding the list to make it infinite in both directions:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a><span class="co">-- | initial world to a zipper</span></span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="ot">rangeToZipper ::</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">LZipper</span> a</span>
<span id="cb6-3"><a href="#cb6-3"></a>rangeToZipper v wd <span class="ot">=</span> <span class="kw">case</span> wd <span class="kw">of</span></span>
<span id="cb6-4"><a href="#cb6-4"></a>    []   <span class="ot">-&gt;</span> <span class="dt">LZipper</span> v pad pad</span>
<span id="cb6-5"><a href="#cb6-5"></a>    x<span class="op">:</span>xs <span class="ot">-&gt;</span> <span class="dt">LZipper</span> x pad (xs <span class="op">++</span> pad)</span>
<span id="cb6-6"><a href="#cb6-6"></a>    <span class="kw">where</span></span>
<span id="cb6-7"><a href="#cb6-7"></a>        pad <span class="ot">=</span> <span class="fu">repeat</span> v</span></code></pre></div>
<p>And to view a portion of the infinite world, we take as argument two coordinates and a zipper (the zipper is assumed to point to the origin point), move the zipper to the position specified by one of the coordinate, and then extract the value of the focus from zipper and keep moving the zipper to the other coordinate.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1"></a><span class="co">-- | a view range (coordinates), a zipper to a portion of the world</span></span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="ot">zipperToRange ::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">LZipper</span> a <span class="ot">-&gt;</span> [a]</span>
<span id="cb7-3"><a href="#cb7-3"></a>zipperToRange (i,j) zp <span class="ot">=</span> <span class="fu">fmap</span> current zippers</span>
<span id="cb7-4"><a href="#cb7-4"></a>    <span class="kw">where</span></span>
<span id="cb7-5"><a href="#cb7-5"></a>        zippers <span class="ot">=</span> <span class="fu">take</span> (j <span class="op">-</span> i <span class="op">+</span> <span class="dv">1</span>) (<span class="fu">iterate</span> zipperMoveR startZ)</span>
<span id="cb7-6"><a href="#cb7-6"></a>        startZ <span class="ot">=</span> zipperMoveFocus i zp</span>
<span id="cb7-7"><a href="#cb7-7"></a><span class="ot">        zipperMoveFocus ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">LZipper</span> a <span class="ot">-&gt;</span> <span class="dt">LZipper</span> a</span>
<span id="cb7-8"><a href="#cb7-8"></a>        zipperMoveFocus t z</span>
<span id="cb7-9"><a href="#cb7-9"></a>            <span class="op">|</span> t <span class="op">&gt;</span> <span class="dv">0</span>     <span class="ot">=</span> zipperMoveFocus (t<span class="op">-</span><span class="dv">1</span>) (zipperMoveR z)</span>
<span id="cb7-10"><a href="#cb7-10"></a>            <span class="op">|</span> t <span class="op">&lt;</span> <span class="dv">0</span>     <span class="ot">=</span> zipperMoveFocus (t<span class="op">+</span><span class="dv">1</span>) (zipperMoveL z)</span>
<span id="cb7-11"><a href="#cb7-11"></a>            <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> z</span></code></pre></div>
<h2 id="propagation-rules-1">Propagation Rules</h2>
<p>We modify <code>waveRule</code> function above so that it can produce the next cell state from a zipper. The nice thing about our zipper is that both of the neighboring old cell states can be easily found by pattern matching on arguments.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1"></a><span class="ot">waveRule ::</span> <span class="dt">LZipper</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Char</span></span>
<span id="cb8-2"><a href="#cb8-2"></a>waveRule (<span class="dt">LZipper</span> _ (l<span class="op">:</span>_) (r<span class="op">:</span>_))</span>
<span id="cb8-3"><a href="#cb8-3"></a>    <span class="op">|</span> fromL <span class="op">&amp;&amp;</span> fromR <span class="ot">=</span> <span class="ch">&#39;X&#39;</span></span>
<span id="cb8-4"><a href="#cb8-4"></a>    <span class="op">|</span> fromL          <span class="ot">=</span> <span class="ch">&#39;&gt;&#39;</span></span>
<span id="cb8-5"><a href="#cb8-5"></a>    <span class="op">|</span> fromR          <span class="ot">=</span> <span class="ch">&#39;&lt;&#39;</span></span>
<span id="cb8-6"><a href="#cb8-6"></a>    <span class="op">|</span> <span class="fu">otherwise</span>      <span class="ot">=</span> <span class="ch">&#39; &#39;</span></span>
<span id="cb8-7"><a href="#cb8-7"></a>    <span class="kw">where</span></span>
<span id="cb8-8"><a href="#cb8-8"></a>        fromL <span class="ot">=</span> l <span class="ot">`elem`</span> <span class="st">&quot;&gt;*X&quot;</span></span>
<span id="cb8-9"><a href="#cb8-9"></a>        fromR <span class="ot">=</span> r <span class="ot">`elem`</span> <span class="st">&quot;&lt;*X&quot;</span></span>
<span id="cb8-10"><a href="#cb8-10"></a>waveRule _ <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;null zipper&quot;</span></span></code></pre></div>
<p>And then we rush to complete the main function, assuming <code>nextGen :: LZipper Char -&gt; LZipper Char</code>, a function that takes a zipper and produces a zipper of the next generation. has been implemented for us.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1"></a><span class="ot">nextGen ::</span> <span class="dt">LZipper</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">LZipper</span> <span class="dt">Char</span></span>
<span id="cb9-2"><a href="#cb9-2"></a>nextGen <span class="ot">=</span> <span class="fu">undefined</span></span>
<span id="cb9-3"><a href="#cb9-3"></a></span>
<span id="cb9-4"><a href="#cb9-4"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb9-5"><a href="#cb9-5"></a>main <span class="ot">=</span> <span class="fu">mapM_</span> (<span class="fu">putStrLn</span> <span class="op">.</span> zipperToRange (<span class="op">-</span><span class="dv">20</span>,<span class="dv">40</span>)) (<span class="fu">take</span> <span class="dv">20</span> (<span class="fu">iterate</span> nextGen startZ))</span>
<span id="cb9-6"><a href="#cb9-6"></a>    <span class="kw">where</span></span>
<span id="cb9-7"><a href="#cb9-7"></a>        startStr <span class="ot">=</span> <span class="st">&quot;*  &gt;  *   *  &lt;  **&lt;&quot;</span></span>
<span id="cb9-8"><a href="#cb9-8"></a>        startZ <span class="ot">=</span> rangeToZipper <span class="ch">&#39; &#39;</span> startStr</span></code></pre></div>
<p>In the code above, we take 20 generations, view the world within range <code>(-20,40)</code>.</p>
<h2 id="the-final-missing-piece">The Final Missing Piece</h2>
<p>The only thing missing in our implementation is the <code>nextGen</code> function, this is also where the magic happens. Let's implement it step by step.</p>
<p>By taking its type signature into account, we can write down the shape of the body:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1"></a><span class="ot">nextGen ::</span> <span class="dt">LZipper</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">LZipper</span> <span class="dt">Char</span></span>
<span id="cb10-2"><a href="#cb10-2"></a>nextGen z <span class="ot">=</span> <span class="dt">LZipper</span> c&#39; ls&#39; rs&#39;</span>
<span id="cb10-3"><a href="#cb10-3"></a>    <span class="kw">where</span></span>
<span id="cb10-4"><a href="#cb10-4"></a>        c&#39; <span class="ot">=</span> <span class="fu">undefined</span></span>
<span id="cb10-5"><a href="#cb10-5"></a>        ls&#39; <span class="ot">=</span> <span class="fu">undefined</span></span>
<span id="cb10-6"><a href="#cb10-6"></a>        rs&#39; <span class="ot">=</span> <span class="fu">undefined</span></span></code></pre></div>
<p>And it's not hard to figure out what is <code>c'</code> – the new cell state in correspondence with <code>c</code>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1"></a><span class="ot">nextGen ::</span> <span class="dt">LZipper</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">LZipper</span> <span class="dt">Char</span></span>
<span id="cb11-2"><a href="#cb11-2"></a>nextGen z <span class="ot">=</span> <span class="dt">LZipper</span> c&#39; ls&#39; rs&#39;</span>
<span id="cb11-3"><a href="#cb11-3"></a>    <span class="kw">where</span></span>
<span id="cb11-4"><a href="#cb11-4"></a>        c&#39; <span class="ot">=</span> waveRule z</span>
<span id="cb11-5"><a href="#cb11-5"></a>        ls&#39; <span class="ot">=</span> <span class="fu">undefined</span></span>
<span id="cb11-6"><a href="#cb11-6"></a>        rs&#39; <span class="ot">=</span> <span class="fu">undefined</span></span></code></pre></div>
<p>To figure out <code>ls'</code>, we first try to figure out the first element of it, namely <code>l'</code>:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1"></a><span class="ot">nextGen ::</span> <span class="dt">LZipper</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">LZipper</span> <span class="dt">Char</span></span>
<span id="cb12-2"><a href="#cb12-2"></a>nextGen z <span class="ot">=</span> <span class="dt">LZipper</span> c&#39; ls&#39; rs&#39;</span>
<span id="cb12-3"><a href="#cb12-3"></a>    <span class="kw">where</span></span>
<span id="cb12-4"><a href="#cb12-4"></a>        c&#39; <span class="ot">=</span> waveRule z</span>
<span id="cb12-5"><a href="#cb12-5"></a>        l&#39; <span class="ot">=</span> <span class="fu">undefined</span></span>
<span id="cb12-6"><a href="#cb12-6"></a>        ls&#39; <span class="ot">=</span> l&#39; <span class="op">:</span> <span class="fu">undefined</span></span>
<span id="cb12-7"><a href="#cb12-7"></a>        rs&#39; <span class="ot">=</span> <span class="fu">undefined</span></span></code></pre></div>
<p>Since the focus of <code>l'</code> is the direct neighborhood of <code>c</code>, we can simply move the zipper to calculate its new state:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1"></a><span class="ot">nextGen ::</span> <span class="dt">LZipper</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">LZipper</span> <span class="dt">Char</span></span>
<span id="cb13-2"><a href="#cb13-2"></a>nextGen z <span class="ot">=</span> <span class="dt">LZipper</span> c&#39; ls&#39; rs&#39;</span>
<span id="cb13-3"><a href="#cb13-3"></a>    <span class="kw">where</span></span>
<span id="cb13-4"><a href="#cb13-4"></a>        c&#39; <span class="ot">=</span> waveRule z</span>
<span id="cb13-5"><a href="#cb13-5"></a>        l&#39; <span class="ot">=</span> waveRule <span class="op">.</span> zipperMoveL <span class="op">$</span> z</span>
<span id="cb13-6"><a href="#cb13-6"></a>        ls&#39; <span class="ot">=</span> l&#39; <span class="op">:</span> <span class="fu">undefined</span></span>
<span id="cb13-7"><a href="#cb13-7"></a>        rs&#39; <span class="ot">=</span> <span class="fu">undefined</span></span></code></pre></div>
<p>Comparing <code>c'</code> and <code>l'</code>, we can find the pattern:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1"></a><span class="ot">nextGen ::</span> <span class="dt">LZipper</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">LZipper</span> <span class="dt">Char</span></span>
<span id="cb14-2"><a href="#cb14-2"></a>nextGen z <span class="ot">=</span> <span class="dt">LZipper</span> c&#39; ls&#39; rs&#39;</span>
<span id="cb14-3"><a href="#cb14-3"></a>    <span class="kw">where</span></span>
<span id="cb14-4"><a href="#cb14-4"></a>        c&#39; <span class="ot">=</span> waveRule z</span>
<span id="cb14-5"><a href="#cb14-5"></a>        l&#39; <span class="ot">=</span> waveRule <span class="op">.</span> zipperMoveL <span class="op">$</span> z</span>
<span id="cb14-6"><a href="#cb14-6"></a>        ls&#39; <span class="ot">=</span> [waveRule <span class="op">.</span> zipperMoveL <span class="op">$</span> z, waveRule <span class="op">.</span> zipperMoveL <span class="op">.</span> zipperMoveL <span class="op">$</span> z, <span class="op">...</span>]</span>
<span id="cb14-7"><a href="#cb14-7"></a>        rs&#39; <span class="ot">=</span> <span class="fu">undefined</span></span></code></pre></div>
<p>And the same pattern holds for <code>rs'</code>: we just keep moving the zipper to its left or right, and produce new states by applying <code>waveRule</code> to it. So we end up with:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1"></a><span class="ot">nextGen ::</span> <span class="dt">LZipper</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">LZipper</span> <span class="dt">Char</span></span>
<span id="cb15-2"><a href="#cb15-2"></a>nextGen z <span class="ot">=</span> <span class="dt">LZipper</span> c&#39; ls&#39; rs&#39;</span>
<span id="cb15-3"><a href="#cb15-3"></a>    <span class="kw">where</span></span>
<span id="cb15-4"><a href="#cb15-4"></a>        c&#39; <span class="ot">=</span> waveRule z</span>
<span id="cb15-5"><a href="#cb15-5"></a>        ls&#39; <span class="ot">=</span> <span class="fu">map</span> waveRule <span class="op">.</span> <span class="fu">tail</span> <span class="op">$</span> <span class="fu">iterate</span> zipperMoveL z</span>
<span id="cb15-6"><a href="#cb15-6"></a>        rs&#39; <span class="ot">=</span> <span class="fu">map</span> waveRule <span class="op">.</span> <span class="fu">tail</span> <span class="op">$</span> <span class="fu">iterate</span> zipperMoveR z</span></code></pre></div>
<p>Now the whole program should be complete, if you run it, you will get something like this:</p>
<pre><code>                    *  &gt;  *   *  &lt;  **&lt;                      
                   &lt; &gt;  &gt;&lt; &gt; &lt; &gt;&lt;  &lt;&lt;X&gt;                      
                  &lt;   &gt; &lt;&gt;  X  &lt;&gt; &lt;&lt;&lt; &gt;&gt;                     
                 &lt;     X  &gt;&lt; &gt;&lt;  X&lt;&lt;   &gt;&gt;                    
                &lt;     &lt; &gt; &lt;&gt; &lt;&gt; &lt;&lt;X     &gt;&gt;                   
               &lt;     &lt;   X  X  X&lt;&lt; &gt;     &gt;&gt;                  
              &lt;     &lt;   &lt; &gt;&lt; &gt;&lt;&lt;X   &gt;     &gt;&gt;                 
             &lt;     &lt;   &lt;  &lt;&gt; &lt;X&lt; &gt;   &gt;     &gt;&gt;                
            &lt;     &lt;   &lt;  &lt;  X&lt;&lt;&gt;  &gt;   &gt;     &gt;&gt;               
           &lt;     &lt;   &lt;  &lt;  &lt;&lt;X  &gt;  &gt;   &gt;     &gt;&gt;              
          &lt;     &lt;   &lt;  &lt;  &lt;&lt;&lt; &gt;  &gt;  &gt;   &gt;     &gt;&gt;             
         &lt;     &lt;   &lt;  &lt;  &lt;&lt;&lt;   &gt;  &gt;  &gt;   &gt;     &gt;&gt;            
        &lt;     &lt;   &lt;  &lt;  &lt;&lt;&lt;     &gt;  &gt;  &gt;   &gt;     &gt;&gt;           
       &lt;     &lt;   &lt;  &lt;  &lt;&lt;&lt;       &gt;  &gt;  &gt;   &gt;     &gt;&gt;          
      &lt;     &lt;   &lt;  &lt;  &lt;&lt;&lt;         &gt;  &gt;  &gt;   &gt;     &gt;&gt;         
     &lt;     &lt;   &lt;  &lt;  &lt;&lt;&lt;           &gt;  &gt;  &gt;   &gt;     &gt;&gt;        
    &lt;     &lt;   &lt;  &lt;  &lt;&lt;&lt;             &gt;  &gt;  &gt;   &gt;     &gt;&gt;       
   &lt;     &lt;   &lt;  &lt;  &lt;&lt;&lt;               &gt;  &gt;  &gt;   &gt;     &gt;&gt;      
  &lt;     &lt;   &lt;  &lt;  &lt;&lt;&lt;                 &gt;  &gt;  &gt;   &gt;     &gt;&gt;     
 &lt;     &lt;   &lt;  &lt;  &lt;&lt;&lt;                   &gt;  &gt;  &gt;   &gt;     &gt;&gt;    </code></pre>
<p>Let's call it a day here. In the next part we'll go back to comonads, and its relationship between zippers. And hopefully we will finally see the implementation of Conway's Game of Life.</p>
<h1 id="complete-code">Complete Code</h1>
<p>You can find my complete code from <a href="https://gist.github.com/Javran/926296611a521cb00467">gist</a>.</p>
<h1 id="other-parts">Other parts</h1>
<ul>
<li><a href="2014-04-13-comonad-and-conways-game-of-life.html">Part 1</a></li>
</ul>
</div>
]]></description>
    <pubDate>Fri, 22 Aug 2014 00:00:00 UT</pubDate>
    <guid>http://javran.github.io//posts/2014-08-22-comonad-zipper-and-conways-game-of-life.html</guid>
    <dc:creator>Javran Cheng</dc:creator>
</item>
<item>
    <title>Comonad, Zipper and Conway's Game of Life (Part 1)</title>
    <link>http://javran.github.io//posts/2014-04-13-comonad-and-conways-game-of-life.html</link>
    <description><![CDATA[<span class="blog-date">
    2014-04-13 - 
</span>
<span class="blog-tag">
    
        [ 
        <a href="/tags/haskell.html">haskell</a>, <a href="/tags/comonad.html">comonad</a>, <a href="/tags/zipper.html">zipper</a>, <a href="/tags/type-tetris.html">type-tetris</a>
        ]
    
</span>
<br />
<br />
<div class="blog-main">
<p>(Updated on Aug 22, 2014, better title, add link)</p>
<h1 id="intro">Intro</h1>
<p>Let's go beyond monad, today I want to show you how to play with <a href="http://hackage.haskell.org/package/comonad">comonad</a>. I don't understand the theory behind comonad, but programming with it is quite simple. Basically, I think <strong>it's just an algebraic structure dealing with data context.</strong></p>
<p>In other words, if you find yourself dealing with some recursive data structure, and in that data structure, the value of one place depends on the value of its neighborhoods (some “data context”, not sure if I'm using the right terminology), you probably want to take a look at comonad.</p>
<h1 id="conways-game-of-life">Conway's Game of Life</h1>
<p>To do something interesting with comonad, the first thing came to my mind was <a href="http://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">Game of Life</a>. It's a simple “game” that involves no players. At the beginning, a world is represented as a 2D array of booleans. Then this world evolves following some simple <a href="http://en.wikipedia.org/wiki/Conway%27s_Game_of_Life#Rules">rules</a>.</p>
<p>Looking at these rules, you will find that the next state of a given cell in the world is merely determined by the previous states of itself and its neighborhoods. So I feel Game of Life would be a perfect example for comonad.</p>
<h1 id="comonad">Comonad</h1>
<p>Recall what is a monad in Haskell code:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">class</span> <span class="dt">Functor</span> m <span class="ot">=&gt;</span> <span class="dt">Monad</span> m <span class="kw">where</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="ot">    return ::</span> a <span class="ot">-&gt;</span> m a</span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="ot">    join   ::</span> m (m a) <span class="ot">-&gt;</span> m a</span></code></pre></div>
<p>I lied here because to define a <code>Monad</code>, Haskell does not require you to make it an instance of <code>Functor</code> at the first place. But trust me <a href="http://www.haskell.org/haskellwiki/Functor-Applicative-Monad_Proposal">this requirement will be forced in future</a>.</p>
<p>In addition, I don't define a <code>(&gt;&gt;=)</code> but instead a <code>join</code>, since <code>f &gt;&gt;= m = join (fmap f m)</code>, and <code>m</code> should also be an instance of <code>Functor</code>, this monad definition should be almost equivalent to the one found in the base library.</p>
<p>Whenever we “co-” something, it means to filp every <code>-&gt;</code> into <code>&lt;-</code>. So we know what a comonad would look like:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">class</span> <span class="dt">Functor</span> w <span class="ot">=&gt;</span> <span class="dt">Comonad</span> w <span class="kw">where</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="ot">    extract   ::</span> w a <span class="ot">-&gt;</span> a</span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="ot">    duplicate ::</span> w a <span class="ot">-&gt;</span> w (w a)</span>
<span id="cb2-4"><a href="#cb2-4"></a></span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="ot">    extend    ::</span> (w a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> w a <span class="ot">-&gt;</span> w b</span>
<span id="cb2-6"><a href="#cb2-6"></a><span class="ot">    (=&gt;&gt;)     ::</span> w a <span class="ot">-&gt;</span> (w a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> w b</span></code></pre></div>
<p>Here you can see we flip the type signature for <code>return</code> and <code>join</code>, we get <code>extract</code> and <code>duplicate</code> as results. It's also handy to have <code>extend</code> and <code>(=&gt;&gt;)</code>, which can all be defined in terms of <code>fmap</code> and <code>duplicate</code>, just like <code>(=&lt;&lt;)</code> and <code>(&gt;&gt;=)</code> functions for monad. Let's try to figure out the implementation of <code>extend</code>.</p>
<p>The first step is to bind the arguments of <code>extend</code> to some name (here <code>f</code> and <code>w1</code>), so we can list all the tools available:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="ot">extract    ::</span> <span class="kw">forall</span> a   <span class="op">.</span> w a <span class="ot">-&gt;</span> a</span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="ot">duplicate  ::</span> <span class="kw">forall</span> a   <span class="op">.</span> w a <span class="ot">-&gt;</span> w (w a)</span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="fu">fmap</span><span class="ot">       ::</span> <span class="kw">forall</span> a b <span class="op">.</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> w a <span class="ot">-&gt;</span> w b</span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="ot">f          ::</span> w a <span class="ot">-&gt;</span> b</span>
<span id="cb3-5"><a href="#cb3-5"></a><span class="ot">w1         ::</span> w a</span>
<span id="cb3-6"><a href="#cb3-6"></a><span class="co">-- goal:</span></span>
<span id="cb3-7"><a href="#cb3-7"></a>extend f<span class="ot"> w ::</span> w b</span></code></pre></div>
<p>It's tempting to try <code>f w1 :: b</code>, but it is a dead end. Instead, because <code>f</code> “removes a layer of w”, we can try to add another layer before using <code>f</code>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a>duplicate<span class="ot"> w1          ::</span> w (w a)</span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="fu">fmap</span><span class="ot">                  ::</span> (a&#39; <span class="ot">-&gt;</span> b&#39;) <span class="ot">-&gt;</span> w a&#39; <span class="ot">-&gt;</span> w b&#39;</span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="co">-- where a&#39; = w a, b&#39; = b</span></span>
<span id="cb4-4"><a href="#cb4-4"></a><span class="fu">fmap</span> f (duplicate w1)<span class="ot"> ::</span> w b</span></code></pre></div>
<p>Therefore:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1"></a>extend f w <span class="ot">=</span> <span class="fu">fmap</span> f (duplicate w)</span>
<span id="cb5-2"><a href="#cb5-2"></a>w <span class="op">=&gt;&gt;</span> f    <span class="ot">=</span> extend f w</span></code></pre></div>
<p>or more point-freely:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a>extend f <span class="ot">=</span> <span class="fu">fmap</span> f <span class="op">.</span> duplicate</span>
<span id="cb6-2"><a href="#cb6-2"></a>(<span class="op">=&gt;&gt;</span>)    <span class="ot">=</span> <span class="fu">flip</span> extend</span></code></pre></div>
<h1 id="some-understanding-about-comonad">Some understanding about comonad</h1>
<p>In my opinion, when trying to understand monad, it's more straightforward to begin with understanding <code>fmap</code>, <code>return</code> and <code>join</code>, but in practice, <code>&gt;&gt;=</code> and <code>=&lt;&lt;</code> come in handy. And the same thing happens to comonad: <code>extract</code> and <code>duplicate</code> are easy, and <code>extend</code> and <code>=&gt;&gt;</code> come in handy.</p>
<p>Recall that in the intro section, I said comonad deals with data context. More precisely, (IMHO) it's a type constructor that adds to a data structure the ability of focusing on one particular value and the ability of moving focus.</p>
<ul>
<li><code>extract</code> means to extract a value from the current focus, this can be seen from its type signature <code>extract :: w a -&gt; a</code>.</li>
<li><code>duplicate</code> might not be that straightforward to understand. It means to replace every value in the data structure, with its corresponding context.</li>
</ul>
<p>To make an analogy, assume you are inside of a big building, there are maps indicating the spot you are currently standing. If this building were a comonad, and the focus was on you. I can use <code>extract</code> to directly find you. In addition, there are some places with maps. These maps provides you with not only the whole structure of this building, but also the place where every map itself is located. So if you are inside a building near a map, you can take a picture on the map and send it to me, then I can locate you using <code>extract</code>.</p>
<p>Now suppose there is a building without maps, what <code>duplicate</code> does is just like drawing maps for each place inside the building and putting them to their right places. So <code>w</code> is the building “comonad”, <code>a</code> is a single place inside the building and <code>duplicate :: w a -&gt; w (w a)</code> draws maps and put them to their corresponding places.</p>
<p>And just like <code>(&gt;&gt;=)</code> in monad, <code>(=&gt;&gt;)</code> is more handy to use in comonad. Looking at its signature <code>(=&gt;&gt;) :: (w a -&gt; b) -&gt; w a -&gt; w b</code>, the most interesting part is its first argument, a function of type <code>w a -&gt; b</code>. This argument is exactly where rules come into play: “Given a data with focus (<code>w a</code>), let's determine the next value of the current focus will be (<code>b</code>).”</p>
<p>I'd like to call it a day here. In the future posts, we'll see these functions in action.</p>
<h1 id="other-parts">Other parts</h1>
<ul>
<li><a href="2014-08-22-comonad-zipper-and-conways-game-of-life.html">Part 2</a></li>
</ul>
</div>
]]></description>
    <pubDate>Sun, 13 Apr 2014 00:00:00 UT</pubDate>
    <guid>http://javran.github.io//posts/2014-04-13-comonad-and-conways-game-of-life.html</guid>
    <dc:creator>Javran Cheng</dc:creator>
</item>
<item>
    <title>Start working on exercism</title>
    <link>http://javran.github.io//posts/2014-04-06-start-working-on-exercism.html</link>
    <description><![CDATA[<span class="blog-date">
    2014-04-06 - 
</span>
<span class="blog-tag">
    
        [ 
        <a href="/tags/haskell.html">haskell</a>, <a href="/tags/coding.html">coding</a>
        ]
    
</span>
<br />
<br />
<div class="blog-main">
<p>Since I'll be busy for the next few weeks, I can only devote few of my brain power to easy programming tasks in my spare time. Therefore, these days I've started working on <a href="http://exercism.io/">exercism</a>.</p>
<p>It's a free website and only requires you having a github account. They offer simple programming problems with test suites. You can solve the problem and submit your source code to the website so that other users would look at your code and have comments on it.</p>
<p>The main target is to improve the readability of your code through comments from others and iterative refinements from yourself.</p>
<p>In a word, it's an excellent website to learn things.</p>
<p>My account is <a href="http://exercism.io/Javran">here</a>, feel free to give me comments.</p>
<p>See you there.</p>
</div>
]]></description>
    <pubDate>Sun, 06 Apr 2014 00:00:00 UT</pubDate>
    <guid>http://javran.github.io//posts/2014-04-06-start-working-on-exercism.html</guid>
    <dc:creator>Javran Cheng</dc:creator>
</item>
<item>
    <title>Implement semantic editor combinators</title>
    <link>http://javran.github.io//posts/2014-03-21-implement-semantic-editor-combinators.html</link>
    <description><![CDATA[<span class="blog-date">
    2014-03-21 - 
</span>
<span class="blog-tag">
    
        [ 
        <a href="/tags/haskell.html">haskell</a>, <a href="/tags/lens.html">lens</a>
        ]
    
</span>
<br />
<br />
<div class="blog-main">
<h1 id="intro">Intro</h1>
<p>In <a href="http://conal.net/blog/posts/semantic-editor-combinators">Semantic editor combinators</a>, Conal has shown us a simple but powerful trick of walking into a portion of data and then modifying it.</p>
<p>When I saw this simple idea, I persuaded myself to take it for grainted and tried it out. Even though it works well in practice, I'd like to explain to myself what's happening, which is the motivation of this article.</p>
<p>I'll implement <code>first</code>, <code>second</code>, <code>result</code> and other combinators step by step, and come up with the way to walking into user defined <code>data</code>, which is easy but not presented in Conal's post.</p>
<h1 id="editing-a-pair">Editing a pair</h1>
<p>First we need to think about what the type would be for <code>first</code> and <code>second</code>:</p>
<ul>
<li><p>When we reach for the portion of data, we need to modify it, so we need a function <code>f :: a -&gt; b</code></p></li>
<li><p>We also need a pair of data <code>(x,y) :: (c,d)</code> for this editor's input.</p></li>
<li><p>For <code>first</code>, we want type <code>c = a</code>, and the return value should be of type <code>(b,d)</code></p></li>
<li><p>For <code>second</code>, we want type <code>d = a</code>, and the return value should be of type <code>(c,b)</code></p></li>
</ul>
<p>Put them together, we end up with type signature for <code>first</code> and <code>second</code>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="ot">first  ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a,d) <span class="ot">-&gt;</span> (b,d)</span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="ot">second ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (c,a) <span class="ot">-&gt;</span> (c,b)</span></code></pre></div>
<p>Introduce <code>f</code> and <code>(x,y)</code> for two arguments, and the implementation is straightforward:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="ot">first  ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a,d) <span class="ot">-&gt;</span> (b,d)</span>
<span id="cb2-2"><a href="#cb2-2"></a>first  f (x,y) <span class="ot">=</span> (f x, y)</span>
<span id="cb2-3"><a href="#cb2-3"></a></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="ot">second ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (c,a) <span class="ot">-&gt;</span> (c,b)</span>
<span id="cb2-5"><a href="#cb2-5"></a>second f (x,y) <span class="ot">=</span> (x, f y)</span></code></pre></div>
<p>Let's bring up GHCi for some tests:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a>λ<span class="op">&gt;</span> first (<span class="fu">const</span> <span class="dv">1</span>) (<span class="st">&quot;foo&quot;</span>,<span class="st">&quot;bar&quot;</span>) <span class="co">-- (1, &quot;bar&quot;)</span></span>
<span id="cb3-2"><a href="#cb3-2"></a>(<span class="dv">1</span>,<span class="st">&quot;bar&quot;</span>)</span>
<span id="cb3-3"><a href="#cb3-3"></a>λ<span class="op">&gt;</span> second (<span class="op">*</span> <span class="dv">20</span>) (<span class="dt">Just</span> <span class="dv">1</span>, <span class="dv">1</span>) <span class="co">-- (Just 1, 20)</span></span>
<span id="cb3-4"><a href="#cb3-4"></a>(<span class="dt">Just</span> <span class="dv">1</span>,<span class="dv">20</span>)</span></code></pre></div>
<h1 id="editing-a-function">Editing a function</h1>
<p>There's two way of editing a function: we can either modify the return value (the <code>result</code> combinator), or modify the argument (the <code>argument</code> combinator).</p>
<h2 id="the-result-combinator">the <code>result</code> combinator</h2>
<p>Let's think about the type of <code>result</code>:</p>
<ul>
<li>How to modify a function is given by <code>f :: a -&gt; b</code></li>
<li>The function we want to edit is <code>g :: c -&gt; d</code></li>
<li>We want to modify on the return value of <code>g</code>, therefore <code>d = a</code>.</li>
<li>Then the resulting function should be of type <code>c -&gt; b</code></li>
</ul>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a><span class="ot">result ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (c <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (c <span class="ot">-&gt;</span> b)</span></code></pre></div>
<p>We know that <code>-&gt;</code> is right-associative, (e.g. <code>p -&gt; q -&gt; r</code> and <code>p -&gt; (q -&gt; r)</code> are equivalent) so we can also think <code>result</code> as a function that accepts 3 arguments, and its type signature becomes:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1"></a><span class="ot">result ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (c <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> b</span></code></pre></div>
<p>Introduce <code>f</code> <code>g</code> <code>x</code> for these 3 arguments, and we want a value of type <code>b</code>.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a><span class="ot">result ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (c <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> b</span>
<span id="cb6-2"><a href="#cb6-2"></a>result f g x <span class="ot">=</span> <span class="fu">undefined</span></span></code></pre></div>
<ul>
<li>To produce a value of <code>b</code>, we might need <code>f :: a -&gt; b</code>.</li>
<li>To produce a value of <code>a</code>, we might need <code>g :: c -&gt; a</code>.</li>
<li><code>x</code> is of type <code>c</code></li>
</ul>
<p>Chaining these facts together, we yield the implementation of <code>result</code>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1"></a><span class="ot">result ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (c <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> b</span>
<span id="cb7-2"><a href="#cb7-2"></a>result f g x <span class="ot">=</span> f (g x)</span></code></pre></div>
<p>This is exactly the definition of <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/src/GHC-Base.html#."><code>(.)</code></a>, function composition.</p>
<p>So we end up with:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1"></a><span class="ot">result ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (c <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> b</span>
<span id="cb8-2"><a href="#cb8-2"></a>result <span class="ot">=</span> (<span class="op">.</span>)</span></code></pre></div>
<p>Test it:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1"></a>λ<span class="op">&gt;</span> result (<span class="op">+</span><span class="dv">2</span>) (<span class="op">*</span><span class="dv">5</span>) <span class="dv">1</span> <span class="co">-- 1 * 5 + 2 = 7</span></span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="dv">7</span></span></code></pre></div>
<h2 id="the-argument-combinator">the <code>argument</code> combinator</h2>
<p>Use the same approach, let’s implement <code>argument</code> combinator:</p>
<ul>
<li><code>f :: a -&gt; b</code> to modify the argument</li>
<li><code>g :: c -&gt; d</code> the function to be modified</li>
<li><code>b = c</code> so that the type of <code>f</code> and <code>g</code> matches.</li>
<li>the resulting function should be of type <code>a -&gt; d</code>.</li>
</ul>
<p>Write down the type signature, introduce <code>f</code>, <code>g</code>, <code>x</code>, the goal is to produce a value of type <code>d</code></p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1"></a><span class="ot">argument ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> d</span>
<span id="cb10-2"><a href="#cb10-2"></a>argument f g x <span class="ot">=</span> <span class="fu">undefined</span></span></code></pre></div>
<ul>
<li>To produce a value of <code>d</code>, we might need <code>g :: b -&gt; d</code>.</li>
<li>To produce a value of <code>b</code>, we might need <code>f :: a -&gt; b</code>.</li>
<li><code>x</code> is of type <code>a</code></li>
</ul>
<p>Therefore the definition of <code>argument</code> is:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1"></a><span class="ot">argument ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> d</span>
<span id="cb11-2"><a href="#cb11-2"></a>argument f g x <span class="ot">=</span> g (f x)</span></code></pre></div>
<p>To simplify this, we do some transformations:</p>
<pre><code>  g (f x)
&gt; (g . f) x           -- definition of (.)
&gt; (.) g f x           -- infix operator
&gt; ((.) g f) x         -- property of curried function
&gt; ((flip (.)) f g) x  -- flip
&gt; flip (.) f g x      -- rule of function application</code></pre>
<p>Finally:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1"></a><span class="ot">argument ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> d</span>
<span id="cb13-2"><a href="#cb13-2"></a><span class="co">-- point-free style of: argument f g x = flip (.) f g x</span></span>
<span id="cb13-3"><a href="#cb13-3"></a>argument <span class="ot">=</span> <span class="fu">flip</span> (<span class="op">.</span>)</span></code></pre></div>
<p>Test it:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1"></a>λ<span class="op">&gt;</span> argument <span class="fu">show</span> (\x <span class="ot">-&gt;</span> x <span class="op">++</span> <span class="st">&quot;!&quot;</span>) <span class="dv">2048</span> <span class="co">-- 2048!</span></span>
<span id="cb14-2"><a href="#cb14-2"></a><span class="st">&quot;2048!&quot;</span></span></code></pre></div>
<h1 id="walking-into-data">Walking into data</h1>
<p>For now we have <code>first</code> and <code>second</code> to work with pairs, and <code>argument</code> and <code>result</code> with functions, but sometimes we want to go deeper inside data, say:</p>
<ul>
<li>Goal 1: we want <code>2</code> to be <code>5</code> in <code>(7,(2,1))</code></li>
<li>Goal 2: we want <code>a+b</code> to be <code>(a+b)*2</code> in <code>\a -&gt; (a+1 ,\b -&gt; (a+b, 1))</code></li>
</ul>
<p>Here I try to give some explanation of how to do this.</p>
<h2 id="goal-1">Goal 1</h2>
<p>To modify <code>d</code> in <code>(a,(c,d))</code>, that means we need to first focus on <code>(c,d)</code>, this can be achieved by <code>second</code>, let’s pass a const function <code>const "Focus"</code> to <code>second</code>, so we know we are focusing on which portion of the data:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1"></a>λ<span class="op">&gt;</span> <span class="kw">let</span> d1 <span class="ot">=</span> (<span class="dv">7</span>,(<span class="dv">2</span>,<span class="dv">1</span>))</span>
<span id="cb15-2"><a href="#cb15-2"></a>λ<span class="op">&gt;</span> <span class="kw">let</span> toFocus <span class="ot">=</span> <span class="fu">const</span> <span class="st">&quot;Focus&quot;</span></span>
<span id="cb15-3"><a href="#cb15-3"></a>λ<span class="op">&gt;</span> second toFocus d1</span>
<span id="cb15-4"><a href="#cb15-4"></a>(<span class="dv">7</span>,<span class="st">&quot;Focus&quot;</span>)</span></code></pre></div>
<p>We now know that missing <code>(2,1)</code> is passed to <code>toFocus</code>, we can use a lambda expression to capture it:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1"></a>λ<span class="op">&gt;</span> second (\x <span class="ot">-&gt;</span> x) d1</span>
<span id="cb16-2"><a href="#cb16-2"></a>(<span class="dv">7</span>,(<span class="dv">2</span>,<span class="dv">1</span>))</span></code></pre></div>
<p>Let's do something more interesting:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1"></a>λ<span class="op">&gt;</span> second (\x <span class="ot">-&gt;</span> <span class="kw">let</span> (a,b) <span class="ot">=</span> x <span class="kw">in</span> (a<span class="op">+</span><span class="dv">1</span>,b,b)) d1</span>
<span id="cb17-2"><a href="#cb17-2"></a>(<span class="dv">7</span>,(<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">1</span>))</span></code></pre></div>
<p>The observation is: inside the body of lambda expression <code>\x -&gt; ...</code>, we can do something to <code>(2,1)</code>. That means we can apply semantic editor combinators on it!</p>
<p>Now assume we are dealing with <code>(2,1)</code>, to reach the goal, we apply <code>const 5</code> to its <code>fst</code> part:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1"></a>λ<span class="op">&gt;</span> first (<span class="fu">const</span> <span class="dv">5</span>) (<span class="dv">2</span>,<span class="dv">1</span>)</span>
<span id="cb18-2"><a href="#cb18-2"></a>(<span class="dv">5</span>,<span class="dv">1</span>)</span></code></pre></div>
<p>Now replace the body of <code>\x -&gt; ...</code> with what we want:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1"></a>λ<span class="op">&gt;</span> second (\x <span class="ot">-&gt;</span> first (<span class="fu">const</span> <span class="dv">5</span>) x) d1</span>
<span id="cb19-2"><a href="#cb19-2"></a>(<span class="dv">7</span>,(<span class="dv">5</span>,<span class="dv">1</span>))</span></code></pre></div>
<p>Done!</p>
<h2 id="some-intuition">Some intuition</h2>
<p>Let's not hurry to Goal 2, I’ll show you some transformations:</p>
<pre><code>  second (\x -&gt; first (const 5) x) d1
&gt; second (first (const 5)) d1         -- eta reduction / point-free
&gt; (second (first (const 5))) d1       -- rule of function application
&gt; ((second . first) (const 5)) d1     -- definition of (.)</code></pre>
<p>I don’t simplify it to <code>(second . first) (const 5) d1</code> on purpose, and I’m going to show you why.</p>
<p>It might not be straightforward at first glance, since function composition is usually “right to left”, that is, <code>(g . f)</code> means “first apply <code>f</code>, on its result, apply <code>g</code>. But here, <code>second . first</code> can be read as”walk to the <code>snd</code> part, and then <code>fst</code> part of it".</p>
<p>My explanation is: <strong>the function does compose from right to left, but what’s “carrying” with the composition is not the data</strong>.</p>
<p>The observation is: no matter how many functions are composed together, the resulting function just takes one argument:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1"></a>λ<span class="op">&gt;</span> <span class="kw">let</span> u <span class="ot">=</span> <span class="fu">undefined</span></span>
<span id="cb21-2"><a href="#cb21-2"></a>λ<span class="op">&gt;</span> <span class="op">:</span>t u <span class="op">.</span> u</span>
<span id="cb21-3"><a href="#cb21-3"></a>u <span class="op">.</span><span class="ot"> u ::</span> a <span class="ot">-&gt;</span> c</span>
<span id="cb21-4"><a href="#cb21-4"></a>λ<span class="op">&gt;</span> <span class="op">:</span>t u <span class="op">.</span> u <span class="op">.</span> u <span class="op">.</span> u</span>
<span id="cb21-5"><a href="#cb21-5"></a>u <span class="op">.</span> u <span class="op">.</span> u <span class="op">.</span><span class="ot"> u ::</span> a <span class="ot">-&gt;</span> c</span>
<span id="cb21-6"><a href="#cb21-6"></a>λ<span class="op">&gt;</span> <span class="op">:</span>t u <span class="op">.</span> u <span class="op">.</span> u <span class="op">.</span> u <span class="op">.</span> u</span>
<span id="cb21-7"><a href="#cb21-7"></a>u <span class="op">.</span> u <span class="op">.</span> u <span class="op">.</span> u <span class="op">.</span><span class="ot"> u ::</span> a <span class="ot">-&gt;</span> c</span></code></pre></div>
<p>So what is the argument taken by this resulting function? In our Goal 1, it is <code>const 5</code>, the “how we modify it” part. So despite that <code>(second . first) (const 5) d1</code> is simple, to understand it, what you really need would be: <code>((second . first) (const 5)) d1</code></p>
<p>The observation is: <strong>functions are composed from right to left and the mutator is buried more deeply as the composition goes</strong>.</p>
<p>To see this, let's just pick up combinators randomly to form a chain of function composition, and check its type:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1"></a>λ<span class="op">&gt;</span> <span class="op">:</span>t first (<span class="fu">const</span> <span class="dv">5</span>)</span>
<span id="cb22-2"><a href="#cb22-2"></a>first (<span class="fu">const</span> <span class="dv">5</span>)<span class="ot"> ::</span> <span class="dt">Num</span> b <span class="ot">=&gt;</span> (a, d) <span class="ot">-&gt;</span> (b, d)</span>
<span id="cb22-3"><a href="#cb22-3"></a>λ<span class="op">&gt;</span> <span class="op">:</span>t (second <span class="op">.</span> first) (<span class="fu">const</span> <span class="dv">5</span>)</span>
<span id="cb22-4"><a href="#cb22-4"></a>(second <span class="op">.</span> first) (<span class="fu">const</span> <span class="dv">5</span>)<span class="ot"> ::</span> <span class="dt">Num</span> b <span class="ot">=&gt;</span> (c, (a, d)) <span class="ot">-&gt;</span> (c, (b, d))</span>
<span id="cb22-5"><a href="#cb22-5"></a>λ<span class="op">&gt;</span> <span class="op">:</span>t (result <span class="op">.</span> second <span class="op">.</span> first) (<span class="fu">const</span> <span class="dv">5</span>)</span>
<span id="cb22-6"><a href="#cb22-6"></a>(result <span class="op">.</span> second <span class="op">.</span> first) (<span class="fu">const</span> <span class="dv">5</span>)</span>
<span id="cb22-7"><a href="#cb22-7"></a><span class="ot">  ::</span> <span class="dt">Num</span> b <span class="ot">=&gt;</span> (c <span class="ot">-&gt;</span> (c1, (a, d))) <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> (c1, (b, d))</span>
<span id="cb22-8"><a href="#cb22-8"></a>λ<span class="op">&gt;</span> <span class="op">:</span>t (second <span class="op">.</span> result <span class="op">.</span> second <span class="op">.</span> first) (<span class="fu">const</span> <span class="dv">5</span>)</span>
<span id="cb22-9"><a href="#cb22-9"></a>(second <span class="op">.</span> result <span class="op">.</span> second <span class="op">.</span> first) (<span class="fu">const</span> <span class="dv">5</span>)</span>
<span id="cb22-10"><a href="#cb22-10"></a><span class="ot">  ::</span> <span class="dt">Num</span> b <span class="ot">=&gt;</span> (c, c1 <span class="ot">-&gt;</span> (c2, (a, d))) <span class="ot">-&gt;</span> (c, c1 <span class="ot">-&gt;</span> (c2, (b, d)))</span>
<span id="cb22-11"><a href="#cb22-11"></a>λ<span class="op">&gt;</span> <span class="op">:</span>t (first <span class="op">.</span> second <span class="op">.</span> result <span class="op">.</span> second <span class="op">.</span> first) (<span class="fu">const</span> <span class="dv">5</span>)</span>
<span id="cb22-12"><a href="#cb22-12"></a>(first <span class="op">.</span> second <span class="op">.</span> result <span class="op">.</span> second <span class="op">.</span> first) (<span class="fu">const</span> <span class="dv">5</span>)</span>
<span id="cb22-13"><a href="#cb22-13"></a><span class="ot">  ::</span> <span class="dt">Num</span> b <span class="ot">=&gt;</span></span>
<span id="cb22-14"><a href="#cb22-14"></a>     ((c, c1 <span class="ot">-&gt;</span> (c2, (a, d1))), d) <span class="ot">-&gt;</span> ((c, c1 <span class="ot">-&gt;</span> (c2, (b, d1))), d)</span></code></pre></div>
<p>Reading the composition from right to left, <strong>we are constructing / definiting the “shape” of the data this combinator would like to work on</strong>. In contrast, reading from left to right, <strong>we are deconstructing the data until we reach for the position that we want to modify</strong>. These two views does not conflict with each other.</p>
<p>Therefore, IMHO, when we are thinking about how to walking into the interesting portion, it's helpful thinking about build up combinator from left to right. But to answer the question about why, we should instead read from right to left.</p>
<p>In addition, here is another interesting observation:</p>
<pre><code>    (&lt;comb1&gt; . &lt;comb2&gt;) (&lt;comb3&gt; . &lt;mutator&gt;) d1
&lt;=&gt; (&lt;comb1&gt; . &lt;comb2&gt; . &lt;comb3&gt;) &lt;mutator&gt; d1</code></pre>
<p>The shape of semantic editor combinators are always: <code>{comb} {mut} {dat}</code></p>
<p>So if we see a combinator appear as the head of the <code>(.)</code> chain in <code>{mut}</code>, we can move it to the tail of the <code>(.)</code> chain in <code>{comb}</code>, and the other way around also holds true.</p>
<h2 id="goal-2">Goal 2</h2>
<p>Recall Goal 2: we want <code>a+b</code> to be <code>(a+b)*2</code> in <code>\a -&gt; (a+1, \b -&gt; (a+b, 1))</code></p>
<p>Based on the previous understand, we need to:</p>
<ul>
<li>walk into <code>(a+1, \b -&gt; (a+b, 1))</code>, using <code>result</code></li>
<li>walk into <code>\b -&gt; (a+b, 1)</code>, using <code>second</code></li>
<li>walk into <code>(a+b, 1)</code>, using <code>result</code></li>
<li>walk into <code>(a+b)</code>, using <code>first</code></li>
<li>apply <code>(* 2)</code></li>
</ul>
<p>Try it out:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1"></a>λ<span class="op">&gt;</span> <span class="kw">let</span> d2 <span class="ot">=</span> \a <span class="ot">-&gt;</span> (a<span class="op">+</span><span class="dv">1</span>, \b <span class="ot">-&gt;</span> (a<span class="op">+</span>b, <span class="dv">1</span>))</span>
<span id="cb24-2"><a href="#cb24-2"></a>λ<span class="op">&gt;</span> <span class="kw">let</span> m2 <span class="ot">=</span> (result <span class="op">.</span> second <span class="op">.</span> result <span class="op">.</span> first) (<span class="op">*</span><span class="dv">2</span>) d2</span>
<span id="cb24-3"><a href="#cb24-3"></a>λ<span class="op">&gt;</span> (<span class="fu">snd</span> (d2 <span class="dv">10</span>)) <span class="dv">20</span></span>
<span id="cb24-4"><a href="#cb24-4"></a>(<span class="dv">30</span>,<span class="dv">1</span>)</span>
<span id="cb24-5"><a href="#cb24-5"></a>λ<span class="op">&gt;</span> (<span class="fu">snd</span> (m2 <span class="dv">10</span>)) <span class="dv">20</span></span>
<span id="cb24-6"><a href="#cb24-6"></a>(<span class="dv">60</span>,<span class="dv">1</span>)</span>
<span id="cb24-7"><a href="#cb24-7"></a>λ<span class="op">&gt;</span> <span class="fu">fst</span> ((<span class="fu">snd</span> (d2 <span class="dv">10</span>)) <span class="dv">20</span>)</span>
<span id="cb24-8"><a href="#cb24-8"></a><span class="dv">30</span></span>
<span id="cb24-9"><a href="#cb24-9"></a>λ<span class="op">&gt;</span> <span class="fu">fst</span> ((<span class="fu">snd</span> (m2 <span class="dv">10</span>)) <span class="dv">20</span>)</span>
<span id="cb24-10"><a href="#cb24-10"></a><span class="dv">60</span></span>
<span id="cb24-11"><a href="#cb24-11"></a>λ<span class="op">&gt;</span> (<span class="fu">fst</span> <span class="op">.</span> (<span class="op">$</span> <span class="dv">20</span>) <span class="op">.</span> <span class="fu">snd</span> <span class="op">.</span> (<span class="op">$</span> <span class="dv">10</span>)) d2</span>
<span id="cb24-12"><a href="#cb24-12"></a><span class="dv">30</span></span>
<span id="cb24-13"><a href="#cb24-13"></a>λ<span class="op">&gt;</span> (<span class="fu">fst</span> <span class="op">.</span> (<span class="op">$</span> <span class="dv">20</span>) <span class="op">.</span> <span class="fu">snd</span> <span class="op">.</span> (<span class="op">$</span> <span class="dv">10</span>)) m2</span>
<span id="cb24-14"><a href="#cb24-14"></a><span class="dv">60</span></span></code></pre></div>
<p>Last two programs are just rewriting the two programs right before it, Do you notice the symmetry between <code>fst . ($ 20) . snd . ($ 10)</code> and <code>result . second . result . first</code>?</p>
<p>I believe this is not an accident, but to explain it might beyond my reach, this is what I have for now:</p>
<p>With the help of <a href="http://www.haskell.org/haskellwiki/Lambdabot">Lambdabot</a>:</p>
<pre><code>   (fst . ($ 20) . snd . ($ 10)) (result . second . result . first) (*2) d2
&gt;  fst (snd (result (second (result (first 10)))) 20) (2 *) d2</code></pre>
<p>I guess when <code>fst</code> and <code>first</code> meet together, or when <code>($ 10)</code> and <code>result</code> meet together, etc. they will be somehow “cancelled”. If someone knows how to finish this explanation, please let me know.</p>
<h1 id="play-with-lists">Play with lists</h1>
<p>Conal has shown us <code>element</code>, which walks into every element of a list.</p>
<p>It’s easy to work out its type signature:</p>
<ul>
<li>how to modify: <code>f :: a -&gt; b</code></li>
<li>data to be modified: <code>[a]</code></li>
<li>resulting data: <code>[b]</code></li>
</ul>
<p>and this is exactly <code>map</code>.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1"></a><span class="ot">element ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</span>
<span id="cb26-2"><a href="#cb26-2"></a>element <span class="ot">=</span> <span class="fu">map</span></span></code></pre></div>
<p>Here I show you 3 extra combinators:</p>
<p><em>inHead</em> modifies the head of a list:</p>
<ul>
<li>how to modify: <code>f :: a -&gt; a</code> (list can only contain elements of same types)</li>
<li>data to be modified: <code>[a]</code></li>
<li>resulting data: <code>[a]</code></li>
</ul>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1"></a><span class="ot">inHead ::</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb27-2"><a href="#cb27-2"></a>inHead f [] <span class="ot">=</span> []</span>
<span id="cb27-3"><a href="#cb27-3"></a>inHead f (x<span class="op">:</span>xs) <span class="ot">=</span> f x <span class="op">:</span> xs</span></code></pre></div>
<p><em>inTail</em> modifies the tail of a list:</p>
<ul>
<li>how to modify: <code>f :: [a] -&gt; [a]</code></li>
<li>data to be modified: <code>[a]</code></li>
<li>resulting data: <code>[a]</code></li>
</ul>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1"></a><span class="ot">inTail ::</span> ([a] <span class="ot">-&gt;</span> [a]) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb28-2"><a href="#cb28-2"></a>inTail f [] <span class="ot">=</span> []</span>
<span id="cb28-3"><a href="#cb28-3"></a>inTail f (x<span class="op">:</span>xs) <span class="ot">=</span> x <span class="op">:</span> f xs</span></code></pre></div>
<p><em>inPos</em> modifies the element at a given position:</p>
<ul>
<li>we first need the position: <code>Int</code></li>
<li>how to modify: <code>f :: a -&gt; a</code></li>
<li>data to be modified: <code>[a]</code></li>
<li>resulting data: <code>[a]</code></li>
</ul>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1"></a><span class="ot">inPos ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb29-2"><a href="#cb29-2"></a>inPos n f xs</span>
<span id="cb29-3"><a href="#cb29-3"></a>      <span class="op">|</span> <span class="fu">null</span> xs    <span class="ot">=</span> xs</span>
<span id="cb29-4"><a href="#cb29-4"></a>      <span class="op">|</span> n <span class="op">&lt;</span> <span class="dv">0</span>      <span class="ot">=</span> xs</span>
<span id="cb29-5"><a href="#cb29-5"></a>      <span class="op">|</span> n <span class="op">==</span> <span class="dv">0</span>     <span class="ot">=</span> <span class="kw">let</span> (y<span class="op">:</span>ys) <span class="ot">=</span> xs</span>
<span id="cb29-6"><a href="#cb29-6"></a>                     <span class="kw">in</span> f y <span class="op">:</span> ys</span>
<span id="cb29-7"><a href="#cb29-7"></a>      <span class="op">|</span> <span class="fu">otherwise</span>  <span class="ot">=</span> <span class="kw">let</span> (y<span class="op">:</span>ys) <span class="ot">=</span> xs</span>
<span id="cb29-8"><a href="#cb29-8"></a>                     <span class="kw">in</span> y <span class="op">:</span> inPos (n <span class="op">-</span> <span class="dv">1</span>) f ys</span></code></pre></div>
<p><em>inSome</em> is like <code>inPos</code>, but modifies multiple positions:</p>
<ul>
<li>we first need the indices: <code>[Int]</code></li>
<li>how to modify: <code>f :: a -&gt; a</code></li>
<li>data to be modified: <code>[a]</code></li>
<li>resulting data: <code>[a]</code></li>
</ul>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1"></a><span class="ot">inSome ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb30-2"><a href="#cb30-2"></a>inSome ixs f xs <span class="ot">=</span> <span class="fu">foldl</span> (\acc i <span class="ot">-&gt;</span> inPos i f acc) xs ixs</span></code></pre></div>
<p>Some examples:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1"></a>λ<span class="op">&gt;</span> <span class="kw">let</span> d1 <span class="ot">=</span> (<span class="st">&quot;foo&quot;</span>,[<span class="dv">1</span><span class="op">..</span><span class="dv">10</span>])</span>
<span id="cb31-2"><a href="#cb31-2"></a>λ<span class="op">&gt;</span> (second <span class="op">.</span> element) (<span class="op">+</span> <span class="dv">1</span>) d1</span>
<span id="cb31-3"><a href="#cb31-3"></a>(<span class="st">&quot;foo&quot;</span>,[<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>,<span class="dv">11</span>])</span>
<span id="cb31-4"><a href="#cb31-4"></a>λ<span class="op">&gt;</span> (first <span class="op">.</span> element) <span class="fu">ord</span> d1</span>
<span id="cb31-5"><a href="#cb31-5"></a>([<span class="dv">102</span>,<span class="dv">111</span>,<span class="dv">111</span>],[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>])</span>
<span id="cb31-6"><a href="#cb31-6"></a>λ<span class="op">&gt;</span> (second <span class="op">.</span> inTail) (<span class="fu">take</span> <span class="dv">2</span>) d1</span>
<span id="cb31-7"><a href="#cb31-7"></a>(<span class="st">&quot;foo&quot;</span>,[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>])</span>
<span id="cb31-8"><a href="#cb31-8"></a>λ<span class="op">&gt;</span> (second <span class="op">.</span> inHead) (<span class="op">*</span> <span class="dv">200</span>) d1</span>
<span id="cb31-9"><a href="#cb31-9"></a>(<span class="st">&quot;foo&quot;</span>,[<span class="dv">200</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>])</span>
<span id="cb31-10"><a href="#cb31-10"></a>λ<span class="op">&gt;</span> (second <span class="op">.</span> inPos <span class="dv">3</span>) (<span class="op">*</span> <span class="dv">200</span>) d1</span>
<span id="cb31-11"><a href="#cb31-11"></a>(<span class="st">&quot;foo&quot;</span>,[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">800</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>])</span>
<span id="cb31-12"><a href="#cb31-12"></a>λ<span class="op">&gt;</span> <span class="kw">let</span> d2 <span class="ot">=</span> <span class="fu">replicate</span> <span class="dv">3</span> (<span class="fu">replicate</span> <span class="dv">4</span> <span class="dv">0</span>)</span>
<span id="cb31-13"><a href="#cb31-13"></a>λ<span class="op">&gt;</span> (inPos <span class="dv">1</span> <span class="op">.</span> inPos <span class="dv">2</span>) (<span class="fu">const</span> <span class="dv">255</span>) d2</span>
<span id="cb31-14"><a href="#cb31-14"></a>[[<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>],[<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">255</span>,<span class="dv">0</span>],[<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>]]</span></code></pre></div>
<h1 id="walking-into-user-defined-data">Walking into user defined data</h1>
<p>Suppose user has defined a binary tree:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1"></a><span class="kw">data</span> <span class="dt">BinTree</span> a <span class="ot">=</span> <span class="dt">Node</span> a</span>
<span id="cb32-2"><a href="#cb32-2"></a>               <span class="op">|</span> <span class="dt">Tree</span> (<span class="dt">BinTree</span> a) (<span class="dt">BinTree</span> a) a</span>
<span id="cb32-3"><a href="#cb32-3"></a>                 <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Functor</span>)</span></code></pre></div>
<p>To write a combinator is easy, just follow the pattern <code>&lt;combinator&gt; &lt;mutator&gt; &lt;data&gt; = &lt;modified-data&gt;</code>:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1"></a><span class="ot">treeV ::</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">BinTree</span> a <span class="ot">-&gt;</span> <span class="dt">BinTree</span> a</span>
<span id="cb33-2"><a href="#cb33-2"></a>treeV f (<span class="dt">Node</span> x) <span class="ot">=</span> <span class="dt">Node</span> (f x)</span>
<span id="cb33-3"><a href="#cb33-3"></a>treeV f (<span class="dt">Tree</span> l r x) <span class="ot">=</span> <span class="dt">Tree</span> l r (f x)</span>
<span id="cb33-4"><a href="#cb33-4"></a></span>
<span id="cb33-5"><a href="#cb33-5"></a><span class="ot">treeElement ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">BinTree</span> a <span class="ot">-&gt;</span> <span class="dt">BinTree</span> b</span>
<span id="cb33-6"><a href="#cb33-6"></a>treeElement <span class="ot">=</span> <span class="fu">fmap</span></span>
<span id="cb33-7"><a href="#cb33-7"></a></span>
<span id="cb33-8"><a href="#cb33-8"></a><span class="ot">treeLeft ::</span> (<span class="dt">BinTree</span> a <span class="ot">-&gt;</span> <span class="dt">BinTree</span> a) <span class="ot">-&gt;</span> <span class="dt">BinTree</span> a <span class="ot">-&gt;</span> <span class="dt">BinTree</span> a</span>
<span id="cb33-9"><a href="#cb33-9"></a>treeLeft f (<span class="dt">Tree</span> l r e) <span class="ot">=</span> <span class="dt">Tree</span> (f l) r e</span>
<span id="cb33-10"><a href="#cb33-10"></a>treeLeft f r <span class="ot">=</span> r</span>
<span id="cb33-11"><a href="#cb33-11"></a></span>
<span id="cb33-12"><a href="#cb33-12"></a><span class="ot">treeRight ::</span> (<span class="dt">BinTree</span> a <span class="ot">-&gt;</span> <span class="dt">BinTree</span> a) <span class="ot">-&gt;</span> <span class="dt">BinTree</span> a <span class="ot">-&gt;</span> <span class="dt">BinTree</span> a</span>
<span id="cb33-13"><a href="#cb33-13"></a>treeRight f (<span class="dt">Tree</span> l r e) <span class="ot">=</span> <span class="dt">Tree</span> l (f r) e</span>
<span id="cb33-14"><a href="#cb33-14"></a>treeRight f r <span class="ot">=</span> r</span>
<span id="cb33-15"><a href="#cb33-15"></a></span>
<span id="cb33-16"><a href="#cb33-16"></a><span class="ot">treeNonLeaf ::</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">BinTree</span> a <span class="ot">-&gt;</span> <span class="dt">BinTree</span> a</span>
<span id="cb33-17"><a href="#cb33-17"></a>treeNonLeaf f (<span class="dt">Tree</span> l r e) <span class="ot">=</span> <span class="dt">Tree</span> (treeNonLeaf f l) (treeNonLeaf f r) (f e)</span>
<span id="cb33-18"><a href="#cb33-18"></a>treeNonLeaf f r <span class="ot">=</span> r</span>
<span id="cb33-19"><a href="#cb33-19"></a></span>
<span id="cb33-20"><a href="#cb33-20"></a><span class="ot">treeLeaf ::</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">BinTree</span> a <span class="ot">-&gt;</span> <span class="dt">BinTree</span> a</span>
<span id="cb33-21"><a href="#cb33-21"></a>treeLeaf f (<span class="dt">Node</span> x) <span class="ot">=</span> <span class="dt">Node</span> (f x)</span>
<span id="cb33-22"><a href="#cb33-22"></a>treeLeaf f (<span class="dt">Tree</span> l r x) <span class="ot">=</span> <span class="dt">Tree</span> (treeLeaf f l) (treeLeaf f r) x</span></code></pre></div>
<p>Here <code>treeElement</code> walks into the data part of each node to do the modification. Since <code>treeElement = fmap</code>, we can generalize <code>element = fmap</code>, to make it work for not only lists and <code>BinTree</code>s, but also any other Functors.</p>
<p><code>treeLeft</code> and <code>treeRight</code> walks into left subtree and right subtree, respectively. But to target at the value of a <code>BinTree</code>, we need <code>treeV</code>, which takes care of walking into the data field of a tree.</p>
<p><code>treeNonLeaf</code> and <code>treeLeaf</code> are just like <code>treeElement</code> but works merely on non-leaf nodes and leaf nodes, respectively.</p>
<p>See them in action:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1"></a>λ<span class="op">&gt;</span> <span class="kw">let</span> d1 <span class="ot">=</span> <span class="dt">Tree</span> (<span class="dt">Tree</span> (<span class="dt">Node</span> (<span class="dv">1</span>,<span class="dv">1</span>)) (<span class="dt">Node</span> (<span class="dv">1</span>,<span class="dv">2</span>)) (<span class="dv">2</span>,<span class="dv">2</span>)) (<span class="dt">Node</span> (<span class="dv">3</span>,<span class="dv">4</span>)) (<span class="dv">5</span>,<span class="dv">6</span>)</span>
<span id="cb34-2"><a href="#cb34-2"></a>λ<span class="op">&gt;</span> (treeElement <span class="op">.</span> first) <span class="fu">even</span> d1 <span class="co">-- test for each node, if the `fst` part is an even?</span></span>
<span id="cb34-3"><a href="#cb34-3"></a><span class="dt">Tree</span> (<span class="dt">Tree</span> (<span class="dt">Node</span> (<span class="dt">False</span>,<span class="dv">1</span>)) (<span class="dt">Node</span> (<span class="dt">False</span>,<span class="dv">2</span>)) (<span class="dt">True</span>,<span class="dv">2</span>)) (<span class="dt">Node</span> (<span class="dt">False</span>,<span class="dv">4</span>)) (<span class="dt">False</span>,<span class="dv">6</span>)</span>
<span id="cb34-4"><a href="#cb34-4"></a>λ<span class="op">&gt;</span> (treeLeft <span class="op">.</span> treeV <span class="op">.</span> first) (<span class="op">*</span> <span class="dv">4</span>) d1 <span class="co">-- walk into left subtree, multiple `fst` part of its value by 4</span></span>
<span id="cb34-5"><a href="#cb34-5"></a><span class="dt">Tree</span> (<span class="dt">Tree</span> (<span class="dt">Node</span> (<span class="dv">1</span>,<span class="dv">1</span>)) (<span class="dt">Node</span> (<span class="dv">1</span>,<span class="dv">2</span>)) (<span class="dv">2</span>,<span class="dv">2</span>)) (<span class="dt">Node</span> (<span class="dv">3</span>,<span class="dv">4</span>)) (<span class="dv">5</span>,<span class="dv">6</span>)</span>
<span id="cb34-6"><a href="#cb34-6"></a>λ<span class="op">&gt;</span> (treeLeft <span class="op">.</span> treeRight <span class="op">.</span> treeV <span class="op">.</span> first) (<span class="op">*</span> <span class="dv">4</span>) d1 <span class="co">-- walk into the right subtree of the left subtree, ..</span></span>
<span id="cb34-7"><a href="#cb34-7"></a><span class="dt">Tree</span> (<span class="dt">Tree</span> (<span class="dt">Node</span> (<span class="dv">1</span>,<span class="dv">1</span>)) (<span class="dt">Node</span> (<span class="dv">4</span>,<span class="dv">2</span>)) (<span class="dv">2</span>,<span class="dv">2</span>)) (<span class="dt">Node</span> (<span class="dv">3</span>,<span class="dv">4</span>)) (<span class="dv">5</span>,<span class="dv">6</span>)</span>
<span id="cb34-8"><a href="#cb34-8"></a>λ<span class="op">&gt;</span> (treeNonLeaf <span class="op">.</span> first) (<span class="fu">const</span> <span class="dv">100</span>) d1 <span class="co">-- for each value of the `fst` part of each non-leaf node</span></span>
<span id="cb34-9"><a href="#cb34-9"></a><span class="dt">Tree</span> (<span class="dt">Tree</span> (<span class="dt">Node</span> (<span class="dv">1</span>,<span class="dv">1</span>)) (<span class="dt">Node</span> (<span class="dv">1</span>,<span class="dv">2</span>)) (<span class="dv">100</span>,<span class="dv">2</span>)) (<span class="dt">Node</span> (<span class="dv">3</span>,<span class="dv">4</span>)) (<span class="dv">100</span>,<span class="dv">6</span>)</span>
<span id="cb34-10"><a href="#cb34-10"></a>λ<span class="op">&gt;</span> (treeLeaf <span class="op">.</span> second) (<span class="fu">const</span> <span class="dv">100</span>) d1 <span class="co">-- for each value of the `snd` part of each leaf node</span></span>
<span id="cb34-11"><a href="#cb34-11"></a><span class="dt">Tree</span> (<span class="dt">Tree</span> (<span class="dt">Node</span> (<span class="dv">1</span>,<span class="dv">100</span>)) (<span class="dt">Node</span> (<span class="dv">1</span>,<span class="dv">100</span>)) (<span class="dv">2</span>,<span class="dv">2</span>)) (<span class="dt">Node</span> (<span class="dv">3</span>,<span class="dv">100</span>)) (<span class="dv">5</span>,<span class="dv">6</span>)</span></code></pre></div>
<h1 id="combining-semantic-editor-combinators">Combining semantic editor combinators</h1>
<p>The semantic editor combinators can also be chained together.</p>
<p>Suppose we have some combinators:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1"></a>λ<span class="op">&gt;</span> <span class="kw">let</span> c13 <span class="ot">=</span> (inPos <span class="dv">1</span>) (<span class="fu">const</span> <span class="dv">3</span>)</span>
<span id="cb35-2"><a href="#cb35-2"></a>λ<span class="op">&gt;</span> <span class="kw">let</span> c05 <span class="ot">=</span> (inPos <span class="dv">0</span>) (<span class="fu">const</span> <span class="dv">5</span>)</span>
<span id="cb35-3"><a href="#cb35-3"></a>λ<span class="op">&gt;</span> <span class="kw">let</span> c06 <span class="ot">=</span> (inPos <span class="dv">0</span>) (<span class="fu">const</span> <span class="dv">6</span>)</span>
<span id="cb35-4"><a href="#cb35-4"></a>λ<span class="op">&gt;</span> <span class="kw">let</span> cf1 <span class="ot">=</span> first (<span class="fu">const</span> <span class="dv">1</span>)</span></code></pre></div>
<p>For a given list, we want to apply <code>c13</code> and <code>c05</code>:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1"></a>λ<span class="op">&gt;</span> <span class="kw">let</span> d <span class="ot">=</span> <span class="fu">replicate</span> <span class="dv">5</span> <span class="dv">0</span></span>
<span id="cb36-2"><a href="#cb36-2"></a>λ<span class="op">&gt;</span> c06 (c13 d)</span>
<span id="cb36-3"><a href="#cb36-3"></a>[<span class="dv">6</span>,<span class="dv">3</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>]</span>
<span id="cb36-4"><a href="#cb36-4"></a>λ<span class="op">&gt;</span> (c06 <span class="op">.</span> c13) d</span>
<span id="cb36-5"><a href="#cb36-5"></a>[<span class="dv">6</span>,<span class="dv">3</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>]</span></code></pre></div>
<p>So we can use function composition to compose semantic editors:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1"></a>λ<span class="op">&gt;</span> <span class="kw">let</span> d2 <span class="ot">=</span> (<span class="dv">10</span>,<span class="fu">replicate</span> <span class="dv">5</span> <span class="dv">0</span>)</span>
<span id="cb37-2"><a href="#cb37-2"></a>λ<span class="op">&gt;</span> (cf1 <span class="op">.</span> (second c13)) d2</span>
<span id="cb37-3"><a href="#cb37-3"></a>(<span class="dv">1</span>,[<span class="dv">0</span>,<span class="dv">3</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>])</span>
<span id="cb37-4"><a href="#cb37-4"></a>λ<span class="op">&gt;</span> (cf1 <span class="op">.</span> (second c13) <span class="op">.</span> (second c05)) d2</span>
<span id="cb37-5"><a href="#cb37-5"></a>(<span class="dv">1</span>,[<span class="dv">5</span>,<span class="dv">3</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>])</span>
<span id="cb37-6"><a href="#cb37-6"></a>λ<span class="op">&gt;</span> (cf1 <span class="op">.</span> (second (c13 <span class="op">.</span> c05))) d2</span>
<span id="cb37-7"><a href="#cb37-7"></a>(<span class="dv">1</span>,[<span class="dv">5</span>,<span class="dv">3</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>])</span></code></pre></div>
<p>The last example says “apply <code>1</code>, (back to the top level and then) walk into the <code>snd</code> part, apply <code>c05</code> and then <code>c13</code>”. I think this “distributive property” will make things extremely flexible.</p>
<p>Since the function composition happens from right to left, if some combinators are trying to modify the same field, the “leftmost” one take effect:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1"></a>λ<span class="op">&gt;</span> (c05 <span class="op">.</span> c06) [<span class="dv">0</span>,<span class="dv">1</span>]</span>
<span id="cb38-2"><a href="#cb38-2"></a>[<span class="dv">5</span>,<span class="dv">1</span>]</span>
<span id="cb38-3"><a href="#cb38-3"></a>λ<span class="op">&gt;</span> (c06 <span class="op">.</span> c05) [<span class="dv">0</span>,<span class="dv">1</span>]</span>
<span id="cb38-4"><a href="#cb38-4"></a>[<span class="dv">6</span>,<span class="dv">1</span>]</span></code></pre></div>
</div>
]]></description>
    <pubDate>Fri, 21 Mar 2014 00:00:00 UT</pubDate>
    <guid>http://javran.github.io//posts/2014-03-21-implement-semantic-editor-combinators.html</guid>
    <dc:creator>Javran Cheng</dc:creator>
</item>
<item>
    <title>Capture the notion of invertible functions</title>
    <link>http://javran.github.io//posts/2014-03-17-capture-the-notion-of-invertible-functions.html</link>
    <description><![CDATA[<span class="blog-date">
    2014-03-17 - 
</span>
<span class="blog-tag">
    
        [ 
        <a href="/tags/haskell.html">haskell</a>
        ]
    
</span>
<br />
<br />
<div class="blog-main">
<h1 id="intro">Intro</h1>
<p>This article is originally posted on <a href="http://codereview.stackexchange.com/questions/44550/capture-the-notion-of-invertible-functions">Code Review</a>. And I think this can also be a good post.</p>
<h1 id="motivation">Motivation</h1>
<p>I find sometimes it is useful to capture the notion of invertible functions.</p>
<p>The idea is that if two functions <code>f :: a -&gt; b</code> and <code>g :: b -&gt; a</code> are the inverse function of each other, and if there is another function <code>h :: b -&gt; b</code>, then <code>h</code> can also work on values of type <code>a</code>.</p>
<p>Moreover, if there<code>f'</code> and <code>g'</code> are another pair of functions that are the inverse function of each other, <code>(f,g)</code> and <code>(f',g')</code> can actually be composed to <code>(f' . f, g . g')</code> and the invertibility still holds.</p>
<p>The following is my attempt to implement this in haskell, and I’m wondering if an existing library can do the same thing (or even more general thing) for me. Also advice and comments about my code are appreciated.</p>
<h1 id="implemnetation">Implemnetation</h1>
<p>First I use records to store two functions:</p>
<pre class="hasekll"><code>data Invertible a b = Invertible
    { into :: a -&gt; b
    , back :: b -&gt; a
    }</code></pre>
<p><code>into</code> means “convert a into b” while <code>back</code> means “convert b back to a”.</p>
<p>And then few helper functions:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="ot">selfInv ::</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Invertible</span> a a</span>
<span id="cb2-2"><a href="#cb2-2"></a>selfInv f <span class="ot">=</span> <span class="dt">Invertible</span> f f</span>
<span id="cb2-3"><a href="#cb2-3"></a></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="ot">flipInv ::</span> <span class="dt">Invertible</span> a b <span class="ot">-&gt;</span> <span class="dt">Invertible</span> b a</span>
<span id="cb2-5"><a href="#cb2-5"></a>flipInv (<span class="dt">Invertible</span> f g) <span class="ot">=</span> <span class="dt">Invertible</span> g f</span>
<span id="cb2-6"><a href="#cb2-6"></a></span>
<span id="cb2-7"><a href="#cb2-7"></a><span class="ot">borrow ::</span> <span class="dt">Invertible</span> a b <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb2-8"><a href="#cb2-8"></a>borrow (<span class="dt">Invertible</span> fIn fOut) g <span class="ot">=</span> fOut <span class="op">.</span> g <span class="op">.</span> fIn</span>
<span id="cb2-9"><a href="#cb2-9"></a></span>
<span id="cb2-10"><a href="#cb2-10"></a><span class="ot">liftInv ::</span> (<span class="dt">Functor</span> f) <span class="ot">=&gt;</span> <span class="dt">Invertible</span> a b <span class="ot">-&gt;</span> <span class="dt">Invertible</span> (f a) (f b)</span>
<span id="cb2-11"><a href="#cb2-11"></a>liftInv (<span class="dt">Invertible</span> a b) <span class="ot">=</span> <span class="dt">Invertible</span> (<span class="fu">fmap</span> a) (<span class="fu">fmap</span> b)</span></code></pre></div>
<p>In the above code <code>borrow</code> will use the pair of functions to make its last argument <code>g</code> available to values of type <code>a</code>. And changing <code>borrow f</code> to <code>borrow (flipInv f)</code> will make <code>g</code> available to values of type <code>b</code>. Therefore <code>borrow</code> captures my initial idea of making a function of type <code>b -&gt; b</code> available for values of <code>a</code> if <code>a</code> and <code>b</code> can be converted to each other.</p>
<p>In addition, <code>Invertible</code> forms a monoid-like structure, I use <code>rappend</code> and <code>rempty</code> to suggest a similiarity between it and <code>Monoid</code>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="ot">rempty ::</span> <span class="dt">Invertible</span> a a</span>
<span id="cb3-2"><a href="#cb3-2"></a>rempty <span class="ot">=</span> selfInv <span class="fu">id</span></span>
<span id="cb3-3"><a href="#cb3-3"></a></span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="ot">rappend ::</span> <span class="dt">Invertible</span> a b</span>
<span id="cb3-5"><a href="#cb3-5"></a>        <span class="ot">-&gt;</span> <span class="dt">Invertible</span> b c</span>
<span id="cb3-6"><a href="#cb3-6"></a>        <span class="ot">-&gt;</span> <span class="dt">Invertible</span> a c</span>
<span id="cb3-7"><a href="#cb3-7"></a>(<span class="dt">Invertible</span> f1 g1) <span class="ot">`rappend`</span> (<span class="dt">Invertible</span> f2 g2) <span class="ot">=</span></span>
<span id="cb3-8"><a href="#cb3-8"></a>    <span class="dt">Invertible</span> (f2 <span class="op">.</span> f1) (g1 <span class="op">.</span> g2)</span></code></pre></div>
<h1 id="examples">Examples</h1>
<p>Here I have two examples to demonstrate that <code>Invertible</code> might be useful.</p>
<h2 id="data-encryption">Data Encryption</h2>
<p>It is natural that <code>Invertible</code> can be used under scenario of symmetric encryption. <code>Invertible (encrypt key) (decrypt key)</code> might be one instance if:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a><span class="ot">encrypt ::</span> <span class="dt">Key</span> <span class="ot">-&gt;</span> <span class="dt">PlainText</span> <span class="ot">-&gt;</span> <span class="dt">CipherText</span></span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="ot">decrypt ::</span> <span class="dt">Key</span> <span class="ot">-&gt;</span> <span class="dt">CipherText</span> <span class="ot">-&gt;</span> <span class="dt">PlainText</span></span></code></pre></div>
<p>To simplify a little, I make an example of <a href="https://en.wikipedia.org/wiki/Caesar_Cipher">Caesar cipher</a> and assume that plain text contains only uppercase letters:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1"></a><span class="co">-- constructor should be invisible from outside</span></span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="kw">newtype</span> <span class="dt">OnlyUpper</span> a <span class="ot">=</span> <span class="dt">OnlyUpper</span></span>
<span id="cb5-3"><a href="#cb5-3"></a>    {<span class="ot"> getOU ::</span> [a]</span>
<span id="cb5-4"><a href="#cb5-4"></a>    } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>, <span class="dt">Functor</span>)</span>
<span id="cb5-5"><a href="#cb5-5"></a></span>
<span id="cb5-6"><a href="#cb5-6"></a><span class="ot">ouAsList ::</span> <span class="dt">Invertible</span> (<span class="dt">OnlyUpper</span> a) [a]</span>
<span id="cb5-7"><a href="#cb5-7"></a>ouAsList <span class="ot">=</span> <span class="dt">Invertible</span> getOU <span class="dt">OnlyUpper</span></span>
<span id="cb5-8"><a href="#cb5-8"></a></span>
<span id="cb5-9"><a href="#cb5-9"></a><span class="ot">onlyUpper ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">OnlyUpper</span> <span class="dt">Char</span></span>
<span id="cb5-10"><a href="#cb5-10"></a>onlyUpper <span class="ot">=</span> <span class="dt">OnlyUpper</span> <span class="op">.</span> <span class="fu">filter</span> isAsciiUpper</span>
<span id="cb5-11"><a href="#cb5-11"></a></span>
<span id="cb5-12"><a href="#cb5-12"></a><span class="ot">upperAsOrd ::</span> <span class="dt">Invertible</span> <span class="dt">Char</span> <span class="dt">Int</span></span>
<span id="cb5-13"><a href="#cb5-13"></a>upperAsOrd <span class="ot">=</span> <span class="dt">Invertible</span> ord&#39; chr&#39;</span>
<span id="cb5-14"><a href="#cb5-14"></a>    <span class="kw">where</span></span>
<span id="cb5-15"><a href="#cb5-15"></a>        ord&#39; x <span class="ot">=</span> <span class="fu">ord</span> x <span class="op">-</span> <span class="fu">ord</span> <span class="ch">&#39;A&#39;</span></span>
<span id="cb5-16"><a href="#cb5-16"></a>        chr&#39; x <span class="ot">=</span> <span class="fu">chr</span> (x <span class="op">+</span> <span class="fu">ord</span> <span class="ch">&#39;A&#39;</span>)</span></code></pre></div>
<p>And Caesar Cipher is basically doing some modular arithmetic:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a><span class="ot">modShift ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Invertible</span> <span class="dt">Int</span> <span class="dt">Int</span></span>
<span id="cb6-2"><a href="#cb6-2"></a>modShift base offset <span class="ot">=</span> <span class="dt">Invertible</span> f g</span>
<span id="cb6-3"><a href="#cb6-3"></a>    <span class="kw">where</span></span>
<span id="cb6-4"><a href="#cb6-4"></a>        f x <span class="ot">=</span> (x <span class="op">+</span> offset) <span class="ot">`mod`</span> base</span>
<span id="cb6-5"><a href="#cb6-5"></a>        g y <span class="ot">=</span> (y <span class="op">+</span> (base <span class="op">-</span> offset)) <span class="ot">`mod`</span> base</span>
<span id="cb6-6"><a href="#cb6-6"></a></span>
<span id="cb6-7"><a href="#cb6-7"></a><span class="ot">caesarShift ::</span> <span class="dt">Invertible</span> <span class="dt">Int</span> <span class="dt">Int</span></span>
<span id="cb6-8"><a href="#cb6-8"></a>caesarShift <span class="ot">=</span> modShift <span class="dv">26</span> <span class="dv">4</span></span>
<span id="cb6-9"><a href="#cb6-9"></a></span>
<span id="cb6-10"><a href="#cb6-10"></a><span class="ot">caesarCipher ::</span> <span class="dt">Invertible</span> (<span class="dt">OnlyUpper</span> <span class="dt">Char</span>) (<span class="dt">OnlyUpper</span> <span class="dt">Char</span>)</span>
<span id="cb6-11"><a href="#cb6-11"></a>caesarCipher <span class="ot">=</span> liftInv (upperAsOrd</span>
<span id="cb6-12"><a href="#cb6-12"></a>                       <span class="co">-- Char &lt;-&gt; Int</span></span>
<span id="cb6-13"><a href="#cb6-13"></a>                       <span class="ot">`rappend`</span> caesarShift</span>
<span id="cb6-14"><a href="#cb6-14"></a>                       <span class="co">-- Int &lt;-&gt; Int</span></span>
<span id="cb6-15"><a href="#cb6-15"></a>                       <span class="ot">`rappend`</span> flipInv upperAsOrd)</span>
<span id="cb6-16"><a href="#cb6-16"></a>                       <span class="co">-- Int &lt;-&gt; Char</span></span></code></pre></div>
<p>One way to use <code>Invertible</code> is just using its <code>into</code> and <code>back</code> as <code>encrypt</code> and <code>decrypt</code>, and <code>Invertible</code> also gives you the power of manipulating encrypyed data as if it was plain text:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1"></a><span class="ot">exampleCaesar ::</span> <span class="dt">IO</span> ()</span>
<span id="cb7-2"><a href="#cb7-2"></a>exampleCaesar <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb7-3"><a href="#cb7-3"></a>    <span class="kw">let</span> encF <span class="ot">=</span> into caesarCipher</span>
<span id="cb7-4"><a href="#cb7-4"></a>        decF <span class="ot">=</span> back caesarCipher</span>
<span id="cb7-5"><a href="#cb7-5"></a>        encrypted <span class="ot">=</span> encF (onlyUpper <span class="st">&quot;THEQUICKBROWNFOX&quot;</span>)</span>
<span id="cb7-6"><a href="#cb7-6"></a>        decrypted <span class="ot">=</span> decF encrypted</span>
<span id="cb7-7"><a href="#cb7-7"></a>        encrypted&#39; <span class="ot">=</span> borrow (flipInv caesarCipher</span>
<span id="cb7-8"><a href="#cb7-8"></a>                             <span class="ot">`rappend`</span> ouAsList) (<span class="op">++</span> <span class="st">&quot;JUMPSOVERTHELAZYDOG&quot;</span>) encrypted</span>
<span id="cb7-9"><a href="#cb7-9"></a>        decrypted&#39; <span class="ot">=</span> decF encrypted&#39;</span>
<span id="cb7-10"><a href="#cb7-10"></a></span>
<span id="cb7-11"><a href="#cb7-11"></a>    <span class="fu">print</span> encrypted</span>
<span id="cb7-12"><a href="#cb7-12"></a>    <span class="co">-- OnlyUpper {getOU = &quot;XLIUYMGOFVSARJSB&quot;}</span></span>
<span id="cb7-13"><a href="#cb7-13"></a>    <span class="fu">print</span> decrypted</span>
<span id="cb7-14"><a href="#cb7-14"></a>    <span class="co">-- OnlyUpper {getOU = &quot;THEQUICKBROWNFOX&quot;}</span></span>
<span id="cb7-15"><a href="#cb7-15"></a></span>
<span id="cb7-16"><a href="#cb7-16"></a>    <span class="fu">print</span> encrypted&#39;</span>
<span id="cb7-17"><a href="#cb7-17"></a>    <span class="co">-- OnlyUpper {getOU = &quot;XLIUYMGOFVSARJSBNYQTWSZIVXLIPEDCHSK&quot;}</span></span>
<span id="cb7-18"><a href="#cb7-18"></a>    <span class="fu">print</span> decrypted&#39;</span>
<span id="cb7-19"><a href="#cb7-19"></a>    <span class="co">-- OnlyUpper {getOU = &quot;THEQUICKBROWNFOXJUMPSOVERTHELAZYDOG&quot;}</span></span></code></pre></div>
<h2 id="matrix-manipulation">Matrix manipulation</h2>
<p>Sometimes it’s convenient to write some code that manipulates matrices using <code>Invertible</code>.</p>
<p>Say there is a list of type <code>[Int]</code> in which <code>0</code> stands for an empty cell, and we want every non-zero element move to their leftmost possible position while preserving the order:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1"></a><span class="ot">compactLeft ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</span>
<span id="cb8-2"><a href="#cb8-2"></a>compactLeft xs <span class="ot">=</span> nonZeros <span class="op">++</span> <span class="fu">replicate</span> (((<span class="op">-</span>) <span class="ot">`on`</span> <span class="fu">length</span>) xs nonZeros) <span class="dv">0</span></span>
<span id="cb8-3"><a href="#cb8-3"></a>    <span class="kw">where</span> nonZeros <span class="ot">=</span> <span class="fu">filter</span> (<span class="op">/=</span> <span class="dv">0</span>) xs</span></code></pre></div>
<p>Now consider 2D matrices, we want to “gravitize” the matrix so that every non-zero element in it falls to {left,right,up,down}-most possible position while preserving the order.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1"></a><span class="kw">data</span> <span class="dt">Dir</span> <span class="ot">=</span> <span class="dt">DU</span> <span class="op">|</span> <span class="dt">DD</span> <span class="op">|</span> <span class="dt">DL</span> <span class="op">|</span> <span class="dt">DR</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Enum</span>, <span class="dt">Show</span>, <span class="dt">Bounded</span>)</span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="ot">gravitizeMat ::</span> <span class="dt">Dir</span> <span class="ot">-&gt;</span> [[<span class="dt">Int</span>]] <span class="ot">-&gt;</span> [[<span class="dt">Int</span>]]</span>
<span id="cb9-3"><a href="#cb9-3"></a>gravitizeMat dir <span class="ot">=</span> borrow invertible (<span class="fu">map</span> compactLeft)</span>
<span id="cb9-4"><a href="#cb9-4"></a>    <span class="kw">where</span> mirrorI <span class="ot">=</span> selfInv (<span class="fu">map</span> <span class="fu">reverse</span>)</span>
<span id="cb9-5"><a href="#cb9-5"></a>        diagonalI <span class="ot">=</span> selfInv transpose</span>
<span id="cb9-6"><a href="#cb9-6"></a>        invertible <span class="ot">=</span> <span class="kw">case</span> dir <span class="kw">of</span></span>
<span id="cb9-7"><a href="#cb9-7"></a>            <span class="dt">DL</span> <span class="ot">-&gt;</span> rempty</span>
<span id="cb9-8"><a href="#cb9-8"></a>            <span class="dt">DR</span> <span class="ot">-&gt;</span> mirrorI</span>
<span id="cb9-9"><a href="#cb9-9"></a>            <span class="dt">DU</span> <span class="ot">-&gt;</span> diagonalI</span>
<span id="cb9-10"><a href="#cb9-10"></a>            <span class="dt">DD</span> <span class="ot">-&gt;</span> diagonalI <span class="ot">`rappend`</span> mirrorI</span></code></pre></div>
<p>here <code>Invertible</code> comes into play by the observation that <code>transpose</code> and <code>map reverse</code> are all invertible (moreover, they are inverse functions of themselves). So that we can tranform matrices and pretend the problem is only “gravitize to the left”.</p>
<p>Here is one example:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1"></a><span class="ot">print2DMat ::</span> (<span class="dt">Show</span> a) <span class="ot">=&gt;</span> [[a]] <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb10-2"><a href="#cb10-2"></a>print2DMat mat <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb10-3"><a href="#cb10-3"></a>    <span class="fu">putStrLn</span> <span class="st">&quot;Matrix: [&quot;</span></span>
<span id="cb10-4"><a href="#cb10-4"></a>    <span class="fu">mapM_</span> <span class="fu">print</span> mat</span>
<span id="cb10-5"><a href="#cb10-5"></a>    <span class="fu">putStrLn</span> <span class="st">&quot;]&quot;</span></span>
<span id="cb10-6"><a href="#cb10-6"></a></span>
<span id="cb10-7"><a href="#cb10-7"></a><span class="ot">exampleMatGravitize ::</span> <span class="dt">IO</span> ()</span>
<span id="cb10-8"><a href="#cb10-8"></a>exampleMatGravitize <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb10-9"><a href="#cb10-9"></a>    <span class="kw">let</span> mat <span class="ot">=</span> [ [<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">2</span>,<span class="dv">0</span>]</span>
<span id="cb10-10"><a href="#cb10-10"></a>              , [<span class="dv">0</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">0</span>]</span>
<span id="cb10-11"><a href="#cb10-11"></a>              , [<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">5</span>]</span>
<span id="cb10-12"><a href="#cb10-12"></a>              ]</span>
<span id="cb10-13"><a href="#cb10-13"></a>    print2DMat mat</span>
<span id="cb10-14"><a href="#cb10-14"></a></span>
<span id="cb10-15"><a href="#cb10-15"></a>    <span class="kw">let</span> showExample d <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb10-16"><a href="#cb10-16"></a>            <span class="fu">putStrLn</span> <span class="op">$</span> <span class="st">&quot;Direction: &quot;</span> <span class="op">++</span> <span class="fu">show</span> d</span>
<span id="cb10-17"><a href="#cb10-17"></a>            print2DMat <span class="op">$</span> gravitizeMat d mat</span>
<span id="cb10-18"><a href="#cb10-18"></a></span>
<span id="cb10-19"><a href="#cb10-19"></a>    <span class="fu">mapM_</span> showExample [<span class="fu">minBound</span> <span class="op">..</span> <span class="fu">maxBound</span>]</span></code></pre></div>
<p>And the result will be:</p>
<pre><code>Matrix: [
[1,0,2,0]
[0,3,4,0]
[0,0,0,5]
]
Direction: DU
Matrix: [
[1,3,2,5]
[0,0,4,0]
[0,0,0,0]
]
Direction: DD
Matrix: [
[0,0,0,0]
[0,0,2,0]
[1,3,4,5]
]
Direction: DL
Matrix: [
[1,2,0,0]
[3,4,0,0]
[5,0,0,0]
]
Direction: DR
Matrix: [
[0,0,1,2]
[0,0,3,4]
[0,0,0,5]
]</code></pre>
<h1 id="complete-code">Complete code</h1>
<p>You can find my complete code from <a href="https://gist.github.com/Javran/9593215">gist</a>.</p>
</div>
]]></description>
    <pubDate>Mon, 17 Mar 2014 00:00:00 UT</pubDate>
    <guid>http://javran.github.io//posts/2014-03-17-capture-the-notion-of-invertible-functions.html</guid>
    <dc:creator>Javran Cheng</dc:creator>
</item>
<item>
    <title>Exploring alternatives</title>
    <link>http://javran.github.io//posts/2014-03-08-exploring-alternatives.html</link>
    <description><![CDATA[<span class="blog-date">
    2014-03-08 - 
</span>
<span class="blog-tag">
    
        [ 
        <a href="/tags/type-tetris.html">type-tetris</a>, <a href="/tags/haskell.html">haskell</a>
        ]
    
</span>
<br />
<br />
<div class="blog-main">
<p>Today I'm going to play with <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Applicative.html#t:Alternative">Alternatives</a>.</p>
<p>(spoiler: I failed to understand what <code>some</code> and <code>many</code> do, and I guess that would be an essential part of getting <code>Alternative</code>. So there's not much thing useful in this article.)</p>
<p>Just as my other type-tetris attempts, this is not a tutorial about <code>Alternative</code>, I'll just provide some examples and intuitions gained throughout playing with it.</p>
<p>I happened to heard this typeclass by a quick scan on typeclassopedia, and there are only few functions related to it, which I think might not take much time to try them all. These are all motivations about this article.</p>
<p>As always, <strong>bold sentences</strong> stands for my intuitions.</p>
<h1 id="a-monoid-on-applicative-functors">“a monoid on applicative functors”</h1>
<p><code>Alternative</code> is a typeclass lied in <code>Control.Applicative</code>, most of the time, I import this package to use functions like <code>&lt;$&gt;</code>, <code>&lt;*&gt;</code> and data type <code>ZipList</code>, but no more. I happened to heard this typeclass by a quick scan on typeclassopedia, and there are only few functions related to it, which I think might not take much time to try them all. These are all motivations about this article.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">import</span> <span class="dt">Control.Applicative</span></span></code></pre></div>
<p>First function in this class is called <code>empty</code>, so I guess <strong><code>Alternative</code> is some typeclass that allows containing nothing</strong>. This would explain why there are so many <code>Applicative</code>s but I can only see <code>[]</code> and <code>Maybe</code> being instances of this typeclass.</p>
<p>The document says <code>Alternative</code> is “a monoid on applicative functors”. So we can make an analogy between <code>(mempty, mappend)</code> from <code>Monoid</code> and <code>(empty, &lt;|&gt;)</code> from <code>Alternative</code>. Let's try it out:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="ot">v1 ::</span> [<span class="dt">String</span>]</span>
<span id="cb2-2"><a href="#cb2-2"></a>v1 <span class="ot">=</span> empty <span class="op">&lt;|&gt;</span> empty <span class="op">&lt;|&gt;</span> empty</span>
<span id="cb2-3"><a href="#cb2-3"></a></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="ot">v2 ::</span> [<span class="dt">String</span>]</span>
<span id="cb2-5"><a href="#cb2-5"></a>v2 <span class="ot">=</span> v1 <span class="op">&lt;|&gt;</span> <span class="fu">pure</span> <span class="st">&quot;foo&quot;</span> <span class="op">&lt;|&gt;</span> <span class="fu">pure</span> <span class="st">&quot;bar&quot;</span></span>
<span id="cb2-6"><a href="#cb2-6"></a></span>
<span id="cb2-7"><a href="#cb2-7"></a><span class="ot">v3 ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span></span>
<span id="cb2-8"><a href="#cb2-8"></a>v3 <span class="ot">=</span> <span class="fu">pure</span> <span class="dv">10</span> <span class="op">&lt;|&gt;</span> <span class="fu">pure</span> <span class="dv">20</span></span>
<span id="cb2-9"><a href="#cb2-9"></a></span>
<span id="cb2-10"><a href="#cb2-10"></a><span class="ot">v4 ::</span> <span class="dt">Maybe</span> <span class="dt">Char</span></span>
<span id="cb2-11"><a href="#cb2-11"></a>v4 <span class="ot">=</span> empty <span class="op">&lt;|&gt;</span> <span class="fu">pure</span> <span class="ch">&#39;A&#39;</span> <span class="op">&lt;|&gt;</span> <span class="fu">undefined</span></span>
<span id="cb2-12"><a href="#cb2-12"></a></span>
<span id="cb2-13"><a href="#cb2-13"></a><span class="ot">v5 ::</span> <span class="dt">Maybe</span> ()</span>
<span id="cb2-14"><a href="#cb2-14"></a>v5 <span class="ot">=</span> empty <span class="op">&lt;|&gt;</span> empty <span class="op">&lt;|&gt;</span> empty</span></code></pre></div>
<p>Let's bring up GHCi:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a>λ<span class="op">&gt;</span> v1</span>
<span id="cb3-2"><a href="#cb3-2"></a>[]</span>
<span id="cb3-3"><a href="#cb3-3"></a>λ<span class="op">&gt;</span> v2</span>
<span id="cb3-4"><a href="#cb3-4"></a>[<span class="st">&quot;foo&quot;</span>,<span class="st">&quot;bar&quot;</span>]</span>
<span id="cb3-5"><a href="#cb3-5"></a>λ<span class="op">&gt;</span> v3</span>
<span id="cb3-6"><a href="#cb3-6"></a><span class="dt">Just</span> <span class="dv">10</span></span>
<span id="cb3-7"><a href="#cb3-7"></a>λ<span class="op">&gt;</span> v4</span>
<span id="cb3-8"><a href="#cb3-8"></a><span class="dt">Just</span> <span class="ch">&#39;A&#39;</span></span>
<span id="cb3-9"><a href="#cb3-9"></a>λ<span class="op">&gt;</span> v5</span>
<span id="cb3-10"><a href="#cb3-10"></a><span class="dt">Nothing</span></span></code></pre></div>
<p><code>empty</code> works like what we expected, and <code>&lt;|&gt;</code> for lists seems straightforward. But when it comes to <code>Maybe</code>, we find that only the first non-<code>Nothing</code> one takes effect, if any.</p>
<h1 id="some-and-many"><code>some</code> and <code>many</code></h1>
<p>The type for <code>some</code> and <code>many</code> are identical, so just fill in some instances I come up with on the fly:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a><span class="ot">v6 ::</span> [[<span class="dt">String</span>]]</span>
<span id="cb4-2"><a href="#cb4-2"></a>v6 <span class="ot">=</span> some [<span class="st">&quot;not working&quot;</span>]</span>
<span id="cb4-3"><a href="#cb4-3"></a></span>
<span id="cb4-4"><a href="#cb4-4"></a><span class="ot">v7 ::</span> [[<span class="dt">String</span>]]</span>
<span id="cb4-5"><a href="#cb4-5"></a>v7 <span class="ot">=</span> some empty</span></code></pre></div>
<p>But when I try this out on GHCi, something is going wrong:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1"></a>λ<span class="op">&gt;</span> v6</span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="op">^</span><span class="dt">CInterrupted</span><span class="op">.</span></span>
<span id="cb5-3"><a href="#cb5-3"></a>λ<span class="op">&gt;</span> v7</span>
<span id="cb5-4"><a href="#cb5-4"></a>[]</span></code></pre></div>
<p>I gave <code>v6</code> some time to run but it didn't terminate, so I cancelled it by hand.</p>
<p>By looking at the document, I find some clue: <code>some</code> and <code>many</code> seem to look for some solutions to the following equations:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a>some v <span class="ot">=</span> (<span class="op">:</span>) <span class="op">&lt;$&gt;</span> v <span class="op">&lt;*&gt;</span> many v</span>
<span id="cb6-2"><a href="#cb6-2"></a>many v <span class="ot">=</span> some v <span class="op">&lt;|&gt;</span> <span class="fu">pure</span> []</span>
<span id="cb6-3"><a href="#cb6-3"></a></span>
<span id="cb6-4"><a href="#cb6-4"></a><span class="co">-- rewrite to break the recursive relation will help?</span></span>
<span id="cb6-5"><a href="#cb6-5"></a>some v <span class="ot">=</span> (<span class="op">:</span>) <span class="op">&lt;$&gt;</span> v <span class="op">&lt;*&gt;</span> (some v <span class="op">&lt;|&gt;</span> <span class="fu">pure</span> [])</span>
<span id="cb6-6"><a href="#cb6-6"></a>many v <span class="ot">=</span> ((<span class="op">:</span>) (<span class="op">$</span>) v <span class="op">&lt;*&gt;</span> many v) <span class="op">&lt;|&gt;</span> <span class="fu">pure</span> []</span></code></pre></div>
<p>I can't go any further from here, but doing some research, I find the following links that might help, but for now I just leave this two functions as mysteries. (Maybe it's just something like <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Function.html#v:fix"><code>fix</code></a>, interesting, but IMHO not useful ).</p>
<p>Related links:</p>
<ul>
<li><a href="http://stackoverflow.com/questions/18108608/what-are-alternatives-some-and-many-useful-for">What are Alternative’s “some” and “many” useful for?</a></li>
<li><a href="http://stackoverflow.com/questions/7671009/functions-from-alternative-type-class">Functions from ‘Alternative’ type class</a></li>
</ul>
<h1 id="optional"><code>optional</code></h1>
<p>For the rest of the story, I'll just type them directly into GHCi.</p>
<p>The last function about <code>Alternative</code> is <code>optional</code>, Let's check its type and feed it with some instances:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1"></a>λ<span class="op">&gt;</span> <span class="op">:</span>t optional</span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="ot">optional ::</span> <span class="dt">Alternative</span> f <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> f (<span class="dt">Maybe</span> a)</span>
<span id="cb7-3"><a href="#cb7-3"></a>λ<span class="op">&gt;</span> optional <span class="dt">Nothing</span></span>
<span id="cb7-4"><a href="#cb7-4"></a><span class="dt">Just</span> <span class="dt">Nothing</span></span>
<span id="cb7-5"><a href="#cb7-5"></a>λ<span class="op">&gt;</span> optional <span class="op">$</span> <span class="dt">Just</span> <span class="dv">1</span></span>
<span id="cb7-6"><a href="#cb7-6"></a><span class="dt">Just</span> (<span class="dt">Just</span> <span class="dv">1</span>)</span>
<span id="cb7-7"><a href="#cb7-7"></a>λ<span class="op">&gt;</span> optional []</span>
<span id="cb7-8"><a href="#cb7-8"></a>[<span class="dt">Nothing</span>]</span>
<span id="cb7-9"><a href="#cb7-9"></a>λ<span class="op">&gt;</span> optional [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</span>
<span id="cb7-10"><a href="#cb7-10"></a>[<span class="dt">Just</span> <span class="dv">1</span>,<span class="dt">Just</span> <span class="dv">2</span>,<span class="dt">Just</span> <span class="dv">3</span>,<span class="dt">Nothing</span>]</span></code></pre></div>
<p>Wait a minute, is <code>f a -&gt; f (Maybe a)</code> looks familiar to you? It looks like an unary function that has type <code>a -&gt; Maybe a</code> under some contexts. I think the simplest expression that matches this type would be <code>(Just &lt;$&gt;)</code>. Let's do the same thing on it.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1"></a>λ<span class="op">&gt;</span> <span class="op">:</span>t (<span class="dt">Just</span> <span class="op">&lt;$&gt;</span>)</span>
<span id="cb8-2"><a href="#cb8-2"></a>(<span class="dt">Just</span> <span class="op">&lt;$&gt;</span>)<span class="ot"> ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> f (<span class="dt">Maybe</span> a)</span>
<span id="cb8-3"><a href="#cb8-3"></a>λ<span class="op">&gt;</span> (<span class="dt">Just</span> <span class="op">&lt;$&gt;</span>) <span class="dt">Nothing</span></span>
<span id="cb8-4"><a href="#cb8-4"></a><span class="dt">Nothing</span></span>
<span id="cb8-5"><a href="#cb8-5"></a>λ<span class="op">&gt;</span> (<span class="dt">Just</span> <span class="op">&lt;$&gt;</span>) <span class="dt">Just</span> <span class="dv">1</span></span>
<span id="cb8-6"><a href="#cb8-6"></a><span class="dt">Just</span> (<span class="dt">Just</span> <span class="dv">1</span>)</span>
<span id="cb8-7"><a href="#cb8-7"></a>λ<span class="op">&gt;</span> (<span class="dt">Just</span> <span class="op">&lt;$&gt;</span>) []</span>
<span id="cb8-8"><a href="#cb8-8"></a>[]</span>
<span id="cb8-9"><a href="#cb8-9"></a>λ<span class="op">&gt;</span> (<span class="dt">Just</span> <span class="op">&lt;$&gt;</span>) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</span>
<span id="cb8-10"><a href="#cb8-10"></a>[<span class="dt">Just</span> <span class="dv">1</span>,<span class="dt">Just</span> <span class="dv">2</span>,<span class="dt">Just</span> <span class="dv">3</span>]</span></code></pre></div>
<p>Comparing the output of <code>optional</code> and <code>(Just &lt;$&gt;)</code>, we find that <code>optional</code> will attach an <code>empty</code> to the end of this monoid. And that <code>empty</code> would be the “none” part from <code>optional</code>'s description: “One or none”. In addition, we've seen <code>&lt;|&gt;</code> is the binary operation for this monoid, so we can have a guess:</p>
<pre><code>optional v = (Just &lt;$&gt; v) &lt;|&gt; pure Nothing</code></pre>
<p>And this turns out to be the exact implementation.</p>
<h1 id="summary">Summary</h1>
<p>Not much is done in this post, I have to admit that type-tetris is not always the best way. As an afterthought, I didn't know how <code>Alternative</code> will be used so there was little hint that I can rely on when I was trying to figure out <code>many</code> and <code>some</code>.</p>
<p>Anyway, if happened to read all contents in this article, sorry for wasting your time and thanks for your patience.</p>
</div>
]]></description>
    <pubDate>Sat, 08 Mar 2014 00:00:00 UT</pubDate>
    <guid>http://javran.github.io//posts/2014-03-08-exploring-alternatives.html</guid>
    <dc:creator>Javran Cheng</dc:creator>
</item>
<item>
    <title>Play with free monad</title>
    <link>http://javran.github.io//posts/2014-03-03-play-with-free-monad.html</link>
    <description><![CDATA[<span class="blog-date">
    2014-03-03 - 
</span>
<span class="blog-tag">
    
        [ 
        <a href="/tags/haskell.html">haskell</a>, <a href="/tags/type-tetris.html">type-tetris</a>, <a href="/tags/monad.html">monad</a>
        ]
    
</span>
<br />
<br />
<div class="blog-main">
<p>This article is not a free monad tutorial but some ideas about what free monad does from the prospective of a Haskell newbie.</p>
<p>Some days ago I came across <a href="http://hackage.haskell.org/package/free-4.4/docs/Control-Monad-Free.html">Free monad</a> by reading <a href="http://stackoverflow.com/questions/13352205/what-are-free-monads">this Stack Overflow question</a>.</p>
<p>I'm not sure about what exactly it is, although some intuitiions are gained through both reading the question and answers and playing with the library.</p>
<p>In the rest of this article, I'd like to share my experience about how I explore functions listed <a href="http://hackage.haskell.org/package/free-4.4/docs/Control-Monad-Free.html">here</a> and some intuitions gained from this process. These intuitions are marked as <strong>bold sentences</strong>.</p>
<h1 id="make-some-values-of-free-f-a">Make some values of <code>Free f a</code></h1>
<p>Import related library, you shoule make sure you've installed <a href="http://hackage.haskell.org/package/free-4.4">The free package</a>.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">import</span> <span class="dt">Control.Monad</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="kw">import</span> <span class="dt">Control.Monad.Free</span></span></code></pre></div>
<p>This first thing is to make some values of type <code>Free f a</code>.</p>
<p>The easiest constructor is <code>Pure</code>. In order to fit the type <code>Free f a</code>, I choose to use a list as <code>f</code> and <code>Int</code> as <code>a</code>, because when I looked around the document, <code>f</code> is most likely to be an instance of <code>Functor</code>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="ot">v1 ::</span> <span class="dt">Free</span> [] <span class="dt">Int</span></span>
<span id="cb2-2"><a href="#cb2-2"></a>v1 <span class="ot">=</span> <span class="dt">Pure</span> <span class="dv">10</span></span></code></pre></div>
<p>The next thing is about how to use the other constructor: <code>Free</code>. Its type signature is <code>Free :: f (Free f a) -&gt; Free f a</code>. It might not be that friendly, so I simplify it a little with <code>f = [], a = Int</code>. Then it becomes: <code>Free :: [Free [] Int] -&gt; Free [] Int</code>. Go back to the original signature, we can say that <code>Free</code> constructor takes some value of <code>Free f a</code> wrapped in another <code>f</code>, then produces <code>Free f a</code>. By using <code>Free</code>, <strong>the outside functor is somehow “ignored” from its type signature.</strong> Moreover, the part <code>f (Free f a)</code> suggests <strong>an exactly match of inside and outside functors.</strong></p>
<p>Now we've already have a <code>v1 :: Free [] Int</code>, and by using <code>Free</code>, we should end up with some values of type <code>Free [] a</code>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="ot">v2 ::</span> <span class="dt">Free</span> [] <span class="dt">Int</span></span>
<span id="cb3-2"><a href="#cb3-2"></a>v2 <span class="ot">=</span> <span class="dt">Free</span> [v1]</span>
<span id="cb3-3"><a href="#cb3-3"></a></span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="ot">v3 ::</span> <span class="dt">Free</span> [] <span class="dt">Int</span></span>
<span id="cb3-5"><a href="#cb3-5"></a>v3 <span class="ot">=</span> <span class="dt">Free</span> [v2,v2,v1]</span></code></pre></div>
<p>Call GHCi to see the values:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a>λ<span class="op">&gt;</span> v1</span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="dt">Pure</span> <span class="dv">10</span></span>
<span id="cb4-3"><a href="#cb4-3"></a>λ<span class="op">&gt;</span> v2</span>
<span id="cb4-4"><a href="#cb4-4"></a><span class="dt">Free</span> [<span class="dt">Pure</span> <span class="dv">10</span>]</span>
<span id="cb4-5"><a href="#cb4-5"></a>λ<span class="op">&gt;</span> v3</span>
<span id="cb4-6"><a href="#cb4-6"></a><span class="dt">Free</span> [<span class="dt">Free</span> [<span class="dt">Pure</span> <span class="dv">10</span>],<span class="dt">Free</span> [<span class="dt">Pure</span> <span class="dv">10</span>],<span class="dt">Pure</span> <span class="dv">10</span>]</span></code></pre></div>
<h1 id="free-monad-is-a-monad">Free monad is a monad</h1>
<p>Of course free monad should be a monad, let's check the document to find some clues, in the instance list of <code>data Free f a</code>, we find this line:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1"></a><span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">Free</span> f)</span></code></pre></div>
<p>This is enough for us to write some functions that can be used as the second argument of our old friend <code>&gt;&gt;=</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a><span class="ot">foo1 ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Free</span> [] <span class="dt">Int</span></span>
<span id="cb6-2"><a href="#cb6-2"></a>foo1 x <span class="ot">=</span> <span class="dt">Free</span> [<span class="dt">Pure</span> <span class="op">$</span> x<span class="op">*</span><span class="dv">2</span>, <span class="dt">Pure</span> <span class="op">$</span> x<span class="op">+</span><span class="dv">20</span>]</span>
<span id="cb6-3"><a href="#cb6-3"></a></span>
<span id="cb6-4"><a href="#cb6-4"></a><span class="ot">foo2 ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Free</span> [] <span class="dt">String</span></span>
<span id="cb6-5"><a href="#cb6-5"></a>foo2 x <span class="ot">=</span> <span class="dt">Free</span> [<span class="dt">Pure</span> <span class="op">$</span> <span class="fu">show</span> x]</span>
<span id="cb6-6"><a href="#cb6-6"></a></span>
<span id="cb6-7"><a href="#cb6-7"></a><span class="ot">v4 ::</span> <span class="dt">Free</span> [] <span class="dt">String</span></span>
<span id="cb6-8"><a href="#cb6-8"></a>v4 <span class="ot">=</span> v1 <span class="op">&gt;&gt;=</span> foo1 <span class="op">&gt;&gt;=</span> foo1 <span class="op">&gt;&gt;=</span> foo1 <span class="op">&gt;&gt;=</span> foo2</span></code></pre></div>
<p>And the GHCi output is:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1"></a>λ<span class="op">&gt;</span> v4</span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="dt">Free</span> [<span class="dt">Free</span> [<span class="dt">Free</span> [<span class="dt">Free</span> [<span class="dt">Pure</span> <span class="st">&quot;80&quot;</span>]</span>
<span id="cb7-3"><a href="#cb7-3"></a>                 ,<span class="dt">Free</span> [<span class="dt">Pure</span> <span class="st">&quot;60&quot;</span>]]</span>
<span id="cb7-4"><a href="#cb7-4"></a>           ,<span class="dt">Free</span> [<span class="dt">Free</span> [<span class="dt">Pure</span> <span class="st">&quot;80&quot;</span>]</span>
<span id="cb7-5"><a href="#cb7-5"></a>                 ,<span class="dt">Free</span> [<span class="dt">Pure</span> <span class="st">&quot;60&quot;</span>]]]</span>
<span id="cb7-6"><a href="#cb7-6"></a>     ,<span class="dt">Free</span> [<span class="dt">Free</span> [<span class="dt">Free</span> [<span class="dt">Pure</span> <span class="st">&quot;120&quot;</span>]</span>
<span id="cb7-7"><a href="#cb7-7"></a>                 ,<span class="dt">Free</span> [<span class="dt">Pure</span> <span class="st">&quot;80&quot;</span>]]</span>
<span id="cb7-8"><a href="#cb7-8"></a>           ,<span class="dt">Free</span> [<span class="dt">Free</span> [<span class="dt">Pure</span> <span class="st">&quot;100&quot;</span>]</span>
<span id="cb7-9"><a href="#cb7-9"></a>                 ,<span class="dt">Free</span> [<span class="dt">Pure</span> <span class="st">&quot;70&quot;</span>]]]]</span>
<span id="cb7-10"><a href="#cb7-10"></a>λ<span class="op">&gt;</span> <span class="op">:</span>{</span>
<span id="cb7-11"><a href="#cb7-11"></a><span class="op">|</span> <span class="kw">let</span> foo1 <span class="ot">=</span> \x <span class="ot">-&gt;</span> [x<span class="op">*</span><span class="dv">2</span>,x<span class="op">+</span><span class="dv">20</span>]</span>
<span id="cb7-12"><a href="#cb7-12"></a><span class="op">|</span>     foo2 <span class="ot">=</span> \x <span class="ot">-&gt;</span> [<span class="fu">show</span> x]</span>
<span id="cb7-13"><a href="#cb7-13"></a><span class="op">|</span> <span class="kw">in</span> [<span class="dv">10</span>] <span class="op">&gt;&gt;=</span> foo1 <span class="op">&gt;&gt;=</span> foo1 <span class="op">&gt;&gt;=</span> foo1 <span class="op">&gt;&gt;=</span> foo2</span>
<span id="cb7-14"><a href="#cb7-14"></a><span class="op">|</span> <span class="op">:</span>}</span>
<span id="cb7-15"><a href="#cb7-15"></a>[<span class="st">&quot;80&quot;</span>,<span class="st">&quot;60&quot;</span>,<span class="st">&quot;80&quot;</span>,<span class="st">&quot;60&quot;</span>,<span class="st">&quot;120&quot;</span>,<span class="st">&quot;80&quot;</span>,<span class="st">&quot;100&quot;</span>,<span class="st">&quot;70&quot;</span>]</span></code></pre></div>
<p>You can observe some similiarity between list monad and <code>Free []</code> monad. The intuition is <strong><code>Free []</code> monad seems to be a list monad but without <code>concat</code></strong>.</p>
<h1 id="retract-and-liftf"><code>retract</code> and <code>liftF</code></h1>
<p>The document says “<code>retract</code> is the left inverse of <code>lift</code> and <code>liftF</code>”. So we explore <code>liftF</code> first.</p>
<p><code>liftF</code> is “A version of lift that can be used with just a Functor for f.” I'm not sure about this, but we can get started from another clue: the type signature <code>liftF :: (Functor f, MonadFree f m) =&gt; f a -&gt; m a</code>.</p>
<p>We choose to stick to our simplification: <code>f = []</code>, so we need to find a suitable <code>m</code> that is an instance of <code>MonadFree [] m</code>.</p>
<p>And this one looks promising:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1"></a><span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">MonadFree</span> f (<span class="dt">Free</span> f)</span></code></pre></div>
<p>So we can let <code>m = Free f</code>, which gives us the simplified type signature: <code>liftF :: [a] -&gt; Free [] a</code>. We can guess that <strong><code>liftF</code> lifts functors into free monads</strong>. To confirm about this, let's try to lift some functors:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1"></a><span class="ot">v7 ::</span> <span class="dt">Free</span> [] <span class="dt">Int</span></span>
<span id="cb9-2"><a href="#cb9-2"></a>v7 <span class="ot">=</span> liftF [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">8</span>,<span class="dv">8</span>,<span class="dv">8</span>]</span>
<span id="cb9-3"><a href="#cb9-3"></a></span>
<span id="cb9-4"><a href="#cb9-4"></a><span class="ot">v8 ::</span> <span class="dt">Free</span> <span class="dt">Maybe</span> <span class="dt">String</span></span>
<span id="cb9-5"><a href="#cb9-5"></a>v8 <span class="ot">=</span> liftF <span class="op">$</span> <span class="dt">Just</span> <span class="st">&quot;Foo&quot;</span></span>
<span id="cb9-6"><a href="#cb9-6"></a></span>
<span id="cb9-7"><a href="#cb9-7"></a><span class="ot">v9 ::</span> <span class="dt">Free</span> ((<span class="ot">-&gt;</span>) <span class="dt">Int</span>) <span class="dt">Int</span></span>
<span id="cb9-8"><a href="#cb9-8"></a>v9 <span class="ot">=</span> liftF (<span class="op">+</span> <span class="dv">10</span>)</span></code></pre></div>
<p>I don't know if there is an easy way of observing <code>v9</code>, for now we just print <code>v7</code> and <code>v8</code>:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1"></a>λ<span class="op">&gt;</span> v7</span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="dt">Free</span> [<span class="dt">Pure</span> <span class="dv">1</span>,<span class="dt">Pure</span> <span class="dv">2</span>,<span class="dt">Pure</span> <span class="dv">3</span>,<span class="dt">Pure</span> <span class="dv">4</span>,<span class="dt">Pure</span> <span class="dv">8</span>,<span class="dt">Pure</span> <span class="dv">8</span>,<span class="dt">Pure</span> <span class="dv">8</span>]</span>
<span id="cb10-3"><a href="#cb10-3"></a>λ<span class="op">&gt;</span> v8</span>
<span id="cb10-4"><a href="#cb10-4"></a><span class="dt">Free</span> (<span class="dt">Just</span> (<span class="dt">Pure</span> <span class="st">&quot;Foo&quot;</span>))</span></code></pre></div>
<p>Now we know we can lift any functors, so <strong>we can construct <code>Free f a</code> not only from <code>Pure</code> and <code>Free</code>, but also directly from functors.</strong></p>
<p>Now think about simplified type signature of <code>retract :: Free [] a -&gt; [a]</code>. <strong>it is the reverse of <code>liftF</code></strong>. Let's have a try in code:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1"></a><span class="ot">v10 ::</span> [<span class="dt">Int</span>]</span>
<span id="cb11-2"><a href="#cb11-2"></a>v10 <span class="ot">=</span> retract v3</span>
<span id="cb11-3"><a href="#cb11-3"></a></span>
<span id="cb11-4"><a href="#cb11-4"></a><span class="ot">v11 ::</span> <span class="dt">Maybe</span> <span class="dt">String</span></span>
<span id="cb11-5"><a href="#cb11-5"></a>v11 <span class="ot">=</span> retract v8</span>
<span id="cb11-6"><a href="#cb11-6"></a></span>
<span id="cb11-7"><a href="#cb11-7"></a><span class="ot">v12 ::</span> [<span class="dt">String</span>]</span>
<span id="cb11-8"><a href="#cb11-8"></a>v12 <span class="ot">=</span> retract v4</span>
<span id="cb11-9"><a href="#cb11-9"></a></span>
<span id="cb11-10"><a href="#cb11-10"></a><span class="ot">v13 ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb11-11"><a href="#cb11-11"></a>v13 <span class="ot">=</span> retract v9</span></code></pre></div>
<p>Call GHCi for results, now we can observe <code>v9</code> indirectly by using function <code>v13</code>:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1"></a>λ<span class="op">&gt;</span> v10</span>
<span id="cb12-2"><a href="#cb12-2"></a>[<span class="dv">10</span>,<span class="dv">10</span>,<span class="dv">10</span>]</span>
<span id="cb12-3"><a href="#cb12-3"></a>λ<span class="op">&gt;</span> v11</span>
<span id="cb12-4"><a href="#cb12-4"></a><span class="dt">Just</span> <span class="st">&quot;Foo&quot;</span></span>
<span id="cb12-5"><a href="#cb12-5"></a>λ<span class="op">&gt;</span> v12</span>
<span id="cb12-6"><a href="#cb12-6"></a>[<span class="st">&quot;80&quot;</span>,<span class="st">&quot;60&quot;</span>,<span class="st">&quot;80&quot;</span>,<span class="st">&quot;60&quot;</span>,<span class="st">&quot;120&quot;</span>,<span class="st">&quot;80&quot;</span>,<span class="st">&quot;100&quot;</span>,<span class="st">&quot;70&quot;</span>]</span>
<span id="cb12-7"><a href="#cb12-7"></a>λ<span class="op">&gt;</span> <span class="fu">map</span> v13 [<span class="dv">1</span><span class="op">..</span><span class="dv">5</span>]</span>
<span id="cb12-8"><a href="#cb12-8"></a>[<span class="dv">11</span>,<span class="dv">12</span>,<span class="dv">13</span>,<span class="dv">14</span>,<span class="dv">15</span>]</span></code></pre></div>
<p>Therefore <strong><code>retract</code> converts a free monad back to a functor</strong>. (I suspect this conclusion is somehow wrong, but for now I cannot tell what exactly is wrong.)</p>
<h1 id="iter-and-iterm"><code>iter</code> and <code>iterM</code></h1>
<p>Use the same trick we've played before, let <code>f = []</code>:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1"></a><span class="ot">iter  ::</span>            ([  a] <span class="ot">-&gt;</span>    a) <span class="ot">-&gt;</span> <span class="dt">Free</span> [] a <span class="ot">-&gt;</span>   a</span>
<span id="cb13-2"><a href="#cb13-2"></a><span class="ot">iterM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> ([m a] <span class="ot">-&gt;</span> m  a) <span class="ot">-&gt;</span> <span class="dt">Free</span> [] a <span class="ot">-&gt;</span> m a</span></code></pre></div>
<p>I guess: <code>iter</code> converts a function who does some sorts of reduction on functors into another function who does the same thing but on free monads, and <code>iterM</code> is the monadic version of <code>iter</code>.</p>
<p>Let's have a try:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1"></a><span class="ot">v14 ::</span> <span class="dt">Int</span></span>
<span id="cb14-2"><a href="#cb14-2"></a>v14 <span class="ot">=</span> iter <span class="fu">sum</span> v3</span>
<span id="cb14-3"><a href="#cb14-3"></a></span>
<span id="cb14-4"><a href="#cb14-4"></a><span class="ot">foo3 ::</span> [<span class="dt">IO</span> <span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Int</span></span>
<span id="cb14-5"><a href="#cb14-5"></a>foo3 ms <span class="ot">=</span> <span class="fu">sum</span> <span class="ot">`fmap`</span> <span class="fu">sequence</span> ms</span>
<span id="cb14-6"><a href="#cb14-6"></a></span>
<span id="cb14-7"><a href="#cb14-7"></a><span class="ot">v15 ::</span> <span class="dt">IO</span> <span class="dt">Int</span></span>
<span id="cb14-8"><a href="#cb14-8"></a>v15 <span class="ot">=</span> iterM foo3 v7</span></code></pre></div>
<p>And look at GHCi:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1"></a>λ<span class="op">&gt;</span> v14</span>
<span id="cb15-2"><a href="#cb15-2"></a><span class="dv">30</span></span>
<span id="cb15-3"><a href="#cb15-3"></a>λ<span class="op">&gt;</span> v15</span>
<span id="cb15-4"><a href="#cb15-4"></a><span class="dv">34</span></span></code></pre></div>
<p>Maybe I can say that <strong><code>iter</code> and <code>iterM</code> lift reduction (for functors) into free monads</strong></p>
<h1 id="hoistfree"><code>hoistFree</code></h1>
<p>The type signature contains <code>forall</code>, but I think it's fine to just ignore that part. As we are just trying to get things work:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1"></a><span class="ot">hoistFree ::</span> <span class="dt">Functor</span> g <span class="ot">=&gt;</span> (f a <span class="ot">-&gt;</span> g a) <span class="ot">-&gt;</span> <span class="dt">Free</span> f b <span class="ot">-&gt;</span> <span class="dt">Free</span> g b</span></code></pre></div>
<p>I guess <strong><code>hoistFree</code> lift a conversion between functors into a conversion between free monads.</strong></p>
<p>I know list and <code>Maybe</code> are good friends:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1"></a><span class="kw">import</span> <span class="dt">Data.Maybe</span></span>
<span id="cb17-2"><a href="#cb17-2"></a><span class="ot">v16 ::</span> <span class="dt">Maybe</span> <span class="dt">String</span></span>
<span id="cb17-3"><a href="#cb17-3"></a>v16 <span class="ot">=</span> <span class="dt">Just</span> <span class="st">&quot;Foo&quot;</span></span>
<span id="cb17-4"><a href="#cb17-4"></a></span>
<span id="cb17-5"><a href="#cb17-5"></a><span class="ot">v17 ::</span> [<span class="dt">String</span>]</span>
<span id="cb17-6"><a href="#cb17-6"></a>v17 <span class="ot">=</span> retract <span class="op">$</span> hoistFree maybeToList <span class="op">$</span> liftF v16</span></code></pre></div>
<p>Look at GHCi, we should observe the conversion from <code>Maybe String</code> to <code>[String]</code>:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1"></a>λ<span class="op">&gt;</span> v16</span>
<span id="cb18-2"><a href="#cb18-2"></a><span class="dt">Just</span> <span class="st">&quot;Foo&quot;</span></span>
<span id="cb18-3"><a href="#cb18-3"></a>λ<span class="op">&gt;</span> v17</span>
<span id="cb18-4"><a href="#cb18-4"></a>[<span class="st">&quot;Foo&quot;</span>]</span></code></pre></div>
<h1 id="pure-and-_free"><code>_Pure</code> and <code>_Free</code></h1>
<p>The type signatures of these two functions are really long, but don't be afraid, we still have some clue:</p>
<ul>
<li>If you look at <a href="http://hackage.haskell.org/package/profunctors-4.0.2/docs/Data-Profunctor.html#t:Choice"><code>Choice</code></a>, we find a simple instance: <code>Choice (-&gt;)</code></li>
<li>Pick up an applicative, I choose <code>m = []</code></li>
<li>Pick up a functor, I choose <code>f = Maybe</code></li>
<li>Ignore <code>forall</code> parts</li>
</ul>
<p>We end up with:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1"></a><span class="ot">_Pure ::</span> (            a <span class="ot">-&gt;</span> [           a])</span>
<span id="cb19-2"><a href="#cb19-2"></a>      <span class="ot">-&gt;</span> ( <span class="dt">Free</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> [<span class="dt">Free</span> <span class="dt">Maybe</span> a])</span>
<span id="cb19-3"><a href="#cb19-3"></a><span class="ot">_Free ::</span> ((<span class="dt">Maybe</span> (<span class="dt">Free</span> <span class="dt">Maybe</span> a)) <span class="ot">-&gt;</span> [<span class="dt">Maybe</span> (<span class="dt">Free</span> <span class="dt">Maybe</span> a)])</span>
<span id="cb19-4"><a href="#cb19-4"></a>      <span class="ot">-&gt;</span> (       (<span class="dt">Free</span> <span class="dt">Maybe</span> a)  <span class="ot">-&gt;</span> [       <span class="dt">Free</span> <span class="dt">Maybe</span> a ])</span></code></pre></div>
<p>I really can't figure out what these functions do, but I can still use it by feeding it with values of suitable type.</p>
<p>So for the following part of this section, I provide codes and outputs without explanation.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1"></a><span class="ot">v18 ::</span> [<span class="dt">Free</span> <span class="dt">Maybe</span> <span class="dt">String</span>]</span>
<span id="cb20-2"><a href="#cb20-2"></a>v18 <span class="ot">=</span> _Pure (<span class="op">:</span>[]) (liftF <span class="op">$</span> <span class="dt">Just</span> <span class="st">&quot;Haskell&quot;</span>)</span>
<span id="cb20-3"><a href="#cb20-3"></a></span>
<span id="cb20-4"><a href="#cb20-4"></a><span class="ot">v19 ::</span> [<span class="dt">String</span>]</span>
<span id="cb20-5"><a href="#cb20-5"></a>v19 <span class="ot">=</span> mapMaybe retract v18</span>
<span id="cb20-6"><a href="#cb20-6"></a></span>
<span id="cb20-7"><a href="#cb20-7"></a><span class="co">-- f = Maybe</span></span>
<span id="cb20-8"><a href="#cb20-8"></a><span class="co">-- p = (-&gt;)</span></span>
<span id="cb20-9"><a href="#cb20-9"></a><span class="co">-- m = IO</span></span>
<span id="cb20-10"><a href="#cb20-10"></a><span class="co">-- _Free :: (Maybe (Free Maybe a) -&gt; IO (Maybe (Free Maybe a)))</span></span>
<span id="cb20-11"><a href="#cb20-11"></a><span class="co">--       -&gt; (       Free Maybe a  -&gt; IO        (Free Maybe a) )</span></span>
<span id="cb20-12"><a href="#cb20-12"></a><span class="ot">v20 ::</span> <span class="dt">IO</span> (<span class="dt">Free</span> <span class="dt">Maybe</span> <span class="dt">Int</span>)</span>
<span id="cb20-13"><a href="#cb20-13"></a>v20 <span class="ot">=</span> _Free <span class="fu">return</span> (liftF <span class="op">$</span> <span class="dt">Just</span> <span class="dv">123456</span>)</span>
<span id="cb20-14"><a href="#cb20-14"></a></span>
<span id="cb20-15"><a href="#cb20-15"></a><span class="ot">v21 ::</span> <span class="dt">IO</span> (<span class="dt">Maybe</span> <span class="dt">Int</span>)</span>
<span id="cb20-16"><a href="#cb20-16"></a>v21 <span class="ot">=</span> retract <span class="ot">`fmap`</span> v20</span></code></pre></div>
<p>GHCi:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1"></a>λ<span class="op">&gt;</span> v18</span>
<span id="cb21-2"><a href="#cb21-2"></a>[<span class="dt">Free</span> (<span class="dt">Just</span> (<span class="dt">Pure</span> <span class="st">&quot;Haskell&quot;</span>))]</span>
<span id="cb21-3"><a href="#cb21-3"></a>λ<span class="op">&gt;</span> v19</span>
<span id="cb21-4"><a href="#cb21-4"></a>[<span class="st">&quot;Haskell&quot;</span>]</span>
<span id="cb21-5"><a href="#cb21-5"></a>λ<span class="op">&gt;</span> v20</span>
<span id="cb21-6"><a href="#cb21-6"></a><span class="dt">Free</span> (<span class="dt">Just</span> (<span class="dt">Pure</span> <span class="dv">123456</span>))</span>
<span id="cb21-7"><a href="#cb21-7"></a>λ<span class="op">&gt;</span> v21</span>
<span id="cb21-8"><a href="#cb21-8"></a><span class="dt">Just</span> <span class="dv">123456</span></span></code></pre></div>
<h1 id="wrap-method"><code>wrap</code> method</h1>
<p>This is a method defined for <code>MonadFree</code>s, the document says <strong>“Add a layer.”</strong>, let's see it in action:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1"></a><span class="ot">v22 ::</span> <span class="dt">Free</span> <span class="dt">Maybe</span> <span class="dt">Int</span></span>
<span id="cb22-2"><a href="#cb22-2"></a>v22 <span class="ot">=</span> liftF <span class="op">$</span> <span class="dt">Just</span> <span class="dv">10</span></span>
<span id="cb22-3"><a href="#cb22-3"></a></span>
<span id="cb22-4"><a href="#cb22-4"></a><span class="ot">v23 ::</span> <span class="dt">Free</span> <span class="dt">Maybe</span> <span class="dt">Int</span></span>
<span id="cb22-5"><a href="#cb22-5"></a>v23 <span class="ot">=</span> wrap (<span class="dt">Just</span> v22)</span>
<span id="cb22-6"><a href="#cb22-6"></a></span>
<span id="cb22-7"><a href="#cb22-7"></a><span class="ot">v24 ::</span> <span class="dt">Free</span> <span class="dt">Maybe</span> <span class="dt">Int</span></span>
<span id="cb22-8"><a href="#cb22-8"></a>v24 <span class="ot">=</span> wrap (<span class="dt">Just</span> v23)</span></code></pre></div>
<p>GHCi:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1"></a>λ<span class="op">&gt;</span> v22</span>
<span id="cb23-2"><a href="#cb23-2"></a><span class="dt">Free</span> (<span class="dt">Just</span> (<span class="dt">Pure</span> <span class="dv">10</span>))</span>
<span id="cb23-3"><a href="#cb23-3"></a>λ<span class="op">&gt;</span> v23</span>
<span id="cb23-4"><a href="#cb23-4"></a><span class="dt">Free</span> (<span class="dt">Just</span> (<span class="dt">Free</span> (<span class="dt">Just</span> (<span class="dt">Pure</span> <span class="dv">10</span>))))</span>
<span id="cb23-5"><a href="#cb23-5"></a>λ<span class="op">&gt;</span> v24</span>
<span id="cb23-6"><a href="#cb23-6"></a><span class="dt">Free</span> (<span class="dt">Just</span> (<span class="dt">Free</span> (<span class="dt">Just</span> (<span class="dt">Free</span> (<span class="dt">Just</span> (<span class="dt">Pure</span> <span class="dv">10</span>))))))</span></code></pre></div>
<h1 id="call-it-a-day">Call it a day</h1>
<p>This is the first time I attempted to do a “type-tetris”, although I still don't know what is free monad, but I do get some intuitions by using the functions provided. So let's call it a day.</p>
</div>
]]></description>
    <pubDate>Mon, 03 Mar 2014 00:00:00 UT</pubDate>
    <guid>http://javran.github.io//posts/2014-03-03-play-with-free-monad.html</guid>
    <dc:creator>Javran Cheng</dc:creator>
</item>
<item>
    <title>Add tags to your Hakyll blog</title>
    <link>http://javran.github.io//posts/2014-03-01-add-tags-to-your-hakyll-blog.html</link>
    <description><![CDATA[<span class="blog-date">
    2014-03-01 - 
</span>
<span class="blog-tag">
    
        [ 
        <a href="/tags/hakyll.html">hakyll</a>, <a href="/tags/haskell.html">haskell</a>
        ]
    
</span>
<br />
<br />
<div class="blog-main">
<p>As promised, here is a simple tutorial about adding tag supports to your Hakyll blog.</p>
<p>Few things before we start:</p>
<ul>
<li><p>My Hakyll version used for this article is <code>4.4.3.2</code>, other versions shouldn't have much difference.</p></li>
<li><p>If this article looks too verbose, you can just look at <strong>bold sentences</strong>.</p></li>
<li><p>All the changes done below is contained <a href="/assets/add-tags-mondo.tar.bz2">in this archive</a>. You can download, run it and skip rest of this article.</p></li>
</ul>
<p>Let's start from scratch to keep it as simple as possible.</p>
<p>So we initialize a new Hakyll website.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1"></a><span class="co"># initialize the website under dir `mondo`</span></span>
<span id="cb1-2"><a href="#cb1-2"></a>$ <span class="ex">hakyll-init</span> mondo</span>
<span id="cb1-3"><a href="#cb1-3"></a>$ <span class="bu">cd</span> mondo</span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="co"># compile the code necessary,</span></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="co"># in order to see the website.</span></span>
<span id="cb1-6"><a href="#cb1-6"></a>$ <span class="ex">ghc</span> site</span></code></pre></div>
<h1 id="write-tags-in-posts">Write tags in posts</h1>
<p>To create tags, we should first learn how to add tags to our posts, this step is easy, look at <a href="https://hackage.haskell.org/package/hakyll-4.4.3.2/docs/Hakyll-Web-Tags.html">the document for tags</a>, it should begin with <code>tags:</code> followed with a comma-separated list.</p>
<p>Now, let's modify posts from <code>mondo/posts</code>:</p>
<p><code>mondo/posts/2012-08-12-spqr.markdown</code>:</p>
<pre><code>---
title: S.P.Q.R.
tags: foo, bar1, bar2
---</code></pre>
<p><code>mondo/posts/2012-10-07-rosa-rosa-rosam.markdown</code>:</p>
<pre><code>---
title: Rosa Rosa Rosam
author: Ovidius
tags: bar1
---</code></pre>
<p><code>mondo/post/2012-11-28-carpe-diem.markdown</code>:</p>
<pre><code>---
title: Carpe Diem
tags: bar2, foo
---</code></pre>
<p><code>mondo/posts/2012-12-07-tu-quoque.markdown</code>:</p>
<pre><code>---
title: Tu Quoque
author: Julius
tags: bar1, bar2
---</code></pre>
<h1 id="fetch-metadata-from-our-posts">Fetch metadata from our posts</h1>
<p>Now we've assigned tags to the posts, next thing is to make them accessible from Haskell codes.</p>
<p>Before we go through all the posts and generate pages, we should build tags using <a href="https://hackage.haskell.org/package/hakyll-4.4.3.2/docs/Hakyll-Web-Tags.html#v:buildTags"><code>buildTags</code></a>.</p>
<p>Unforuntately this function is not well-documented, a short explanation would be : <code>buildTags pattern makeId</code> finds all tags from posts captured by <code>pattern</code>, converts each tag to a corresponding <a href="https://hackage.haskell.org/package/hakyll-4.4.3.2/docs/Hakyll-Core-Identifier.html#t:Identifier"><code>Identifier</code></a> by using <code>makeId</code> and returns a value of type <a href="https://hackage.haskell.org/package/hakyll-4.4.3.2/docs/Hakyll-Web-Tags.html#t:Tags"><code>Tags</code></a>.</p>
<p>From <code>site.hs</code> file, <strong>find these lines</strong>:</p>
<div class="sourceCode" id="cb6" data-startFrom="24"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 23;"><span id="cb6-24"><a href="#cb6-24"></a>    match <span class="st">&quot;posts/*&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb6-25"><a href="#cb6-25"></a>        route <span class="op">$</span> setExtension <span class="st">&quot;html&quot;</span></span>
<span id="cb6-26"><a href="#cb6-26"></a>        compile <span class="op">$</span> pandocCompiler</span>
<span id="cb6-27"><a href="#cb6-27"></a>            <span class="op">&gt;&gt;=</span> loadAndApplyTemplate <span class="st">&quot;templates/post.html&quot;</span>    postCtx</span>
<span id="cb6-28"><a href="#cb6-28"></a>            <span class="op">&gt;&gt;=</span> loadAndApplyTemplate <span class="st">&quot;templates/default.html&quot;</span> postCtx</span>
<span id="cb6-29"><a href="#cb6-29"></a>            <span class="op">&gt;&gt;=</span> relativizeUrls</span></code></pre></div>
<p>Insert the following code in front of it:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1"></a><span class="co">-- build up tags</span></span>
<span id="cb7-2"><a href="#cb7-2"></a>tags <span class="ot">&lt;-</span> buildTags <span class="st">&quot;posts/*&quot;</span> (fromCapture <span class="st">&quot;tags/*.html&quot;</span>)</span></code></pre></div>
<p>The code region above says: find all tags by searching the metadata of posts found by pattern <code>posts/*</code>, and the corresponding path for each tag will be of form <code>tags/*.html</code>. (e.g. for tag <code>foo</code>, you can generate a list of all posts that contains tag <code>foo</code> under URL: <code>{your-website}/tags/foo.html</code>.)</p>
<p>After tags are generated, we need to tell the post generator to include the corresponding tag informations for each tag, this is done by modifying <code>postCtx</code>. (for now you don't have to understand the detail of <code>postCtx</code> if you just want to setup up tags.)</p>
<p>Put the following definition somewhere in your <code>site.hs</code>, I choose to put it right after the definition of <code>postCtx</code>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1"></a><span class="ot">postCtxWithTags ::</span> <span class="dt">Tags</span> <span class="ot">-&gt;</span> <span class="dt">Context</span> <span class="dt">String</span></span>
<span id="cb8-2"><a href="#cb8-2"></a>postCtxWithTags tags <span class="ot">=</span> tagsField <span class="st">&quot;tags&quot;</span> tags <span class="ot">`mappend`</span> postCtx</span></code></pre></div>
<p>And then change all the occurrence of <code>postCtx</code> inside the code region mentioned above.</p>
<p>After this change, <strong>the code region should look like</strong>:</p>
<div class="sourceCode" id="cb9" data-startFrom="24"><pre class="sourceCode numberSource haskell numberLines"><code class="sourceCode haskell" style="counter-reset: source-line 23;"><span id="cb9-24"><a href="#cb9-24"></a>    <span class="co">-- build up tags</span></span>
<span id="cb9-25"><a href="#cb9-25"></a>    tags <span class="ot">&lt;-</span> buildTags <span class="st">&quot;posts/*&quot;</span> (fromCapture <span class="st">&quot;tags/*.html&quot;</span>)</span>
<span id="cb9-26"><a href="#cb9-26"></a></span>
<span id="cb9-27"><a href="#cb9-27"></a>    match <span class="st">&quot;posts/*&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb9-28"><a href="#cb9-28"></a>        route <span class="op">$</span> setExtension <span class="st">&quot;html&quot;</span></span>
<span id="cb9-29"><a href="#cb9-29"></a>        compile <span class="op">$</span> pandocCompiler</span>
<span id="cb9-30"><a href="#cb9-30"></a>            <span class="op">&gt;&gt;=</span> loadAndApplyTemplate <span class="st">&quot;templates/post.html&quot;</span>    (postCtxWithTags tags)</span>
<span id="cb9-31"><a href="#cb9-31"></a>            <span class="op">&gt;&gt;=</span> loadAndApplyTemplate <span class="st">&quot;templates/default.html&quot;</span> (postCtxWithTags tags)</span>
<span id="cb9-32"><a href="#cb9-32"></a>            <span class="op">&gt;&gt;=</span> relativizeUrls</span></code></pre></div>
<h1 id="template-pages">Template pages</h1>
<p>Now we need to add some changes to our templates, to make tags visible.</p>
<p>I think the following changes in this section are self-explanatory even if you knows nothing about how template works. So Let's go though them quickly.</p>
<p><strong>Modify your <code>templates/post.html</code> to make it looks like</strong>:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode html"><code class="sourceCode html"><span id="cb10-1"><a href="#cb10-1"></a><span class="kw">&lt;div</span><span class="ot"> class=</span><span class="st">&quot;info&quot;</span><span class="kw">&gt;</span></span>
<span id="cb10-2"><a href="#cb10-2"></a>    Posted on $date$</span>
<span id="cb10-3"><a href="#cb10-3"></a>    $if(author)$</span>
<span id="cb10-4"><a href="#cb10-4"></a>        by $author$</span>
<span id="cb10-5"><a href="#cb10-5"></a>    $endif$</span>
<span id="cb10-6"><a href="#cb10-6"></a><span class="kw">&lt;/div&gt;</span></span>
<span id="cb10-7"><a href="#cb10-7"></a><span class="kw">&lt;div</span><span class="ot"> class=</span><span class="st">&quot;info&quot;</span><span class="kw">&gt;</span></span>
<span id="cb10-8"><a href="#cb10-8"></a>    $if(tags)$</span>
<span id="cb10-9"><a href="#cb10-9"></a>    Tags: $tags$</span>
<span id="cb10-10"><a href="#cb10-10"></a>    $endif$</span>
<span id="cb10-11"><a href="#cb10-11"></a><span class="kw">&lt;/div&gt;</span></span>
<span id="cb10-12"><a href="#cb10-12"></a></span>
<span id="cb10-13"><a href="#cb10-13"></a>$body$</span></code></pre></div>
<p>Now we create the template for tag pages which lists all posts containing the corresponding tags. Since we already have a template for listing posts(<code>template/post-list.html</code>), we can simply reuse it.</p>
<p>This is done by <strong>creating a new file: <code>templates/tag.html</code>, with the following content</strong>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode html"><code class="sourceCode html"><span id="cb11-1"><a href="#cb11-1"></a>$partial(&quot;templates/post-list.html&quot;)$</span></code></pre></div>
<h1 id="generate-tag-pages">Generate tag pages</h1>
<p>This is the final step, we generate tag pages based on the templates we've written.</p>
<p><strong>Put the following code somewhere after we build up <code>tags</code>,</strong> I choose to place it right after the line <code>tags &lt;- buildTags</code>:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1"></a>    tagsRules tags <span class="op">$</span> \tag <span class="kw">pattern</span> <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb12-2"><a href="#cb12-2"></a>        <span class="kw">let</span> title <span class="ot">=</span> <span class="st">&quot;Posts tagged \&quot;&quot;</span> <span class="op">++</span> tag <span class="op">++</span> <span class="st">&quot;\&quot;&quot;</span></span>
<span id="cb12-3"><a href="#cb12-3"></a>        route idRoute</span>
<span id="cb12-4"><a href="#cb12-4"></a>        compile <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb12-5"><a href="#cb12-5"></a>            posts <span class="ot">&lt;-</span> recentFirst <span class="op">=&lt;&lt;</span> loadAll <span class="kw">pattern</span></span>
<span id="cb12-6"><a href="#cb12-6"></a>            <span class="kw">let</span> ctx <span class="ot">=</span> constField <span class="st">&quot;title&quot;</span> title</span>
<span id="cb12-7"><a href="#cb12-7"></a>                      <span class="ot">`mappend`</span> listField <span class="st">&quot;posts&quot;</span> (postCtxWithTags tags) (<span class="fu">return</span> posts)</span>
<span id="cb12-8"><a href="#cb12-8"></a>                      <span class="ot">`mappend`</span> defaultContext</span>
<span id="cb12-9"><a href="#cb12-9"></a></span>
<span id="cb12-10"><a href="#cb12-10"></a>            makeItem <span class="st">&quot;&quot;</span></span>
<span id="cb12-11"><a href="#cb12-11"></a>                <span class="op">&gt;&gt;=</span> loadAndApplyTemplate <span class="st">&quot;templates/tag.html&quot;</span> ctx</span>
<span id="cb12-12"><a href="#cb12-12"></a>                <span class="op">&gt;&gt;=</span> loadAndApplyTemplate <span class="st">&quot;templates/default.html&quot;</span> ctx</span>
<span id="cb12-13"><a href="#cb12-13"></a>                <span class="op">&gt;&gt;=</span> relativizeUrls</span></code></pre></div>
<p>Now it's done, recompile <code>site.hs</code> and have fun!</p>
<h1 id="result">Result</h1>
<p>Few screenshots after we adding tags:</p>
<figure>
<img src="/assets/add-tags-result-1.jpg" alt="" /><figcaption>Inside posts</figcaption>
</figure>
<figure>
<img src="/assets/add-tags-result-2.jpg" alt="" /><figcaption>Tag page</figcaption>
</figure>
<p>I also provide the final version of <code>mondo</code> directory <a href="/assets/add-tags-mondo.tar.bz2">here</a>.</p>
<h1 id="acknowledgement">Acknowledgement</h1>
<p>Thanks for the big help from <a href="https://github.com/eakron/variadic.me">the source code</a> of <a href="https://variadic.me/">variadic.me</a>.</p>
</div>
]]></description>
    <pubDate>Sat, 01 Mar 2014 00:00:00 UT</pubDate>
    <guid>http://javran.github.io//posts/2014-03-01-add-tags-to-your-hakyll-blog.html</guid>
    <dc:creator>Javran Cheng</dc:creator>
</item>

    </channel>
</rss>
