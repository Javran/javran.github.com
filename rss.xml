<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Javrania</title>
        <link>http://javran.github.io/</link>
        <description><![CDATA[Javran's blog]]></description>
        <atom:link href="http://javran.github.io//rss.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Fri, 22 Aug 2014 00:00:00 UT</lastBuildDate>
        <item>
    <title>Comonad, Zipper and Conway's Game of Life (Part 2)</title>
    <link>http://javran.github.io//posts/2014-08-22-comonad-zipper-and-conways-game-of-life.html</link>
    <description><![CDATA[<span class="blog-date">
    2014-08-22 - 
</span>
<span class="blog-tag">
    
        [ 
        <a href="/tags/haskell.html">haskell</a>, <a href="/tags/comonad.html">comonad</a>, <a href="/tags/zipper.html">zipper</a>, <a href="/tags/type-tetris.html">type-tetris</a>
        ]
    
</span>
<br />
<br />
<div class="blog-main">
<h1 id="intro">Intro</h1>
<p>In the <a href="2014-04-13-comonad-and-conways-game-of-life.html">previous post</a>, We' ve discussed a little bit about comonad. But these abstract concepts are useless without practical usage.</p>
<p>Forget about comonad and Conway's Game of Life for a while. Today I want to show you an interesting example, which will give you some ideas about what it means by saying “the value of one place depends on the value of its neighborhoods”. And these examples will be connect to the concept of comonad in a future post.</p>
<h1 id="d-wave-propagation">2D Wave Propagation</h1>
<p>This example simulates a simple wave propagation by ASCII art.</p>
<p>The “world” is represented by a list of characters, each of which has a special meaning, namely:</p>
<ul>
<li><code>&lt;space&gt;</code> : Just the medium. Air, water, etc.</li>
<li><code>&gt;</code> : a wave moving right.</li>
<li><code>&lt;</code> : a wave moving left.</li>
<li><code>X</code> : two waves with opposite direction meeting each other.</li>
<li><code>*</code> : a wave source which will disappear at the next moment, producing waves in both directions.</li>
</ul>
<p>The simulation of wave propagation will be archieved by continuously printing the next generation of the “world”.</p>
<p>For example, if we are given a string: <code>&quot;*  &gt;  *   *  &lt;  **&lt;&quot;</code>, the output would be the following:</p>
<pre><code>*  &gt;  *   *  &lt;  **&lt;  
 &gt;  &gt;&lt; &gt; &lt; &gt;&lt;  &lt;&lt;X&gt;  
  &gt; &lt;&gt;  X  &lt;&gt; &lt;&lt;&lt; &gt;&gt; 
   X  &gt;&lt; &gt;&lt;  X&lt;&lt;   &gt;&gt;
  &lt; &gt; &lt;&gt; &lt;&gt; &lt;&lt;X     &gt;
 &lt;   X  X  X&lt;&lt; &gt;     
&lt;   &lt; &gt;&lt; &gt;&lt;&lt;X   &gt;
...</code></pre>
<h1 id="propagation-rules">Propagation Rules</h1>
<p>I believe it's easy to see the pattern. And you can write a function to describe the rule. At the first glance you might think the state of a fixed position in the “world” only depends on its previous state and the previous states of its neighborhoods. But it turns out the previous state of itself isn't necessary, but we just leave it as an argument (Simply because I think it looks better).</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">waveRule ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Char</span>
waveRule _ l r
    <span class="fu">|</span> fromL <span class="fu">&amp;&amp;</span> fromR <span class="fu">=</span> <span class="ch">&#39;X&#39;</span>
    <span class="fu">|</span> fromL          <span class="fu">=</span> <span class="ch">&#39;&gt;&#39;</span>
    <span class="fu">|</span> fromR          <span class="fu">=</span> <span class="ch">&#39;&lt;&#39;</span>
    <span class="fu">|</span> otherwise      <span class="fu">=</span> <span class="ch">&#39; &#39;</span>
    <span class="kw">where</span>
        fromL <span class="fu">=</span> l <span class="ot">`elem`</span> <span class="st">&quot;&gt;*X&quot;</span>
        fromR <span class="fu">=</span> r <span class="ot">`elem`</span> <span class="st">&quot;&lt;*X&quot;</span></code></pre>
<h1 id="first-solution">First Solution</h1>
<p>(This part is not about zippers or comonads, feel free to skip it) It is not hard to come up with a solution involving only basic list manipulations. I think it would be a good exercise. My solution can be found <a href="https://gist.github.com/Javran/eed695b4f837cc8ea214">here</a>.</p>
<p>The output should be:</p>
<pre><code>*  &gt;  *   *  &lt;  **&lt;
 &gt;  &gt;&lt; &gt; &lt; &gt;&lt;  &lt;&lt;X&gt;
  &gt; &lt;&gt;  X  &lt;&gt; &lt;&lt;&lt; &gt;
   X  &gt;&lt; &gt;&lt;  X&lt;&lt;   
  &lt; &gt; &lt;&gt; &lt;&gt; &lt;&lt;X    
 &lt;   X  X  X&lt;&lt; &gt;   
&lt;   &lt; &gt;&lt; &gt;&lt;&lt;X   &gt;  
   &lt;  &lt;&gt; &lt;X&lt; &gt;   &gt; 
  &lt;  &lt;  X&lt;&lt;&gt;  &gt;   &gt;
 &lt;  &lt;  &lt;&lt;X  &gt;  &gt;   
&lt;  &lt;  &lt;&lt;&lt; &gt;  &gt;  &gt;  
  &lt;  &lt;&lt;&lt;   &gt;  &gt;  &gt; 
 &lt;  &lt;&lt;&lt;     &gt;  &gt;  &gt;
&lt;  &lt;&lt;&lt;       &gt;  &gt;  
  &lt;&lt;&lt;         &gt;  &gt; 
 &lt;&lt;&lt;           &gt;  &gt;
&lt;&lt;&lt;             &gt;  
&lt;&lt;               &gt; 
&lt;                 &gt;
                   </code></pre>
<h1 id="a-limited-view-of-the-world">A Limited View of the World</h1>
<p>Now suppose this 2D world is infinite on both directions, and we introduce the obvious coordinate system into this world. We will no longer see the whole world, but only a portion of it.</p>
<p>Now we are given two coordinates, and we can only observe the world in between these coordinates, can we still work out the problem?</p>
<p>It turns out pretty difficult to reuse the previous approach because:</p>
<ul>
<li><p>Lists can only be infinite in one direction while we need a world representation that can be infinite in both directions so that we are allowed to theoretically view the world in between two arbitrary coordinates.</p></li>
<li><p>Given a world and its previous generation, it is hard to find the “old cell state” or “old neighboring cell states” unless we can introduce something like coordinates to establish the corrspondence between cells.</p></li>
<li><p>We don't know where to start generating the next iteration as the world can be infinite in both directions. We can't simply walk through it from left to right, which might not terminate.</p></li>
</ul>
<p>I'd recommend to use a list <a href="http://en.wikipedia.org/wiki/Zipper_%28data_structure%29">zipper</a> to overcome these problems.</p>
<h1 id="list-zippers">List Zippers</h1>
<p>Zippers are a way to efficiently walk back and forth or update values in certain data structures like lists and trees. Those data structures can usually be traversed in a deterministic way.</p>
<p>A zipper of a certain data structure usually consists of two parts: a stack of data contexts (each data context is an incompete data structure with a “hole” in it), and a value that can fill a “hole”.</p>
<p>Here we are only interested in list zippers. But there are plenty of useful tutorials about zippers like <a href="http://learnyouahaskell.com/zippers">this one</a> from <a href="http://learnyouahaskell.com/chapters">LYAH</a>.</p>
<p>To explain what we just said about zippers, we take a random list <code>[1,2,3]</code> (you should recall that <code>[1,2,3]</code> is just a shorthand for <code>1:2:3:[]</code>) and traverse it to demonstrate list zippers.</p>
<table>
<thead>
<tr class="header">
<th align="left">Stack</th>
<th align="left">Focus</th>
<th align="left">Zipper = (Stack,Focus)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>[]</code></td>
<td align="left"><code>[1,2,3]</code></td>
<td align="left"><code>([],[1,2,3])</code></td>
</tr>
<tr class="even">
<td align="left"><code>[1:&lt;hole&gt;]</code></td>
<td align="left"><code>[2,3]</code></td>
<td align="left"><code>([1],[2,3])</code></td>
</tr>
<tr class="odd">
<td align="left"><code>[2:&lt;hole&gt;, 1:&lt;hole&gt;]</code></td>
<td align="left"><code>[3]</code></td>
<td align="left"><code>([2,1],[3])</code></td>
</tr>
<tr class="even">
<td align="left"><code>[3:&lt;hole&gt;, 2:&lt;hole&gt;, 1:&lt;hole&gt;]</code></td>
<td align="left"><code>[]</code></td>
<td align="left"><code>([3,2,1],[])</code></td>
</tr>
</tbody>
</table>
<p>A list zipper changes as we are walking in the data structure, the table above shows how the list zipper changes as we walk though a list from left to right. Note that since the data context for a list is always something like <code>(&lt;value&gt;:&lt;hole&gt;)</code>, we can simply represent it as <code>&lt;value&gt;</code>. That is why a list zipper are usually represented as a pair of two lists, or to be more precise, a stack and a list.</p>
<p>The data context stack makes it possible to traverse backwards. Whenever we want to do so, pop one data context from the stack, and fill in its hole by using the current focus. For example, to go backwards when the list zipper is <code>([2,1],[3])</code>, we pop the data context to get <code>2:&lt;hole&gt;</code>, fill in the hole with our current focus, namely <code>[3]</code> and we end up with <code>([1],2:[3])</code> whose focus is changed from <code>[3]</code> to <code>[2,3]</code>.</p>
<p>We can also change the value at the focus efficiently. For example, when the list zipper is <code>([2,1],[3])</code>, we modify the focus to <code>[4,5,6]</code>. And then we keep going backwards to recover the list. We will end up with <code>1:2:[4,5,6]</code> and as you can see the part we were focusing on (namely <code>[3]</code>) is now replaced by <code>[4,5,6]</code>.</p>
<h1 id="list-zippers-to-the-rescue">List Zippers to the Rescue</h1>
<p>With some introduction of zippers, I can now explain how can list zippers solve our problem.</p>
<ul>
<li><p>List zippers can be infinite in both directions by using a simple trick: make the context stack infinite. It is an importation observation that the stack in the list zipper are actually the reversed left part of the list and the focus the right part. By making both the reversed left part and right part infinite, we end up with a list zipper that is infinite in both directions.</p></li>
<li><p>It's quite easy to find “old cell state” and “old neighboring cell states” given the list zipper. The old cell is the <code>head</code> of the current focus, the cells right next to it are the top of the stack and the second element of the current focus, respectively. Therefore for any given list zipper, we can yield the next cell state of the <code>head</code> of the current focusing list.</p></li>
<li><p>We don't need to worry about where to start generating the next world, given a list zipper, we know how to iteratively move the focus to the left or to the right. So as long as we can pin one position to the origin point of the world, we can take steps based on the original zipper by moving either left or right to focus on the coordinate in question. And a list zipper contains sufficient information to calculate the next cell state in question.</p></li>
</ul>
<h1 id="implementation">Implementation</h1>
<h2 id="zippers">Zippers</h2>
<p>First let's begin with zipper implementations. Since the world can never be empty, it is totally safe to break the focusing data (<code>[a]</code>) into its components (<code>(a,[a])</code>). By rearranging the order of arguments (<code>([a],[a])</code> … <code>([a],(a,[a]))</code> … <code>LZipper a [a] [a]</code>) we have our final version of <code>LZipper</code> here:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DeriveFunctor #-}</span>

<span class="co">-- | LZipper &lt;current&gt; &lt;left (reversed)&gt; &lt;right&gt;</span>
<span class="kw">data</span> <span class="dt">LZipper</span> a <span class="fu">=</span> <span class="dt">LZipper</span> a [a] [a]
    <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Functor</span>)</code></pre>
<p>Here the old focus would be <code>&lt;current&gt;:&lt;right&gt;</code> but we can break the focusing list to make it looks nicer: now a list zipper in our case consists of three parts, a current focus <code>&lt;current&gt;</code>, everything to the left of it <code>&lt;left (reversed)&gt;</code> and everything to the right of it <code>&lt;right&gt;</code>.</p>
<p>With the list zipper definition given, it's easy to define basic operations:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | shift left and right</span>
zipperMoveL,<span class="ot"> zipperMoveR ::</span> <span class="dt">LZipper</span> a <span class="ot">-&gt;</span> <span class="dt">LZipper</span> a
zipperMoveL (<span class="dt">LZipper</span> a (x<span class="fu">:</span>xs&#39;) ys) <span class="fu">=</span> <span class="dt">LZipper</span> x xs&#39; (a<span class="fu">:</span>ys)
zipperMoveL _ <span class="fu">=</span> error <span class="st">&quot;Invalid move&quot;</span>
zipperMoveR (<span class="dt">LZipper</span> a xs (y<span class="fu">:</span>ys&#39;)) <span class="fu">=</span> <span class="dt">LZipper</span> y (a<span class="fu">:</span>xs) ys&#39;
zipperMoveR _ <span class="fu">=</span> error <span class="st">&quot;Invalid move&quot;</span>

<span class="co">-- | get the current focusing element</span>
<span class="ot">current ::</span> <span class="dt">LZipper</span> a <span class="ot">-&gt;</span> a
current (<span class="dt">LZipper</span> v _ _) <span class="fu">=</span> v</code></pre>
<h2 id="conversion-between-limited-worlds-and-infinite-worlds">Conversion between Limited Worlds and Infinite Worlds</h2>
<p>To initialize the world we need to convert from a list of cells to a zipper which represents the infinite world. This can be achieved by padding the list to make it infinite in both directions:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | initial world to a zipper</span>
<span class="ot">rangeToZipper ::</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">LZipper</span> a
rangeToZipper v wd <span class="fu">=</span> <span class="kw">case</span> wd <span class="kw">of</span>
    []   <span class="ot">-&gt;</span> <span class="dt">LZipper</span> v pad pad
    x<span class="fu">:</span>xs <span class="ot">-&gt;</span> <span class="dt">LZipper</span> x pad (xs <span class="fu">++</span> pad)
    <span class="kw">where</span>
        pad <span class="fu">=</span> repeat v</code></pre>
<p>And to view a portion of the infinite world, we take as argument two coordinates and a zipper (the zipper is assumed to point to the origin point), move the zipper to the position specified by one of the coordinate, and then extract the value of the focus from zipper and keep moving the zipper to the other coordinate.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | a view range (coordinates), a zipper to a portion of the world</span>
<span class="ot">zipperToRange ::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">LZipper</span> a <span class="ot">-&gt;</span> [a]
zipperToRange (i,j) zp <span class="fu">=</span> fmap current zippers
    <span class="kw">where</span>
        zippers <span class="fu">=</span> take (j <span class="fu">-</span> i <span class="fu">+</span> <span class="dv">1</span>) (iterate zipperMoveR startZ)
        startZ <span class="fu">=</span> zipperMoveFocus i zp
<span class="ot">        zipperMoveFocus ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">LZipper</span> a <span class="ot">-&gt;</span> <span class="dt">LZipper</span> a
        zipperMoveFocus t z
            <span class="fu">|</span> t <span class="fu">&gt;</span> <span class="dv">0</span>     <span class="fu">=</span> zipperMoveFocus (t<span class="fu">-</span><span class="dv">1</span>) (zipperMoveR z)
            <span class="fu">|</span> t <span class="fu">&lt;</span> <span class="dv">0</span>     <span class="fu">=</span> zipperMoveFocus (t<span class="fu">+</span><span class="dv">1</span>) (zipperMoveL z)
            <span class="fu">|</span> otherwise <span class="fu">=</span> z</code></pre>
<h2 id="propagation-rules-1">Propagation Rules</h2>
<p>We modify <code>waveRule</code> function above so that it can produce the next cell state from a zipper. The nice thing about our zipper is that both of the neighboring old cell states can be easily found by pattern matching on arguments.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">waveRule ::</span> <span class="dt">LZipper</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Char</span>
waveRule (<span class="dt">LZipper</span> _ (l<span class="fu">:</span>_) (r<span class="fu">:</span>_))
    <span class="fu">|</span> fromL <span class="fu">&amp;&amp;</span> fromR <span class="fu">=</span> <span class="ch">&#39;X&#39;</span>
    <span class="fu">|</span> fromL          <span class="fu">=</span> <span class="ch">&#39;&gt;&#39;</span>
    <span class="fu">|</span> fromR          <span class="fu">=</span> <span class="ch">&#39;&lt;&#39;</span>
    <span class="fu">|</span> otherwise      <span class="fu">=</span> <span class="ch">&#39; &#39;</span>
    <span class="kw">where</span>
        fromL <span class="fu">=</span> l <span class="ot">`elem`</span> <span class="st">&quot;&gt;*X&quot;</span>
        fromR <span class="fu">=</span> r <span class="ot">`elem`</span> <span class="st">&quot;&lt;*X&quot;</span>
waveRule _ <span class="fu">=</span> error <span class="st">&quot;null zipper&quot;</span></code></pre>
<p>And then we rush to complete the main function, assuming <code>nextGen :: LZipper Char -&gt; LZipper Char</code>, a function that takes a zipper and produces a zipper of the next generation. has been implemented for us.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">nextGen ::</span> <span class="dt">LZipper</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">LZipper</span> <span class="dt">Char</span>
nextGen <span class="fu">=</span> undefined

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> mapM_ (putStrLn <span class="fu">.</span> zipperToRange (<span class="fu">-</span><span class="dv">20</span>,<span class="dv">40</span>)) (take <span class="dv">20</span> (iterate nextGen startZ))
    <span class="kw">where</span>
        startStr <span class="fu">=</span> <span class="st">&quot;*  &gt;  *   *  &lt;  **&lt;&quot;</span>
        startZ <span class="fu">=</span> rangeToZipper <span class="ch">&#39; &#39;</span> startStr</code></pre>
<p>In the code above, we take 20 generations, view the world within range <code>(-20,40)</code>.</p>
<h2 id="the-final-missing-piece">The Final Missing Piece</h2>
<p>The only thing missing in our implementation is the <code>nextGen</code> function, this is also where the magic happens. Let's implement it step by step.</p>
<p>By taking its type signature into account, we can write down the shape of the body:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">nextGen ::</span> <span class="dt">LZipper</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">LZipper</span> <span class="dt">Char</span>
nextGen z <span class="fu">=</span> <span class="dt">LZipper</span> c&#39; ls&#39; rs&#39;
    <span class="kw">where</span>
        c&#39; <span class="fu">=</span> undefined
        ls&#39; <span class="fu">=</span> undefined
        rs&#39; <span class="fu">=</span> undefined</code></pre>
<p>And it's not hard to figure out what is <code>c'</code> – the new cell state in correspondence with <code>c</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">nextGen ::</span> <span class="dt">LZipper</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">LZipper</span> <span class="dt">Char</span>
nextGen z <span class="fu">=</span> <span class="dt">LZipper</span> c&#39; ls&#39; rs&#39;
    <span class="kw">where</span>
        c&#39; <span class="fu">=</span> waveRule z
        ls&#39; <span class="fu">=</span> undefined
        rs&#39; <span class="fu">=</span> undefined</code></pre>
<p>To figure out <code>ls'</code>, we first try to figure out the first element of it, namely <code>l'</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">nextGen ::</span> <span class="dt">LZipper</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">LZipper</span> <span class="dt">Char</span>
nextGen z <span class="fu">=</span> <span class="dt">LZipper</span> c&#39; ls&#39; rs&#39;
    <span class="kw">where</span>
        c&#39; <span class="fu">=</span> waveRule z
        l&#39; <span class="fu">=</span> undefined
        ls&#39; <span class="fu">=</span> l&#39; <span class="fu">:</span> undefined
        rs&#39; <span class="fu">=</span> undefined</code></pre>
<p>Since the focus of <code>l'</code> is the direct neighborhood of <code>c</code>, we can simply move the zipper to calculate its new state:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">nextGen ::</span> <span class="dt">LZipper</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">LZipper</span> <span class="dt">Char</span>
nextGen z <span class="fu">=</span> <span class="dt">LZipper</span> c&#39; ls&#39; rs&#39;
    <span class="kw">where</span>
        c&#39; <span class="fu">=</span> waveRule z
        l&#39; <span class="fu">=</span> waveRule <span class="fu">.</span> zipperMoveL <span class="fu">$</span> z
        ls&#39; <span class="fu">=</span> l&#39; <span class="fu">:</span> undefined
        rs&#39; <span class="fu">=</span> undefined</code></pre>
<p>Comparing <code>c'</code> and <code>l'</code>, we can find the pattern:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">nextGen ::</span> <span class="dt">LZipper</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">LZipper</span> <span class="dt">Char</span>
nextGen z <span class="fu">=</span> <span class="dt">LZipper</span> c&#39; ls&#39; rs&#39;
    <span class="kw">where</span>
        c&#39; <span class="fu">=</span> waveRule z
        l&#39; <span class="fu">=</span> waveRule <span class="fu">.</span> zipperMoveL <span class="fu">$</span> z
        ls&#39; <span class="fu">=</span> [waveRule <span class="fu">.</span> zipperMoveL <span class="fu">$</span> z, waveRule <span class="fu">.</span> zipperMoveL <span class="fu">.</span> zipperMoveL <span class="fu">$</span> z, <span class="fu">...</span>]
        rs&#39; <span class="fu">=</span> undefined</code></pre>
<p>And the same pattern holds for <code>rs'</code>: we just keep moving the zipper to its left or right, and produce new states by applying <code>waveRule</code> to it. So we end up with:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">nextGen ::</span> <span class="dt">LZipper</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">LZipper</span> <span class="dt">Char</span>
nextGen z <span class="fu">=</span> <span class="dt">LZipper</span> c&#39; ls&#39; rs&#39;
    <span class="kw">where</span>
        c&#39; <span class="fu">=</span> waveRule z
        ls&#39; <span class="fu">=</span> map waveRule <span class="fu">.</span> tail <span class="fu">$</span> iterate zipperMoveL z
        rs&#39; <span class="fu">=</span> map waveRule <span class="fu">.</span> tail <span class="fu">$</span> iterate zipperMoveR z</code></pre>
<p>Now the whole program should be complete, if you run it, you will get something like this:</p>
<pre><code>                    *  &gt;  *   *  &lt;  **&lt;                      
                   &lt; &gt;  &gt;&lt; &gt; &lt; &gt;&lt;  &lt;&lt;X&gt;                      
                  &lt;   &gt; &lt;&gt;  X  &lt;&gt; &lt;&lt;&lt; &gt;&gt;                     
                 &lt;     X  &gt;&lt; &gt;&lt;  X&lt;&lt;   &gt;&gt;                    
                &lt;     &lt; &gt; &lt;&gt; &lt;&gt; &lt;&lt;X     &gt;&gt;                   
               &lt;     &lt;   X  X  X&lt;&lt; &gt;     &gt;&gt;                  
              &lt;     &lt;   &lt; &gt;&lt; &gt;&lt;&lt;X   &gt;     &gt;&gt;                 
             &lt;     &lt;   &lt;  &lt;&gt; &lt;X&lt; &gt;   &gt;     &gt;&gt;                
            &lt;     &lt;   &lt;  &lt;  X&lt;&lt;&gt;  &gt;   &gt;     &gt;&gt;               
           &lt;     &lt;   &lt;  &lt;  &lt;&lt;X  &gt;  &gt;   &gt;     &gt;&gt;              
          &lt;     &lt;   &lt;  &lt;  &lt;&lt;&lt; &gt;  &gt;  &gt;   &gt;     &gt;&gt;             
         &lt;     &lt;   &lt;  &lt;  &lt;&lt;&lt;   &gt;  &gt;  &gt;   &gt;     &gt;&gt;            
        &lt;     &lt;   &lt;  &lt;  &lt;&lt;&lt;     &gt;  &gt;  &gt;   &gt;     &gt;&gt;           
       &lt;     &lt;   &lt;  &lt;  &lt;&lt;&lt;       &gt;  &gt;  &gt;   &gt;     &gt;&gt;          
      &lt;     &lt;   &lt;  &lt;  &lt;&lt;&lt;         &gt;  &gt;  &gt;   &gt;     &gt;&gt;         
     &lt;     &lt;   &lt;  &lt;  &lt;&lt;&lt;           &gt;  &gt;  &gt;   &gt;     &gt;&gt;        
    &lt;     &lt;   &lt;  &lt;  &lt;&lt;&lt;             &gt;  &gt;  &gt;   &gt;     &gt;&gt;       
   &lt;     &lt;   &lt;  &lt;  &lt;&lt;&lt;               &gt;  &gt;  &gt;   &gt;     &gt;&gt;      
  &lt;     &lt;   &lt;  &lt;  &lt;&lt;&lt;                 &gt;  &gt;  &gt;   &gt;     &gt;&gt;     
 &lt;     &lt;   &lt;  &lt;  &lt;&lt;&lt;                   &gt;  &gt;  &gt;   &gt;     &gt;&gt;    </code></pre>
<p>Let's call it a day here. In the next part we'll go back to comonads, and its relationship between zippers. And hopefully we will finally see the implementation of Conway's Game of Life.</p>
<h1 id="complete-code">Complete Code</h1>
<p>You can find my complete code from <a href="https://gist.github.com/Javran/926296611a521cb00467">gist</a>.</p>
<h1 id="other-parts">Other parts</h1>
<ul>
<li><a href="2014-04-13-comonad-and-conways-game-of-life.html">Part 1</a></li>
</ul>
</div>
]]></description>
    <pubDate>Fri, 22 Aug 2014 00:00:00 UT</pubDate>
    <guid>http://javran.github.io//posts/2014-08-22-comonad-zipper-and-conways-game-of-life.html</guid>
</item>
<item>
    <title>Comonad, Zipper and Conway's Game of Life (Part 1)</title>
    <link>http://javran.github.io//posts/2014-04-13-comonad-and-conways-game-of-life.html</link>
    <description><![CDATA[<span class="blog-date">
    2014-04-13 - 
</span>
<span class="blog-tag">
    
        [ 
        <a href="/tags/haskell.html">haskell</a>, <a href="/tags/comonad.html">comonad</a>, <a href="/tags/zipper.html">zipper</a>, <a href="/tags/type-tetris.html">type-tetris</a>
        ]
    
</span>
<br />
<br />
<div class="blog-main">
<p>(Updated on Aug 22, 2014, better title, add link)</p>
<h1 id="intro">Intro</h1>
<p>Let's go beyond monad, today I want to show you how to play with <a href="http://hackage.haskell.org/package/comonad">comonad</a>. I don't understand the theory behind comonad, but programming with it is quite simple. Basically, I think <strong>it's just an algebraic structure dealing with data context.</strong></p>
<p>In other words, if you find yourself dealing with some recursive data structure, and in that data structure, the value of one place depends on the value of its neighborhoods (some “data context”, not sure if I'm using the right terminology), you probably want to take a look at comonad.</p>
<h1 id="conways-game-of-life">Conway's Game of Life</h1>
<p>To do something interesting with comonad, the first thing came to my mind was <a href="http://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">Game of Life</a>. It's a simple “game” that involves no players. At the beginning, a world is represented as a 2D array of booleans. Then this world evolves following some simple <a href="http://en.wikipedia.org/wiki/Conway%27s_Game_of_Life#Rules">rules</a>.</p>
<p>Looking at these rules, you will find that the next state of a given cell in the world is merely determined by the previous states of itself and its neighborhoods. So I feel Game of Life would be a perfect example for comonad.</p>
<h1 id="comonad">Comonad</h1>
<p>Recall what is a monad in Haskell code:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Functor</span> m <span class="ot">=&gt;</span> <span class="dt">Monad</span> m <span class="kw">where</span>
<span class="ot">    return ::</span> a <span class="ot">-&gt;</span> m a
<span class="ot">    join   ::</span> m (m a) <span class="ot">-&gt;</span> m a</code></pre>
<p>I lied here because to define a <code>Monad</code>, Haskell does not require you to make it an instance of <code>Functor</code> at the first place. But trust me <a href="http://www.haskell.org/haskellwiki/Functor-Applicative-Monad_Proposal">this requirement will be forced in future</a>.</p>
<p>In addition, I don't define a <code>(&gt;&gt;=)</code> but instead a <code>join</code>, since <code>f &gt;&gt;= m = join (fmap f m)</code>, and <code>m</code> should also be an instance of <code>Functor</code>, this monad definition should be almost equivalent to the one found in the base library.</p>
<p>Whenever we “co-” something, it means to filp every <code>-&gt;</code> into <code>&lt;-</code>. So we know what a comonad would look like:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Functor</span> w <span class="ot">=&gt;</span> <span class="dt">Comonad</span> w <span class="kw">where</span>
<span class="ot">    extract   ::</span> w a <span class="ot">-&gt;</span> a
<span class="ot">    duplicate ::</span> w a <span class="ot">-&gt;</span> w (w a)

<span class="ot">    extend    ::</span> (w a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> w a <span class="ot">-&gt;</span> w b
<span class="ot">    (=&gt;&gt;)     ::</span> w a <span class="ot">-&gt;</span> (w a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> w b</code></pre>
<p>Here you can see we flip the type signature for <code>return</code> and <code>join</code>, we get <code>extract</code> and <code>duplicate</code> as results. It's also handy to have <code>extend</code> and <code>(=&gt;&gt;)</code>, which can all be defined in terms of <code>fmap</code> and <code>duplicate</code>, just like <code>(=&lt;&lt;)</code> and <code>(&gt;&gt;=)</code> functions for monad. Let's try to figure out the implementation of <code>extend</code>.</p>
<p>The first step is to bind the arguments of <code>extend</code> to some name (here <code>f</code> and <code>w1</code>), so we can list all the tools available:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">extract    ::</span> forall a   <span class="fu">.</span> w a <span class="ot">-&gt;</span> a
<span class="ot">duplicate  ::</span> forall a   <span class="fu">.</span> w a <span class="ot">-&gt;</span> w (w a)
fmap<span class="ot">       ::</span> forall a b <span class="fu">.</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> w a <span class="ot">-&gt;</span> w b
<span class="ot">f          ::</span> w a <span class="ot">-&gt;</span> b
<span class="ot">w1         ::</span> w a
<span class="co">-- goal:</span>
extend f<span class="ot"> w ::</span> w b</code></pre>
<p>It's tempting to try <code>f w1 :: b</code>, but it is a dead end. Instead, because <code>f</code> “removes a layer of w”, we can try to add another layer before using <code>f</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">duplicate<span class="ot"> w1          ::</span> w (w a)
fmap<span class="ot">                  ::</span> (a&#39; <span class="ot">-&gt;</span> b&#39;) <span class="ot">-&gt;</span> w a&#39; <span class="ot">-&gt;</span> w b&#39;
<span class="co">-- where a&#39; = w a, b&#39; = b</span>
fmap f (duplicate w1)<span class="ot"> ::</span> w b</code></pre>
<p>Therefore:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">extend f w <span class="fu">=</span> fmap f (duplicate w)
w <span class="ot">=&gt;</span><span class="fu">&gt;</span> f    <span class="fu">=</span> extend f w</code></pre>
<p>or more point-freely:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">extend f <span class="fu">=</span> fmap f <span class="fu">.</span> duplicate
(<span class="ot">=&gt;</span><span class="fu">&gt;</span>)    <span class="fu">=</span> flip extend</code></pre>
<h1 id="some-understanding-about-comonad">Some understanding about comonad</h1>
<p>In my opinion, when trying to understand monad, it's more straightforward to begin with understanding <code>fmap</code>, <code>return</code> and <code>join</code>, but in practice, <code>&gt;&gt;=</code> and <code>=&lt;&lt;</code> come in handy. And the same thing happens to comonad: <code>extract</code> and <code>duplicate</code> are easy, and <code>extend</code> and <code>=&gt;&gt;</code> come in handy.</p>
<p>Recall that in the intro section, I said comonad deals with data context. More precisely, (IMHO) it's a type constructor that adds to a data structure the ability of focusing on one particular value and the ability of moving focus.</p>
<ul>
<li><code>extract</code> means to extract a value from the current focus, this can be seen from its type signature <code>extract :: w a -&gt; a</code>.</li>
<li><code>duplicate</code> might not be that straightforward to understand. It means to replace every value in the data structure, with its corresponding context.</li>
</ul>
<p>To make an analogy, assume you are inside of a big building, there are maps indicating the spot you are currently standing. If this building were a comonad, and the focus was on you. I can use <code>extract</code> to directly find you. In addition, there are some places with maps. These maps provides you with not only the whole structure of this building, but also the place where every map itself is located. So if you are inside a building near a map, you can take a picture on the map and send it to me, then I can locate you using <code>extract</code>.</p>
<p>Now suppose there is a building without maps, what <code>duplicate</code> does is just like drawing maps for each place inside the building and putting them to their right places. So <code>w</code> is the building “comonad”, <code>a</code> is a single place inside the building and <code>duplicate :: w a -&gt; w (w a)</code> draws maps and put them to their corresponding places.</p>
<p>And just like <code>(&gt;&gt;=)</code> in monad, <code>(=&gt;&gt;)</code> is more handy to use in comonad. Looking at its signature <code>(=&gt;&gt;) :: (w a -&gt; b) -&gt; w a -&gt; w b</code>, the most interesting part is its first argument, a function of type <code>w a -&gt; b</code>. This argument is exactly where rules come into play: “Given a data with focus (<code>w a</code>), let's determine the next value of the current focus will be (<code>b</code>).”</p>
<p>I'd like to call it a day here. In the future posts, we'll see these functions in action.</p>
<h1 id="other-parts">Other parts</h1>
<ul>
<li><a href="2014-08-22-comonad-zipper-and-conways-game-of-life.html">Part 2</a></li>
</ul>
</div>
]]></description>
    <pubDate>Sun, 13 Apr 2014 00:00:00 UT</pubDate>
    <guid>http://javran.github.io//posts/2014-04-13-comonad-and-conways-game-of-life.html</guid>
</item>
<item>
    <title>Start working on exercism</title>
    <link>http://javran.github.io//posts/2014-04-06-start-working-on-exercism.html</link>
    <description><![CDATA[<span class="blog-date">
    2014-04-06 - 
</span>
<span class="blog-tag">
    
        [ 
        <a href="/tags/haskell.html">haskell</a>, <a href="/tags/coding.html">coding</a>
        ]
    
</span>
<br />
<br />
<div class="blog-main">
<p>Since I'll be busy for the next few weeks, I can only devote few of my brain power to easy programming tasks in my spare time. Therefore, these days I've started working on <a href="http://exercism.io/">exercism</a>.</p>
<p>It's a free website and only requires you having a github account. They offer simple programming problems with test suites. You can solve the problem and submit your source code to the website so that other users would look at your code and have comments on it.</p>
<p>The main target is to improve the readability of your code through comments from others and iterative refinements from yourself.</p>
<p>In a word, it's an excellent website to learn things.</p>
<p>My account is <a href="http://exercism.io/Javran">here</a>, feel free to give me comments.</p>
<p>See you there.</p>
</div>
]]></description>
    <pubDate>Sun, 06 Apr 2014 00:00:00 UT</pubDate>
    <guid>http://javran.github.io//posts/2014-04-06-start-working-on-exercism.html</guid>
</item>
<item>
    <title>Implement semantic editor combinators</title>
    <link>http://javran.github.io//posts/2014-03-21-implement-semantic-editor-combinators.html</link>
    <description><![CDATA[<span class="blog-date">
    2014-03-21 - 
</span>
<span class="blog-tag">
    
        [ 
        <a href="/tags/haskell.html">haskell</a>, <a href="/tags/lens.html">lens</a>
        ]
    
</span>
<br />
<br />
<div class="blog-main">
<h1 id="intro">Intro</h1>
<p>In <a href="http://conal.net/blog/posts/semantic-editor-combinators">Semantic editor combinators</a>, Conal has shown us a simple but powerful trick of walking into a portion of data and then modifying it.</p>
<p>When I saw this simple idea, I persuaded myself to take it for grainted and tried it out. Even though it works well in practice, I'd like to explain to myself what's happening, which is the motivation of this article.</p>
<p>I'll implement <code>first</code>, <code>second</code>, <code>result</code> and other combinators step by step, and come up with the way to walking into user defined <code>data</code>, which is easy but not presented in Conal's post.</p>
<h1 id="editing-a-pair">Editing a pair</h1>
<p>First we need to think about what the type would be for <code>first</code> and <code>second</code>:</p>
<ul>
<li><p>When we reach for the portion of data, we need to modify it, so we need a function <code>f :: a -&gt; b</code></p></li>
<li><p>We also need a pair of data <code>(x,y) :: (c,d)</code> for this editor's input.</p></li>
<li><p>For <code>first</code>, we want type <code>c = a</code>, and the return value should be of type <code>(b,d)</code></p></li>
<li><p>For <code>second</code>, we want type <code>d = a</code>, and the return value should be of type <code>(c,b)</code></p></li>
</ul>
<p>Put them together, we end up with type signature for <code>first</code> and <code>second</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">first  ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a,d) <span class="ot">-&gt;</span> (b,d)
<span class="ot">second ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (c,a) <span class="ot">-&gt;</span> (c,b)</code></pre>
<p>Introduce <code>f</code> and <code>(x,y)</code> for two arguments, and the implementation is straightforward:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">first  ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a,d) <span class="ot">-&gt;</span> (b,d)
first  f (x,y) <span class="fu">=</span> (f x, y)

<span class="ot">second ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (c,a) <span class="ot">-&gt;</span> (c,b)
second f (x,y) <span class="fu">=</span> (x, f y)</code></pre>
<p>Let's bring up GHCi for some tests:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> first (const <span class="dv">1</span>) (<span class="st">&quot;foo&quot;</span>,<span class="st">&quot;bar&quot;</span>) <span class="co">-- (1, &quot;bar&quot;)</span>
(<span class="dv">1</span>,<span class="st">&quot;bar&quot;</span>)
λ<span class="fu">&gt;</span> second (<span class="fu">*</span> <span class="dv">20</span>) (<span class="dt">Just</span> <span class="dv">1</span>, <span class="dv">1</span>) <span class="co">-- (Just 1, 20)</span>
(<span class="dt">Just</span> <span class="dv">1</span>,<span class="dv">20</span>)</code></pre>
<h1 id="editing-a-function">Editing a function</h1>
<p>There's two way of editing a function: we can either modify the return value (the <code>result</code> combinator), or modify the argument (the <code>argument</code> combinator).</p>
<h2 id="the-result-combinator">the <code>result</code> combinator</h2>
<p>Let's think about the type of <code>result</code>:</p>
<ul>
<li>How to modify a function is given by <code>f :: a -&gt; b</code></li>
<li>The function we want to edit is <code>g :: c -&gt; d</code></li>
<li>We want to modify on the return value of <code>g</code>, therefore <code>d = a</code>.</li>
<li>Then the resulting function should be of type <code>c -&gt; b</code></li>
</ul>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">result ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (c <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (c <span class="ot">-&gt;</span> b)</code></pre>
<p>We know that <code>-&gt;</code> is right-associative, (e.g. <code>p -&gt; q -&gt; r</code> and <code>p -&gt; (q -&gt; r)</code> are equivalent) so we can also think <code>result</code> as a function that accepts 3 arguments, and its type signature becomes:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">result ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (c <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> b</code></pre>
<p>Introduce <code>f</code> <code>g</code> <code>x</code> for these 3 arguments, and we want a value of type <code>b</code>.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">result ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (c <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> b
result f g x <span class="fu">=</span> undefined</code></pre>
<ul>
<li>To produce a value of <code>b</code>, we might need <code>f :: a -&gt; b</code>.</li>
<li>To produce a value of <code>a</code>, we might need <code>g :: c -&gt; a</code>.</li>
<li><code>x</code> is of type <code>c</code></li>
</ul>
<p>Chaining these facts together, we yield the implementation of <code>result</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">result ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (c <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> b
result f g x <span class="fu">=</span> f (g x)</code></pre>
<p>This is exactly the definition of <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/src/GHC-Base.html#."><code>(.)</code></a>, function composition.</p>
<p>So we end up with:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">result ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (c <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> b
result <span class="fu">=</span> (<span class="fu">.</span>)</code></pre>
<p>Test it:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> result (<span class="fu">+</span><span class="dv">2</span>) (<span class="fu">*</span><span class="dv">5</span>) <span class="dv">1</span> <span class="co">-- 1 * 5 + 2 = 7</span>
<span class="dv">7</span></code></pre>
<h2 id="the-argument-combinator">the <code>argument</code> combinator</h2>
<p>Use the same approach, let’s implement <code>argument</code> combinator:</p>
<ul>
<li><code>f :: a -&gt; b</code> to modify the argument</li>
<li><code>g :: c -&gt; d</code> the function to be modified</li>
<li><code>b = c</code> so that the type of <code>f</code> and <code>g</code> matches.</li>
<li>the resulting function should be of type <code>a -&gt; d</code>.</li>
</ul>
<p>Write down the type signature, introduce <code>f</code>, <code>g</code>, <code>x</code>, the goal is to produce a value of type <code>d</code></p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">argument ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> d
argument f g x <span class="fu">=</span> undefined</code></pre>
<ul>
<li>To produce a value of <code>d</code>, we might need <code>g :: b -&gt; d</code>.</li>
<li>To produce a value of <code>b</code>, we might need <code>f :: a -&gt; b</code>.</li>
<li><code>x</code> is of type <code>a</code></li>
</ul>
<p>Therefore the definition of <code>argument</code> is:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">argument ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> d
argument f g x <span class="fu">=</span> g (f x)</code></pre>
<p>To simplify this, we do some transformations:</p>
<pre><code>  g (f x)
&gt; (g . f) x           -- definition of (.)
&gt; (.) g f x           -- infix operator
&gt; ((.) g f) x         -- property of curried function
&gt; ((flip (.)) f g) x  -- flip
&gt; flip (.) f g x      -- rule of function application</code></pre>
<p>Finally:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">argument ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> d
<span class="co">-- point-free style of: argument f g x = flip (.) f g x</span>
argument <span class="fu">=</span> flip (<span class="fu">.</span>)</code></pre>
<p>Test it:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> argument show (\x <span class="ot">-&gt;</span> x <span class="fu">++</span> <span class="st">&quot;!&quot;</span>) <span class="dv">2048</span> <span class="co">-- 2048!</span>
<span class="st">&quot;2048!&quot;</span></code></pre>
<h1 id="walking-into-data">Walking into data</h1>
<p>For now we have <code>first</code> and <code>second</code> to work with pairs, and <code>argument</code> and <code>result</code> with functions, but sometimes we want to go deeper inside data, say:</p>
<ul>
<li>Goal 1: we want <code>2</code> to be <code>5</code> in <code>(7,(2,1))</code></li>
<li>Goal 2: we want <code>a+b</code> to be <code>(a+b)*2</code> in <code>\a -&gt; (a+1 ,\b -&gt; (a+b, 1))</code></li>
</ul>
<p>Here I try to give some explanation of how to do this.</p>
<h2 id="goal-1">Goal 1</h2>
<p>To modify <code>d</code> in <code>(a,(c,d))</code>, that means we need to first focus on <code>(c,d)</code>, this can be achieved by <code>second</code>, let’s pass a const function <code>const &quot;Focus&quot;</code> to <code>second</code>, so we know we are focusing on which portion of the data:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> <span class="kw">let</span> d1 <span class="fu">=</span> (<span class="dv">7</span>,(<span class="dv">2</span>,<span class="dv">1</span>))
λ<span class="fu">&gt;</span> <span class="kw">let</span> toFocus <span class="fu">=</span> const <span class="st">&quot;Focus&quot;</span>
λ<span class="fu">&gt;</span> second toFocus d1
(<span class="dv">7</span>,<span class="st">&quot;Focus&quot;</span>)</code></pre>
<p>We now know that missing <code>(2,1)</code> is passed to <code>toFocus</code>, we can use a lambda expression to capture it:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> second (\x <span class="ot">-&gt;</span> x) d1
(<span class="dv">7</span>,(<span class="dv">2</span>,<span class="dv">1</span>))</code></pre>
<p>Let's do something more interesting:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> second (\x <span class="ot">-&gt;</span> <span class="kw">let</span> (a,b) <span class="fu">=</span> x <span class="kw">in</span> (a<span class="fu">+</span><span class="dv">1</span>,b,b)) d1
(<span class="dv">7</span>,(<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">1</span>))</code></pre>
<p>The observation is: inside the body of lambda expression <code>\x -&gt; ...</code>, we can do something to <code>(2,1)</code>. That means we can apply semantic editor combinators on it!</p>
<p>Now assume we are dealing with <code>(2,1)</code>, to reach the goal, we apply <code>const 5</code> to its <code>fst</code> part:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> first (const <span class="dv">5</span>) (<span class="dv">2</span>,<span class="dv">1</span>)
(<span class="dv">5</span>,<span class="dv">1</span>)</code></pre>
<p>Now replace the body of <code>\x -&gt; ...</code> with what we want:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> second (\x <span class="ot">-&gt;</span> first (const <span class="dv">5</span>) x) d1
(<span class="dv">7</span>,(<span class="dv">5</span>,<span class="dv">1</span>))</code></pre>
<p>Done!</p>
<h2 id="some-intuition">Some intuition</h2>
<p>Let's not hurry to Goal 2, I’ll show you some transformations:</p>
<pre><code>  second (\x -&gt; first (const 5) x) d1
&gt; second (first (const 5)) d1         -- eta reduction / point-free
&gt; (second (first (const 5))) d1       -- rule of function application
&gt; ((second . first) (const 5)) d1     -- definition of (.)</code></pre>
<p>I don’t simplify it to <code>(second . first) (const 5) d1</code> on purpose, and I’m going to show you why.</p>
<p>It might not be straightforward at first glance, since function composition is usually “right to left”, that is, <code>(g . f)</code> means “first apply <code>f</code>, on its result, apply <code>g</code>. But here, <code>second . first</code> can be read as”walk to the <code>snd</code> part, and then <code>fst</code> part of it“.</p>
<p>My explanation is: <strong>the function does compose from right to left, but what’s “carrying” with the composition is not the data</strong>.</p>
<p>The observation is: no matter how many functions are composed together, the resulting function just takes one argument:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> <span class="kw">let</span> u <span class="fu">=</span> undefined
λ<span class="fu">&gt;</span> <span class="fu">:</span>t u <span class="fu">.</span> u
u <span class="fu">.</span><span class="ot"> u ::</span> a <span class="ot">-&gt;</span> c
λ<span class="fu">&gt;</span> <span class="fu">:</span>t u <span class="fu">.</span> u <span class="fu">.</span> u <span class="fu">.</span> u
u <span class="fu">.</span> u <span class="fu">.</span> u <span class="fu">.</span><span class="ot"> u ::</span> a <span class="ot">-&gt;</span> c
λ<span class="fu">&gt;</span> <span class="fu">:</span>t u <span class="fu">.</span> u <span class="fu">.</span> u <span class="fu">.</span> u <span class="fu">.</span> u
u <span class="fu">.</span> u <span class="fu">.</span> u <span class="fu">.</span> u <span class="fu">.</span><span class="ot"> u ::</span> a <span class="ot">-&gt;</span> c</code></pre>
<p>So what is the argument taken by this resulting function? In our Goal 1, it is <code>const 5</code>, the “how we modify it” part. So despite that <code>(second . first) (const 5) d1</code> is simple, to understand it, what you really need would be: <code>((second . first) (const 5)) d1</code></p>
<p>The observation is: <strong>functions are composed from right to left and the mutator is buried more deeply as the composition goes</strong>.</p>
<p>To see this, let's just pick up combinators randomly to form a chain of function composition, and check its type:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> <span class="fu">:</span>t first (const <span class="dv">5</span>)
first (const <span class="dv">5</span>)<span class="ot"> ::</span> <span class="dt">Num</span> b <span class="ot">=&gt;</span> (a, d) <span class="ot">-&gt;</span> (b, d)
λ<span class="fu">&gt;</span> <span class="fu">:</span>t (second <span class="fu">.</span> first) (const <span class="dv">5</span>)
(second <span class="fu">.</span> first) (const <span class="dv">5</span>)<span class="ot"> ::</span> <span class="dt">Num</span> b <span class="ot">=&gt;</span> (c, (a, d)) <span class="ot">-&gt;</span> (c, (b, d))
λ<span class="fu">&gt;</span> <span class="fu">:</span>t (result <span class="fu">.</span> second <span class="fu">.</span> first) (const <span class="dv">5</span>)
(result <span class="fu">.</span> second <span class="fu">.</span> first) (const <span class="dv">5</span>)
<span class="ot">  ::</span> <span class="dt">Num</span> b <span class="ot">=&gt;</span> (c <span class="ot">-&gt;</span> (c1, (a, d))) <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> (c1, (b, d))
λ<span class="fu">&gt;</span> <span class="fu">:</span>t (second <span class="fu">.</span> result <span class="fu">.</span> second <span class="fu">.</span> first) (const <span class="dv">5</span>)
(second <span class="fu">.</span> result <span class="fu">.</span> second <span class="fu">.</span> first) (const <span class="dv">5</span>)
<span class="ot">  ::</span> <span class="dt">Num</span> b <span class="ot">=&gt;</span> (c, c1 <span class="ot">-&gt;</span> (c2, (a, d))) <span class="ot">-&gt;</span> (c, c1 <span class="ot">-&gt;</span> (c2, (b, d)))
λ<span class="fu">&gt;</span> <span class="fu">:</span>t (first <span class="fu">.</span> second <span class="fu">.</span> result <span class="fu">.</span> second <span class="fu">.</span> first) (const <span class="dv">5</span>)
(first <span class="fu">.</span> second <span class="fu">.</span> result <span class="fu">.</span> second <span class="fu">.</span> first) (const <span class="dv">5</span>)
<span class="ot">  ::</span> <span class="dt">Num</span> b <span class="ot">=&gt;</span>
     ((c, c1 <span class="ot">-&gt;</span> (c2, (a, d1))), d) <span class="ot">-&gt;</span> ((c, c1 <span class="ot">-&gt;</span> (c2, (b, d1))), d)</code></pre>
<p>Reading the composition from right to left, <strong>we are constructing / definiting the “shape” of the data this combinator would like to work on</strong>. In contrast, reading from left to right, <strong>we are deconstructing the data until we reach for the position that we want to modify</strong>. These two views does not conflict with each other.</p>
<p>Therefore, IMHO, when we are thinking about how to walking into the interesting portion, it's helpful thinking about build up combinator from left to right. But to answer the question about why, we should instead read from right to left.</p>
<p>In addition, here is another interesting observation:</p>
<pre><code>    (&lt;comb1&gt; . &lt;comb2&gt;) (&lt;comb3&gt; . &lt;mutator&gt;) d1
&lt;=&gt; (&lt;comb1&gt; . &lt;comb2&gt; . &lt;comb3&gt;) &lt;mutator&gt; d1</code></pre>
<p>The shape of semantic editor combinators are always: <code>{comb} {mut} {dat}</code></p>
<p>So if we see a combinator appear as the head of the <code>(.)</code> chain in <code>{mut}</code>, we can move it to the tail of the <code>(.)</code> chain in <code>{comb}</code>, and the other way around also holds true.</p>
<h2 id="goal-2">Goal 2</h2>
<p>Recall Goal 2: we want <code>a+b</code> to be <code>(a+b)*2</code> in <code>\a -&gt; (a+1, \b -&gt; (a+b, 1))</code></p>
<p>Based on the previous understand, we need to:</p>
<ul>
<li>walk into <code>(a+1, \b -&gt; (a+b, 1))</code>, using <code>result</code></li>
<li>walk into <code>\b -&gt; (a+b, 1)</code>, using <code>second</code></li>
<li>walk into <code>(a+b, 1)</code>, using <code>result</code></li>
<li>walk into <code>(a+b)</code>, using <code>first</code></li>
<li>apply <code>(* 2)</code></li>
</ul>
<p>Try it out:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> <span class="kw">let</span> d2 <span class="fu">=</span> \a <span class="ot">-&gt;</span> (a<span class="fu">+</span><span class="dv">1</span>, \b <span class="ot">-&gt;</span> (a<span class="fu">+</span>b, <span class="dv">1</span>))
λ<span class="fu">&gt;</span> <span class="kw">let</span> m2 <span class="fu">=</span> (result <span class="fu">.</span> second <span class="fu">.</span> result <span class="fu">.</span> first) (<span class="fu">*</span><span class="dv">2</span>) d2
λ<span class="fu">&gt;</span> (snd (d2 <span class="dv">10</span>)) <span class="dv">20</span>
(<span class="dv">30</span>,<span class="dv">1</span>)
λ<span class="fu">&gt;</span> (snd (m2 <span class="dv">10</span>)) <span class="dv">20</span>
(<span class="dv">60</span>,<span class="dv">1</span>)
λ<span class="fu">&gt;</span> fst ((snd (d2 <span class="dv">10</span>)) <span class="dv">20</span>)
<span class="dv">30</span>
λ<span class="fu">&gt;</span> fst ((snd (m2 <span class="dv">10</span>)) <span class="dv">20</span>)
<span class="dv">60</span>
λ<span class="fu">&gt;</span> (fst <span class="fu">.</span> (<span class="fu">$</span> <span class="dv">20</span>) <span class="fu">.</span> snd <span class="fu">.</span> (<span class="fu">$</span> <span class="dv">10</span>)) d2
<span class="dv">30</span>
λ<span class="fu">&gt;</span> (fst <span class="fu">.</span> (<span class="fu">$</span> <span class="dv">20</span>) <span class="fu">.</span> snd <span class="fu">.</span> (<span class="fu">$</span> <span class="dv">10</span>)) m2
<span class="dv">60</span></code></pre>
<p>Last two programs are just rewriting the two programs right before it, Do you notice the symmetry between <code>fst . ($ 20) . snd . ($ 10)</code> and <code>result . second . result . first</code>?</p>
<p>I believe this is not an accident, but to explain it might beyond my reach, this is what I have for now:</p>
<p>With the help of <a href="http://www.haskell.org/haskellwiki/Lambdabot">Lambdabot</a>:</p>
<pre><code>   (fst . ($ 20) . snd . ($ 10)) (result . second . result . first) (*2) d2
&gt;  fst (snd (result (second (result (first 10)))) 20) (2 *) d2</code></pre>
<p>I guess when <code>fst</code> and <code>first</code> meet together, or when <code>($ 10)</code> and <code>result</code> meet together, etc. they will be somehow “cancelled”. If someone knows how to finish this explanation, please let me know.</p>
<h1 id="play-with-lists">Play with lists</h1>
<p>Conal has shown us <code>element</code>, which walks into every element of a list.</p>
<p>It’s easy to work out its type signature:</p>
<ul>
<li>how to modify: <code>f :: a -&gt; b</code></li>
<li>data to be modified: <code>[a]</code></li>
<li>resulting data: <code>[b]</code></li>
</ul>
<p>and this is exactly <code>map</code>.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">element ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]
element <span class="fu">=</span> map</code></pre>
<p>Here I show you 3 extra combinators:</p>
<p><em>inHead</em> modifies the head of a list:</p>
<ul>
<li>how to modify: <code>f :: a -&gt; a</code> (list can only contain elements of same types)</li>
<li>data to be modified: <code>[a]</code></li>
<li>resulting data: <code>[a]</code></li>
</ul>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">inHead ::</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]
inHead f [] <span class="fu">=</span> []
inHead f (x<span class="fu">:</span>xs) <span class="fu">=</span> f x <span class="fu">:</span> xs</code></pre>
<p><em>inTail</em> modifies the tail of a list:</p>
<ul>
<li>how to modify: <code>f :: [a] -&gt; [a]</code></li>
<li>data to be modified: <code>[a]</code></li>
<li>resulting data: <code>[a]</code></li>
</ul>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">inTail ::</span> ([a] <span class="ot">-&gt;</span> [a]) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]
inTail f [] <span class="fu">=</span> []
inTail f (x<span class="fu">:</span>xs) <span class="fu">=</span> x <span class="fu">:</span> f xs</code></pre>
<p><em>inPos</em> modifies the element at a given position:</p>
<ul>
<li>we first need the position: <code>Int</code></li>
<li>how to modify: <code>f :: a -&gt; a</code></li>
<li>data to be modified: <code>[a]</code></li>
<li>resulting data: <code>[a]</code></li>
</ul>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">inPos ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]
inPos n f xs
      <span class="fu">|</span> null xs    <span class="fu">=</span> xs
      <span class="fu">|</span> n <span class="fu">&lt;</span> <span class="dv">0</span>      <span class="fu">=</span> xs
      <span class="fu">|</span> n <span class="fu">==</span> <span class="dv">0</span>     <span class="fu">=</span> <span class="kw">let</span> (y<span class="fu">:</span>ys) <span class="fu">=</span> xs
                     <span class="kw">in</span> f y <span class="fu">:</span> ys
      <span class="fu">|</span> otherwise  <span class="fu">=</span> <span class="kw">let</span> (y<span class="fu">:</span>ys) <span class="fu">=</span> xs
                     <span class="kw">in</span> y <span class="fu">:</span> inPos (n <span class="fu">-</span> <span class="dv">1</span>) f ys</code></pre>
<p><em>inSome</em> is like <code>inPos</code>, but modifies multiple positions:</p>
<ul>
<li>we first need the indices: <code>[Int]</code></li>
<li>how to modify: <code>f :: a -&gt; a</code></li>
<li>data to be modified: <code>[a]</code></li>
<li>resulting data: <code>[a]</code></li>
</ul>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">inSome ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]
inSome ixs f xs <span class="fu">=</span> foldl (\acc i <span class="ot">-&gt;</span> inPos i f acc) xs ixs</code></pre>
<p>Some examples:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> <span class="kw">let</span> d1 <span class="fu">=</span> (<span class="st">&quot;foo&quot;</span>,[<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>])
λ<span class="fu">&gt;</span> (second <span class="fu">.</span> element) (<span class="fu">+</span> <span class="dv">1</span>) d1
(<span class="st">&quot;foo&quot;</span>,[<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>,<span class="dv">11</span>])
λ<span class="fu">&gt;</span> (first <span class="fu">.</span> element) ord d1
([<span class="dv">102</span>,<span class="dv">111</span>,<span class="dv">111</span>],[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>])
λ<span class="fu">&gt;</span> (second <span class="fu">.</span> inTail) (take <span class="dv">2</span>) d1
(<span class="st">&quot;foo&quot;</span>,[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>])
λ<span class="fu">&gt;</span> (second <span class="fu">.</span> inHead) (<span class="fu">*</span> <span class="dv">200</span>) d1
(<span class="st">&quot;foo&quot;</span>,[<span class="dv">200</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>])
λ<span class="fu">&gt;</span> (second <span class="fu">.</span> inPos <span class="dv">3</span>) (<span class="fu">*</span> <span class="dv">200</span>) d1
(<span class="st">&quot;foo&quot;</span>,[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">800</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>])
λ<span class="fu">&gt;</span> <span class="kw">let</span> d2 <span class="fu">=</span> replicate <span class="dv">3</span> (replicate <span class="dv">4</span> <span class="dv">0</span>)
λ<span class="fu">&gt;</span> (inPos <span class="dv">1</span> <span class="fu">.</span> inPos <span class="dv">2</span>) (const <span class="dv">255</span>) d2
[[<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>],[<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">255</span>,<span class="dv">0</span>],[<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>]]</code></pre>
<h1 id="walking-into-user-defined-data">Walking into user defined data</h1>
<p>Suppose user has defined a binary tree:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">BinTree</span> a <span class="fu">=</span> <span class="dt">Node</span> a
               <span class="fu">|</span> <span class="dt">Tree</span> (<span class="dt">BinTree</span> a) (<span class="dt">BinTree</span> a) a
                 <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Functor</span>)</code></pre>
<p>To write a combinator is easy, just follow the pattern <code>&lt;combinator&gt; &lt;mutator&gt; &lt;data&gt; = &lt;modified-data&gt;</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">treeV ::</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">BinTree</span> a <span class="ot">-&gt;</span> <span class="dt">BinTree</span> a
treeV f (<span class="dt">Node</span> x) <span class="fu">=</span> <span class="dt">Node</span> (f x)
treeV f (<span class="dt">Tree</span> l r x) <span class="fu">=</span> <span class="dt">Tree</span> l r (f x)

<span class="ot">treeElement ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">BinTree</span> a <span class="ot">-&gt;</span> <span class="dt">BinTree</span> b
treeElement <span class="fu">=</span> fmap

<span class="ot">treeLeft ::</span> (<span class="dt">BinTree</span> a <span class="ot">-&gt;</span> <span class="dt">BinTree</span> a) <span class="ot">-&gt;</span> <span class="dt">BinTree</span> a <span class="ot">-&gt;</span> <span class="dt">BinTree</span> a
treeLeft f (<span class="dt">Tree</span> l r e) <span class="fu">=</span> <span class="dt">Tree</span> (f l) r e
treeLeft f r <span class="fu">=</span> r

<span class="ot">treeRight ::</span> (<span class="dt">BinTree</span> a <span class="ot">-&gt;</span> <span class="dt">BinTree</span> a) <span class="ot">-&gt;</span> <span class="dt">BinTree</span> a <span class="ot">-&gt;</span> <span class="dt">BinTree</span> a
treeRight f (<span class="dt">Tree</span> l r e) <span class="fu">=</span> <span class="dt">Tree</span> l (f r) e
treeRight f r <span class="fu">=</span> r

<span class="ot">treeNonLeaf ::</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">BinTree</span> a <span class="ot">-&gt;</span> <span class="dt">BinTree</span> a
treeNonLeaf f (<span class="dt">Tree</span> l r e) <span class="fu">=</span> <span class="dt">Tree</span> (treeNonLeaf f l) (treeNonLeaf f r) (f e)
treeNonLeaf f r <span class="fu">=</span> r

<span class="ot">treeLeaf ::</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">BinTree</span> a <span class="ot">-&gt;</span> <span class="dt">BinTree</span> a
treeLeaf f (<span class="dt">Node</span> x) <span class="fu">=</span> <span class="dt">Node</span> (f x)
treeLeaf f (<span class="dt">Tree</span> l r x) <span class="fu">=</span> <span class="dt">Tree</span> (treeLeaf f l) (treeLeaf f r) x</code></pre>
<p>Here <code>treeElement</code> walks into the data part of each node to do the modification. Since <code>treeElement = fmap</code>, we can generalize <code>element = fmap</code>, to make it work for not only lists and <code>BinTree</code>s, but also any other Functors.</p>
<p><code>treeLeft</code> and <code>treeRight</code> walks into left subtree and right subtree, respectively. But to target at the value of a <code>BinTree</code>, we need <code>treeV</code>, which takes care of walking into the data field of a tree.</p>
<p><code>treeNonLeaf</code> and <code>treeLeaf</code> are just like <code>treeElement</code> but works merely on non-leaf nodes and leaf nodes, respectively.</p>
<p>See them in action:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> <span class="kw">let</span> d1 <span class="fu">=</span> <span class="dt">Tree</span> (<span class="dt">Tree</span> (<span class="dt">Node</span> (<span class="dv">1</span>,<span class="dv">1</span>)) (<span class="dt">Node</span> (<span class="dv">1</span>,<span class="dv">2</span>)) (<span class="dv">2</span>,<span class="dv">2</span>)) (<span class="dt">Node</span> (<span class="dv">3</span>,<span class="dv">4</span>)) (<span class="dv">5</span>,<span class="dv">6</span>)
λ<span class="fu">&gt;</span> (treeElement <span class="fu">.</span> first) even d1 <span class="co">-- test for each node, if the `fst` part is an even?</span>
<span class="dt">Tree</span> (<span class="dt">Tree</span> (<span class="dt">Node</span> (<span class="dt">False</span>,<span class="dv">1</span>)) (<span class="dt">Node</span> (<span class="dt">False</span>,<span class="dv">2</span>)) (<span class="dt">True</span>,<span class="dv">2</span>)) (<span class="dt">Node</span> (<span class="dt">False</span>,<span class="dv">4</span>)) (<span class="dt">False</span>,<span class="dv">6</span>)
λ<span class="fu">&gt;</span> (treeLeft <span class="fu">.</span> treeV <span class="fu">.</span> first) (<span class="fu">*</span> <span class="dv">4</span>) d1 <span class="co">-- walk into left subtree, multiple `fst` part of its value by 4</span>
<span class="dt">Tree</span> (<span class="dt">Tree</span> (<span class="dt">Node</span> (<span class="dv">1</span>,<span class="dv">1</span>)) (<span class="dt">Node</span> (<span class="dv">1</span>,<span class="dv">2</span>)) (<span class="dv">2</span>,<span class="dv">2</span>)) (<span class="dt">Node</span> (<span class="dv">3</span>,<span class="dv">4</span>)) (<span class="dv">5</span>,<span class="dv">6</span>)
λ<span class="fu">&gt;</span> (treeLeft <span class="fu">.</span> treeRight <span class="fu">.</span> treeV <span class="fu">.</span> first) (<span class="fu">*</span> <span class="dv">4</span>) d1 <span class="co">-- walk into the right subtree of the left subtree, ..</span>
<span class="dt">Tree</span> (<span class="dt">Tree</span> (<span class="dt">Node</span> (<span class="dv">1</span>,<span class="dv">1</span>)) (<span class="dt">Node</span> (<span class="dv">4</span>,<span class="dv">2</span>)) (<span class="dv">2</span>,<span class="dv">2</span>)) (<span class="dt">Node</span> (<span class="dv">3</span>,<span class="dv">4</span>)) (<span class="dv">5</span>,<span class="dv">6</span>)
λ<span class="fu">&gt;</span> (treeNonLeaf <span class="fu">.</span> first) (const <span class="dv">100</span>) d1 <span class="co">-- for each value of the `fst` part of each non-leaf node</span>
<span class="dt">Tree</span> (<span class="dt">Tree</span> (<span class="dt">Node</span> (<span class="dv">1</span>,<span class="dv">1</span>)) (<span class="dt">Node</span> (<span class="dv">1</span>,<span class="dv">2</span>)) (<span class="dv">100</span>,<span class="dv">2</span>)) (<span class="dt">Node</span> (<span class="dv">3</span>,<span class="dv">4</span>)) (<span class="dv">100</span>,<span class="dv">6</span>)
λ<span class="fu">&gt;</span> (treeLeaf <span class="fu">.</span> second) (const <span class="dv">100</span>) d1 <span class="co">-- for each value of the `snd` part of each leaf node</span>
<span class="dt">Tree</span> (<span class="dt">Tree</span> (<span class="dt">Node</span> (<span class="dv">1</span>,<span class="dv">100</span>)) (<span class="dt">Node</span> (<span class="dv">1</span>,<span class="dv">100</span>)) (<span class="dv">2</span>,<span class="dv">2</span>)) (<span class="dt">Node</span> (<span class="dv">3</span>,<span class="dv">100</span>)) (<span class="dv">5</span>,<span class="dv">6</span>)</code></pre>
<h1 id="combining-semantic-editor-combinators">Combining semantic editor combinators</h1>
<p>The semantic editor combinators can also be chained together.</p>
<p>Suppose we have some combinators:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> <span class="kw">let</span> c13 <span class="fu">=</span> (inPos <span class="dv">1</span>) (const <span class="dv">3</span>)
λ<span class="fu">&gt;</span> <span class="kw">let</span> c05 <span class="fu">=</span> (inPos <span class="dv">0</span>) (const <span class="dv">5</span>)
λ<span class="fu">&gt;</span> <span class="kw">let</span> c06 <span class="fu">=</span> (inPos <span class="dv">0</span>) (const <span class="dv">6</span>)
λ<span class="fu">&gt;</span> <span class="kw">let</span> cf1 <span class="fu">=</span> first (const <span class="dv">1</span>)</code></pre>
<p>For a given list, we want to apply <code>c13</code> and <code>c05</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> <span class="kw">let</span> d <span class="fu">=</span> replicate <span class="dv">5</span> <span class="dv">0</span>
λ<span class="fu">&gt;</span> c06 (c13 d)
[<span class="dv">6</span>,<span class="dv">3</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>]
λ<span class="fu">&gt;</span> (c06 <span class="fu">.</span> c13) d
[<span class="dv">6</span>,<span class="dv">3</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>]</code></pre>
<p>So we can use function composition to compose semantic editors:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> <span class="kw">let</span> d2 <span class="fu">=</span> (<span class="dv">10</span>,replicate <span class="dv">5</span> <span class="dv">0</span>)
λ<span class="fu">&gt;</span> (cf1 <span class="fu">.</span> (second c13)) d2
(<span class="dv">1</span>,[<span class="dv">0</span>,<span class="dv">3</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>])
λ<span class="fu">&gt;</span> (cf1 <span class="fu">.</span> (second c13) <span class="fu">.</span> (second c05)) d2
(<span class="dv">1</span>,[<span class="dv">5</span>,<span class="dv">3</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>])
λ<span class="fu">&gt;</span> (cf1 <span class="fu">.</span> (second (c13 <span class="fu">.</span> c05))) d2
(<span class="dv">1</span>,[<span class="dv">5</span>,<span class="dv">3</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>])</code></pre>
<p>The last example says “apply <code>1</code>, (back to the top level and then) walk into the <code>snd</code> part, apply <code>c05</code> and then <code>c13</code>”. I think this “distributive property” will make things extremely flexible.</p>
<p>Since the function composition happens from right to left, if some combinators are trying to modify the same field, the “leftmost” one take effect:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> (c05 <span class="fu">.</span> c06) [<span class="dv">0</span>,<span class="dv">1</span>]
[<span class="dv">5</span>,<span class="dv">1</span>]
λ<span class="fu">&gt;</span> (c06 <span class="fu">.</span> c05) [<span class="dv">0</span>,<span class="dv">1</span>]
[<span class="dv">6</span>,<span class="dv">1</span>]</code></pre>
</div>
]]></description>
    <pubDate>Fri, 21 Mar 2014 00:00:00 UT</pubDate>
    <guid>http://javran.github.io//posts/2014-03-21-implement-semantic-editor-combinators.html</guid>
</item>
<item>
    <title>Capture the notion of invertible functions</title>
    <link>http://javran.github.io//posts/2014-03-17-capture-the-notion-of-invertible-functions.html</link>
    <description><![CDATA[<span class="blog-date">
    2014-03-17 - 
</span>
<span class="blog-tag">
    
        [ 
        <a href="/tags/haskell.html">haskell</a>
        ]
    
</span>
<br />
<br />
<div class="blog-main">
<h1 id="intro">Intro</h1>
<p>This article is originally posted on <a href="http://codereview.stackexchange.com/questions/44550/capture-the-notion-of-invertible-functions">Code Review</a>. And I think this can also be a good post.</p>
<h1 id="motivation">Motivation</h1>
<p>I find sometimes it is useful to capture the notion of invertible functions.</p>
<p>The idea is that if two functions <code>f :: a -&gt; b</code> and <code>g :: b -&gt; a</code> are the inverse function of each other, and if there is another function <code>h :: b -&gt; b</code>, then <code>h</code> can also work on values of type <code>a</code>.</p>
<p>Moreover, if there<code>f'</code> and <code>g'</code> are another pair of functions that are the inverse function of each other, <code>(f,g)</code> and <code>(f',g')</code> can actually be composed to <code>(f' . f, g . g')</code> and the invertibility still holds.</p>
<p>The following is my attempt to implement this in haskell, and I’m wondering if an existing library can do the same thing (or even more general thing) for me. Also advice and comments about my code are appreciated.</p>
<h1 id="implemnetation">Implemnetation</h1>
<p>First I use records to store two functions:</p>
<pre class="hasekll"><code>data Invertible a b = Invertible
    { into :: a -&gt; b
    , back :: b -&gt; a
    }</code></pre>
<p><code>into</code> means “convert a into b” while <code>back</code> means “convert b back to a”.</p>
<p>And then few helper functions:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">selfInv ::</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Invertible</span> a a
selfInv f <span class="fu">=</span> <span class="dt">Invertible</span> f f

<span class="ot">flipInv ::</span> <span class="dt">Invertible</span> a b <span class="ot">-&gt;</span> <span class="dt">Invertible</span> b a
flipInv (<span class="dt">Invertible</span> f g) <span class="fu">=</span> <span class="dt">Invertible</span> g f

<span class="ot">borrow ::</span> <span class="dt">Invertible</span> a b <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
borrow (<span class="dt">Invertible</span> fIn fOut) g <span class="fu">=</span> fOut <span class="fu">.</span> g <span class="fu">.</span> fIn

<span class="ot">liftInv ::</span> (<span class="dt">Functor</span> f) <span class="ot">=&gt;</span> <span class="dt">Invertible</span> a b <span class="ot">-&gt;</span> <span class="dt">Invertible</span> (f a) (f b)
liftInv (<span class="dt">Invertible</span> a b) <span class="fu">=</span> <span class="dt">Invertible</span> (fmap a) (fmap b)</code></pre>
<p>In the above code <code>borrow</code> will use the pair of functions to make its last argument <code>g</code> available to values of type <code>a</code>. And changing <code>borrow f</code> to <code>borrow (flipInv f)</code> will make <code>g</code> available to values of type <code>b</code>. Therefore <code>borrow</code> captures my initial idea of making a function of type <code>b -&gt; b</code> available for values of <code>a</code> if <code>a</code> and <code>b</code> can be converted to each other.</p>
<p>In addition, <code>Invertible</code> forms a monoid-like structure, I use <code>rappend</code> and <code>rempty</code> to suggest a similiarity between it and <code>Monoid</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">rempty ::</span> <span class="dt">Invertible</span> a a
rempty <span class="fu">=</span> selfInv id

<span class="ot">rappend ::</span> <span class="dt">Invertible</span> a b
        <span class="ot">-&gt;</span> <span class="dt">Invertible</span> b c
        <span class="ot">-&gt;</span> <span class="dt">Invertible</span> a c
(<span class="dt">Invertible</span> f1 g1) <span class="ot">`rappend`</span> (<span class="dt">Invertible</span> f2 g2) <span class="fu">=</span>
    <span class="dt">Invertible</span> (f2 <span class="fu">.</span> f1) (g1 <span class="fu">.</span> g2)</code></pre>
<h1 id="examples">Examples</h1>
<p>Here I have two examples to demonstrate that <code>Invertible</code> might be useful.</p>
<h2 id="data-encryption">Data Encryption</h2>
<p>It is natural that <code>Invertible</code> can be used under scenario of symmetric encryption. <code>Invertible (encrypt key) (decrypt key)</code> might be one instance if:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">encrypt ::</span> <span class="dt">Key</span> <span class="ot">-&gt;</span> <span class="dt">PlainText</span> <span class="ot">-&gt;</span> <span class="dt">CipherText</span>
<span class="ot">decrypt ::</span> <span class="dt">Key</span> <span class="ot">-&gt;</span> <span class="dt">CipherText</span> <span class="ot">-&gt;</span> <span class="dt">PlainText</span></code></pre>
<p>To simplify a little, I make an example of <a href="https://en.wikipedia.org/wiki/Caesar_Cipher">Caesar cipher</a> and assume that plain text contains only uppercase letters:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- constructor should be invisible from outside</span>
<span class="kw">newtype</span> <span class="dt">OnlyUpper</span> a <span class="fu">=</span> <span class="dt">OnlyUpper</span>
    {<span class="ot"> getOU ::</span> [a]
    } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>, <span class="dt">Functor</span>)

<span class="ot">ouAsList ::</span> <span class="dt">Invertible</span> (<span class="dt">OnlyUpper</span> a) [a]
ouAsList <span class="fu">=</span> <span class="dt">Invertible</span> getOU <span class="dt">OnlyUpper</span>

<span class="ot">onlyUpper ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">OnlyUpper</span> <span class="dt">Char</span>
onlyUpper <span class="fu">=</span> <span class="dt">OnlyUpper</span> <span class="fu">.</span> filter isAsciiUpper

<span class="ot">upperAsOrd ::</span> <span class="dt">Invertible</span> <span class="dt">Char</span> <span class="dt">Int</span>
upperAsOrd <span class="fu">=</span> <span class="dt">Invertible</span> ord&#39; chr&#39;
    <span class="kw">where</span>
        ord&#39; x <span class="fu">=</span> ord x <span class="fu">-</span> ord <span class="ch">&#39;A&#39;</span>
        chr&#39; x <span class="fu">=</span> chr (x <span class="fu">+</span> ord <span class="ch">&#39;A&#39;</span>)</code></pre>
<p>And Caesar Cipher is basically doing some modular arithmetic:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">modShift ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Invertible</span> <span class="dt">Int</span> <span class="dt">Int</span>
modShift base offset <span class="fu">=</span> <span class="dt">Invertible</span> f g
    <span class="kw">where</span>
        f x <span class="fu">=</span> (x <span class="fu">+</span> offset) <span class="ot">`mod`</span> base
        g y <span class="fu">=</span> (y <span class="fu">+</span> (base <span class="fu">-</span> offset)) <span class="ot">`mod`</span> base

<span class="ot">caesarShift ::</span> <span class="dt">Invertible</span> <span class="dt">Int</span> <span class="dt">Int</span>
caesarShift <span class="fu">=</span> modShift <span class="dv">26</span> <span class="dv">4</span>

<span class="ot">caesarCipher ::</span> <span class="dt">Invertible</span> (<span class="dt">OnlyUpper</span> <span class="dt">Char</span>) (<span class="dt">OnlyUpper</span> <span class="dt">Char</span>)
caesarCipher <span class="fu">=</span> liftInv (upperAsOrd
                       <span class="co">-- Char &lt;-&gt; Int</span>
                       <span class="ot">`rappend`</span> caesarShift
                       <span class="co">-- Int &lt;-&gt; Int</span>
                       <span class="ot">`rappend`</span> flipInv upperAsOrd)
                       <span class="co">-- Int &lt;-&gt; Char</span></code></pre>
<p>One way to use <code>Invertible</code> is just using its <code>into</code> and <code>back</code> as <code>encrypt</code> and <code>decrypt</code>, and <code>Invertible</code> also gives you the power of manipulating encrypyed data as if it was plain text:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">exampleCaesar ::</span> <span class="dt">IO</span> ()
exampleCaesar <span class="fu">=</span> <span class="kw">do</span>
    <span class="kw">let</span> encF <span class="fu">=</span> into caesarCipher
        decF <span class="fu">=</span> back caesarCipher
        encrypted <span class="fu">=</span> encF (onlyUpper <span class="st">&quot;THEQUICKBROWNFOX&quot;</span>)
        decrypted <span class="fu">=</span> decF encrypted
        encrypted&#39; <span class="fu">=</span> borrow (flipInv caesarCipher
                             <span class="ot">`rappend`</span> ouAsList) (<span class="fu">++</span> <span class="st">&quot;JUMPSOVERTHELAZYDOG&quot;</span>) encrypted
        decrypted&#39; <span class="fu">=</span> decF encrypted&#39;

    print encrypted
    <span class="co">-- OnlyUpper {getOU = &quot;XLIUYMGOFVSARJSB&quot;}</span>
    print decrypted
    <span class="co">-- OnlyUpper {getOU = &quot;THEQUICKBROWNFOX&quot;}</span>

    print encrypted&#39;
    <span class="co">-- OnlyUpper {getOU = &quot;XLIUYMGOFVSARJSBNYQTWSZIVXLIPEDCHSK&quot;}</span>
    print decrypted&#39;
    <span class="co">-- OnlyUpper {getOU = &quot;THEQUICKBROWNFOXJUMPSOVERTHELAZYDOG&quot;}</span></code></pre>
<h2 id="matrix-manipulation">Matrix manipulation</h2>
<p>Sometimes it’s convenient to write some code that manipulates matrices using <code>Invertible</code>.</p>
<p>Say there is a list of type <code>[Int]</code> in which <code>0</code> stands for an empty cell, and we want every non-zero element move to their leftmost possible position while preserving the order:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">compactLeft ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [<span class="dt">Int</span>]
compactLeft xs <span class="fu">=</span> nonZeros <span class="fu">++</span> replicate (((<span class="fu">-</span>) <span class="ot">`on`</span> length) xs nonZeros) <span class="dv">0</span>
    <span class="kw">where</span> nonZeros <span class="fu">=</span> filter (<span class="fu">/=</span> <span class="dv">0</span>) xs</code></pre>
<p>Now consider 2D matrices, we want to “gravitize” the matrix so that every non-zero element in it falls to {left,right,up,down}-most possible position while preserving the order.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Dir</span> <span class="fu">=</span> <span class="dt">DU</span> <span class="fu">|</span> <span class="dt">DD</span> <span class="fu">|</span> <span class="dt">DL</span> <span class="fu">|</span> <span class="dt">DR</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Enum</span>, <span class="dt">Show</span>, <span class="dt">Bounded</span>)
<span class="ot">gravitizeMat ::</span> <span class="dt">Dir</span> <span class="ot">-&gt;</span> [[<span class="dt">Int</span>]] <span class="ot">-&gt;</span> [[<span class="dt">Int</span>]]
gravitizeMat dir <span class="fu">=</span> borrow invertible (map compactLeft)
    <span class="kw">where</span> mirrorI <span class="fu">=</span> selfInv (map reverse)
        diagonalI <span class="fu">=</span> selfInv transpose
        invertible <span class="fu">=</span> <span class="kw">case</span> dir <span class="kw">of</span>
            <span class="dt">DL</span> <span class="ot">-&gt;</span> rempty
            <span class="dt">DR</span> <span class="ot">-&gt;</span> mirrorI
            <span class="dt">DU</span> <span class="ot">-&gt;</span> diagonalI
            <span class="dt">DD</span> <span class="ot">-&gt;</span> diagonalI <span class="ot">`rappend`</span> mirrorI</code></pre>
<p>here <code>Invertible</code> comes into play by the observation that <code>transpose</code> and <code>map reverse</code> are all invertible (moreover, they are inverse functions of themselves). So that we can tranform matrices and pretend the problem is only “gravitize to the left”.</p>
<p>Here is one example:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">print2DMat ::</span> (<span class="dt">Show</span> a) <span class="ot">=&gt;</span> [[a]] <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
print2DMat mat <span class="fu">=</span> <span class="kw">do</span>
    putStrLn <span class="st">&quot;Matrix: [&quot;</span>
    mapM_ print mat
    putStrLn <span class="st">&quot;]&quot;</span>

<span class="ot">exampleMatGravitize ::</span> <span class="dt">IO</span> ()
exampleMatGravitize <span class="fu">=</span> <span class="kw">do</span>
    <span class="kw">let</span> mat <span class="fu">=</span> [ [<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">2</span>,<span class="dv">0</span>]
              , [<span class="dv">0</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">0</span>]
              , [<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">5</span>]
              ]
    print2DMat mat

    <span class="kw">let</span> showExample d <span class="fu">=</span> <span class="kw">do</span>
            putStrLn <span class="fu">$</span> <span class="st">&quot;Direction: &quot;</span> <span class="fu">++</span> show d
            print2DMat <span class="fu">$</span> gravitizeMat d mat

    mapM_ showExample [minBound <span class="fu">..</span> maxBound]</code></pre>
<p>And the result will be:</p>
<pre><code>Matrix: [
[1,0,2,0]
[0,3,4,0]
[0,0,0,5]
]
Direction: DU
Matrix: [
[1,3,2,5]
[0,0,4,0]
[0,0,0,0]
]
Direction: DD
Matrix: [
[0,0,0,0]
[0,0,2,0]
[1,3,4,5]
]
Direction: DL
Matrix: [
[1,2,0,0]
[3,4,0,0]
[5,0,0,0]
]
Direction: DR
Matrix: [
[0,0,1,2]
[0,0,3,4]
[0,0,0,5]
]</code></pre>
<h1 id="complete-code">Complete code</h1>
<p>You can find my complete code from <a href="https://gist.github.com/Javran/9593215">gist</a>.</p>
</div>
]]></description>
    <pubDate>Mon, 17 Mar 2014 00:00:00 UT</pubDate>
    <guid>http://javran.github.io//posts/2014-03-17-capture-the-notion-of-invertible-functions.html</guid>
</item>
<item>
    <title>Exploring alternatives</title>
    <link>http://javran.github.io//posts/2014-03-08-exploring-alternatives.html</link>
    <description><![CDATA[<span class="blog-date">
    2014-03-08 - 
</span>
<span class="blog-tag">
    
        [ 
        <a href="/tags/type-tetris.html">type-tetris</a>, <a href="/tags/haskell.html">haskell</a>
        ]
    
</span>
<br />
<br />
<div class="blog-main">
<p>Today I'm going to play with <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Applicative.html#t:Alternative">Alternatives</a>.</p>
<p>(spoiler: I failed to understand what <code>some</code> and <code>many</code> do, and I guess that would be an essential part of getting <code>Alternative</code>. So there's not much thing useful in this article.)</p>
<p>Just as my other type-tetris attempts, this is not a tutorial about <code>Alternative</code>, I'll just provide some examples and intuitions gained throughout playing with it.</p>
<p>I happened to heard this typeclass by a quick scan on typeclassopedia, and there are only few functions related to it, which I think might not take much time to try them all. These are all motivations about this article.</p>
<p>As always, <strong>bold sentences</strong> stands for my intuitions.</p>
<h1 id="a-monoid-on-applicative-functors">“a monoid on applicative functors”</h1>
<p><code>Alternative</code> is a typeclass lied in <code>Control.Applicative</code>, most of the time, I import this package to use functions like <code>&lt;$&gt;</code>, <code>&lt;*&gt;</code> and data type <code>ZipList</code>, but no more. I happened to heard this typeclass by a quick scan on typeclassopedia, and there are only few functions related to it, which I think might not take much time to try them all. These are all motivations about this article.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Applicative</span></code></pre>
<p>First function in this class is called <code>empty</code>, so I guess <strong><code>Alternative</code> is some typeclass that allows containing nothing</strong>. This would explain why there are so many <code>Applicative</code>s but I can only see <code>[]</code> and <code>Maybe</code> being instances of this typeclass.</p>
<p>The document says <code>Alternative</code> is “a monoid on applicative functors”. So we can make an analogy between <code>(mempty, mappend)</code> from <code>Monoid</code> and <code>(empty, &lt;|&gt;)</code> from <code>Alternative</code>. Let's try it out:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">v1 ::</span> [<span class="dt">String</span>]
v1 <span class="fu">=</span> empty <span class="fu">&lt;|&gt;</span> empty <span class="fu">&lt;|&gt;</span> empty

<span class="ot">v2 ::</span> [<span class="dt">String</span>]
v2 <span class="fu">=</span> v1 <span class="fu">&lt;|&gt;</span> pure <span class="st">&quot;foo&quot;</span> <span class="fu">&lt;|&gt;</span> pure <span class="st">&quot;bar&quot;</span>

<span class="ot">v3 ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span>
v3 <span class="fu">=</span> pure <span class="dv">10</span> <span class="fu">&lt;|&gt;</span> pure <span class="dv">20</span>

<span class="ot">v4 ::</span> <span class="dt">Maybe</span> <span class="dt">Char</span>
v4 <span class="fu">=</span> empty <span class="fu">&lt;|&gt;</span> pure <span class="ch">&#39;A&#39;</span> <span class="fu">&lt;|&gt;</span> undefined

<span class="ot">v5 ::</span> <span class="dt">Maybe</span> ()
v5 <span class="fu">=</span> empty <span class="fu">&lt;|&gt;</span> empty <span class="fu">&lt;|&gt;</span> empty</code></pre>
<p>Let's bring up GHCi:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> v1
[]
λ<span class="fu">&gt;</span> v2
[<span class="st">&quot;foo&quot;</span>,<span class="st">&quot;bar&quot;</span>]
λ<span class="fu">&gt;</span> v3
<span class="dt">Just</span> <span class="dv">10</span>
λ<span class="fu">&gt;</span> v4
<span class="dt">Just</span> <span class="ch">&#39;A&#39;</span>
λ<span class="fu">&gt;</span> v5
<span class="dt">Nothing</span></code></pre>
<p><code>empty</code> works like what we expected, and <code>&lt;|&gt;</code> for lists seems straightforward. But when it comes to <code>Maybe</code>, we find that only the first non-<code>Nothing</code> one takes effect, if any.</p>
<h1 id="some-and-many"><code>some</code> and <code>many</code></h1>
<p>The type for <code>some</code> and <code>many</code> are identical, so just fill in some instances I come up with on the fly:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">v6 ::</span> [[<span class="dt">String</span>]]
v6 <span class="fu">=</span> some [<span class="st">&quot;not working&quot;</span>]

<span class="ot">v7 ::</span> [[<span class="dt">String</span>]]
v7 <span class="fu">=</span> some empty</code></pre>
<p>But when I try this out on GHCi, something is going wrong:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> v6
<span class="fu">^</span><span class="dt">CInterrupted</span><span class="fu">.</span>
λ<span class="fu">&gt;</span> v7
[]</code></pre>
<p>I gave <code>v6</code> some time to run but it didn't terminate, so I cancelled it by hand.</p>
<p>By looking at the document, I find some clue: <code>some</code> and <code>many</code> seem to look for some solutions to the following equations:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">some v <span class="fu">=</span> (<span class="fu">:</span>) <span class="fu">&lt;$&gt;</span> v <span class="fu">&lt;*&gt;</span> many v
many v <span class="fu">=</span> some v <span class="fu">&lt;|&gt;</span> pure []

<span class="co">-- rewrite to break the recursive relation will help?</span>
some v <span class="fu">=</span> (<span class="fu">:</span>) <span class="fu">&lt;$&gt;</span> v <span class="fu">&lt;*&gt;</span> (some v <span class="fu">&lt;|&gt;</span> pure [])
many v <span class="fu">=</span> ((<span class="fu">:</span>) (<span class="fu">$</span>) v <span class="fu">&lt;*&gt;</span> many v) <span class="fu">&lt;|&gt;</span> pure []</code></pre>
<p>I can't go any further from here, but doing some research, I find the following links that might help, but for now I just leave this two functions as mysteries. (Maybe it's just something like <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Function.html#v:fix"><code>fix</code></a>, interesting, but IMHO not useful ).</p>
<p>Related links:</p>
<ul>
<li><a href="http://stackoverflow.com/questions/18108608/what-are-alternatives-some-and-many-useful-for">What are Alternative’s “some” and “many” useful for?</a></li>
<li><a href="http://stackoverflow.com/questions/7671009/functions-from-alternative-type-class">Functions from ‘Alternative’ type class</a></li>
</ul>
<h1 id="optional"><code>optional</code></h1>
<p>For the rest of the story, I'll just type them directly into GHCi.</p>
<p>The last function about <code>Alternative</code> is <code>optional</code>, Let's check its type and feed it with some instances:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> <span class="fu">:</span>t optional
<span class="ot">optional ::</span> <span class="dt">Alternative</span> f <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> f (<span class="dt">Maybe</span> a)
λ<span class="fu">&gt;</span> optional <span class="dt">Nothing</span>
<span class="dt">Just</span> <span class="dt">Nothing</span>
λ<span class="fu">&gt;</span> optional <span class="fu">$</span> <span class="dt">Just</span> <span class="dv">1</span>
<span class="dt">Just</span> (<span class="dt">Just</span> <span class="dv">1</span>)
λ<span class="fu">&gt;</span> optional []
[<span class="dt">Nothing</span>]
λ<span class="fu">&gt;</span> optional [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]
[<span class="dt">Just</span> <span class="dv">1</span>,<span class="dt">Just</span> <span class="dv">2</span>,<span class="dt">Just</span> <span class="dv">3</span>,<span class="dt">Nothing</span>]</code></pre>
<p>Wait a minute, is <code>f a -&gt; f (Maybe a)</code> looks familiar to you? It looks like an unary function that has type <code>a -&gt; Maybe a</code> under some contexts. I think the simplest expression that matches this type would be <code>(Just &lt;$&gt;)</code>. Let's do the same thing on it.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> <span class="fu">:</span>t (<span class="dt">Just</span> <span class="fu">&lt;$&gt;</span>)
(<span class="dt">Just</span> <span class="fu">&lt;$&gt;</span>)<span class="ot"> ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> f (<span class="dt">Maybe</span> a)
λ<span class="fu">&gt;</span> (<span class="dt">Just</span> <span class="fu">&lt;$&gt;</span>) <span class="dt">Nothing</span>
<span class="dt">Nothing</span>
λ<span class="fu">&gt;</span> (<span class="dt">Just</span> <span class="fu">&lt;$&gt;</span>) <span class="dt">Just</span> <span class="dv">1</span>
<span class="dt">Just</span> (<span class="dt">Just</span> <span class="dv">1</span>)
λ<span class="fu">&gt;</span> (<span class="dt">Just</span> <span class="fu">&lt;$&gt;</span>) []
[]
λ<span class="fu">&gt;</span> (<span class="dt">Just</span> <span class="fu">&lt;$&gt;</span>) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]
[<span class="dt">Just</span> <span class="dv">1</span>,<span class="dt">Just</span> <span class="dv">2</span>,<span class="dt">Just</span> <span class="dv">3</span>]</code></pre>
<p>Comparing the output of <code>optional</code> and <code>(Just &lt;$&gt;)</code>, we find that <code>optional</code> will attach an <code>empty</code> to the end of this monoid. And that <code>empty</code> would be the “none” part from <code>optional</code>'s description: “One or none”. In addition, we've seen <code>&lt;|&gt;</code> is the binary operation for this monoid, so we can have a guess:</p>
<pre><code>optional v = (Just &lt;$&gt; v) &lt;|&gt; pure Nothing</code></pre>
<p>And this turns out to be the exact implementation.</p>
<h1 id="summary">Summary</h1>
<p>Not much is done in this post, I have to admit that type-tetris is not always the best way. As an afterthought, I didn't know how <code>Alternative</code> will be used so there was little hint that I can rely on when I was trying to figure out <code>many</code> and <code>some</code>.</p>
<p>Anyway, if happened to read all contents in this article, sorry for wasting your time and thanks for your patience.</p>
</div>
]]></description>
    <pubDate>Sat, 08 Mar 2014 00:00:00 UT</pubDate>
    <guid>http://javran.github.io//posts/2014-03-08-exploring-alternatives.html</guid>
</item>
<item>
    <title>Play with free monad</title>
    <link>http://javran.github.io//posts/2014-03-03-play-with-free-monad.html</link>
    <description><![CDATA[<span class="blog-date">
    2014-03-03 - 
</span>
<span class="blog-tag">
    
        [ 
        <a href="/tags/haskell.html">haskell</a>, <a href="/tags/type-tetris.html">type-tetris</a>, <a href="/tags/monad.html">monad</a>
        ]
    
</span>
<br />
<br />
<div class="blog-main">
<p>This article is not a free monad tutorial but some ideas about what free monad does from the prospective of a Haskell newbie.</p>
<p>Some days ago I came across <a href="http://hackage.haskell.org/package/free-4.4/docs/Control-Monad-Free.html">Free monad</a> by reading <a href="http://stackoverflow.com/questions/13352205/what-are-free-monads">this Stack Overflow question</a>.</p>
<p>I'm not sure about what exactly it is, although some intuitiions are gained through both reading the question and answers and playing with the library.</p>
<p>In the rest of this article, I'd like to share my experience about how I explore functions listed <a href="http://hackage.haskell.org/package/free-4.4/docs/Control-Monad-Free.html">here</a> and some intuitions gained from this process. These intuitions are marked as <strong>bold sentences</strong>.</p>
<h1 id="make-some-values-of-free-f-a">Make some values of <code>Free f a</code></h1>
<p>Import related library, you shoule make sure you've installed <a href="http://hackage.haskell.org/package/free-4.4">The free package</a>.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Monad</span>
<span class="kw">import </span><span class="dt">Control.Monad.Free</span></code></pre>
<p>This first thing is to make some values of type <code>Free f a</code>.</p>
<p>The easiest constructor is <code>Pure</code>. In order to fit the type <code>Free f a</code>, I choose to use a list as <code>f</code> and <code>Int</code> as <code>a</code>, because when I looked around the document, <code>f</code> is most likely to be an instance of <code>Functor</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">v1 ::</span> <span class="dt">Free</span> [] <span class="dt">Int</span>
v1 <span class="fu">=</span> <span class="dt">Pure</span> <span class="dv">10</span></code></pre>
<p>The next thing is about how to use the other constructor: <code>Free</code>. Its type signature is <code>Free :: f (Free f a) -&gt; Free f a</code>. It might not be that friendly, so I simplify it a little with <code>f = [], a = Int</code>. Then it becomes: <code>Free :: [Free [] Int] -&gt; Free [] Int</code>. Go back to the original signature, we can say that <code>Free</code> constructor takes some value of <code>Free f a</code> wrapped in another <code>f</code>, then produces <code>Free f a</code>. By using <code>Free</code>, <strong>the outside functor is somehow “ignored” from its type signature.</strong> Moreover, the part <code>f (Free f a)</code> suggests <strong>an exactly match of inside and outside functors.</strong></p>
<p>Now we've already have a <code>v1 :: Free [] Int</code>, and by using <code>Free</code>, we should end up with some values of type <code>Free [] a</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">v2 ::</span> <span class="dt">Free</span> [] <span class="dt">Int</span>
v2 <span class="fu">=</span> <span class="dt">Free</span> [v1]

<span class="ot">v3 ::</span> <span class="dt">Free</span> [] <span class="dt">Int</span>
v3 <span class="fu">=</span> <span class="dt">Free</span> [v2,v2,v1]</code></pre>
<p>Call GHCi to see the values:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> v1
<span class="dt">Pure</span> <span class="dv">10</span>
λ<span class="fu">&gt;</span> v2
<span class="dt">Free</span> [<span class="dt">Pure</span> <span class="dv">10</span>]
λ<span class="fu">&gt;</span> v3
<span class="dt">Free</span> [<span class="dt">Free</span> [<span class="dt">Pure</span> <span class="dv">10</span>],<span class="dt">Free</span> [<span class="dt">Pure</span> <span class="dv">10</span>],<span class="dt">Pure</span> <span class="dv">10</span>]</code></pre>
<h1 id="free-monad-is-a-monad">Free monad is a monad</h1>
<p>Of course free monad should be a monad, let's check the document to find some clues, in the instance list of <code>data Free f a</code>, we find this line:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">Free</span> f)</code></pre>
<p>This is enough for us to write some functions that can be used as the second argument of our old friend <code>&gt;&gt;=</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">foo1 ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Free</span> [] <span class="dt">Int</span>
foo1 x <span class="fu">=</span> <span class="dt">Free</span> [<span class="dt">Pure</span> <span class="fu">$</span> x<span class="fu">*</span><span class="dv">2</span>, <span class="dt">Pure</span> <span class="fu">$</span> x<span class="fu">+</span><span class="dv">20</span>]

<span class="ot">foo2 ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Free</span> [] <span class="dt">String</span>
foo2 x <span class="fu">=</span> <span class="dt">Free</span> [<span class="dt">Pure</span> <span class="fu">$</span> show x]

<span class="ot">v4 ::</span> <span class="dt">Free</span> [] <span class="dt">String</span>
v4 <span class="fu">=</span> v1 <span class="fu">&gt;&gt;=</span> foo1 <span class="fu">&gt;&gt;=</span> foo1 <span class="fu">&gt;&gt;=</span> foo1 <span class="fu">&gt;&gt;=</span> foo2</code></pre>
<p>And the GHCi output is:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> v4
<span class="dt">Free</span> [<span class="dt">Free</span> [<span class="dt">Free</span> [<span class="dt">Free</span> [<span class="dt">Pure</span> <span class="st">&quot;80&quot;</span>]
                 ,<span class="dt">Free</span> [<span class="dt">Pure</span> <span class="st">&quot;60&quot;</span>]]
           ,<span class="dt">Free</span> [<span class="dt">Free</span> [<span class="dt">Pure</span> <span class="st">&quot;80&quot;</span>]
                 ,<span class="dt">Free</span> [<span class="dt">Pure</span> <span class="st">&quot;60&quot;</span>]]]
     ,<span class="dt">Free</span> [<span class="dt">Free</span> [<span class="dt">Free</span> [<span class="dt">Pure</span> <span class="st">&quot;120&quot;</span>]
                 ,<span class="dt">Free</span> [<span class="dt">Pure</span> <span class="st">&quot;80&quot;</span>]]
           ,<span class="dt">Free</span> [<span class="dt">Free</span> [<span class="dt">Pure</span> <span class="st">&quot;100&quot;</span>]
                 ,<span class="dt">Free</span> [<span class="dt">Pure</span> <span class="st">&quot;70&quot;</span>]]]]
λ<span class="fu">&gt;</span> <span class="fu">:</span>{
<span class="fu">|</span> <span class="kw">let</span> foo1 <span class="fu">=</span> \x <span class="ot">-&gt;</span> [x<span class="fu">*</span><span class="dv">2</span>,x<span class="fu">+</span><span class="dv">20</span>]
<span class="fu">|</span>     foo2 <span class="fu">=</span> \x <span class="ot">-&gt;</span> [show x]
<span class="fu">|</span> <span class="kw">in</span> [<span class="dv">10</span>] <span class="fu">&gt;&gt;=</span> foo1 <span class="fu">&gt;&gt;=</span> foo1 <span class="fu">&gt;&gt;=</span> foo1 <span class="fu">&gt;&gt;=</span> foo2
<span class="fu">|</span> <span class="fu">:</span>}
[<span class="st">&quot;80&quot;</span>,<span class="st">&quot;60&quot;</span>,<span class="st">&quot;80&quot;</span>,<span class="st">&quot;60&quot;</span>,<span class="st">&quot;120&quot;</span>,<span class="st">&quot;80&quot;</span>,<span class="st">&quot;100&quot;</span>,<span class="st">&quot;70&quot;</span>]</code></pre>
<p>You can observe some similiarity between list monad and <code>Free []</code> monad. The intuition is <strong><code>Free []</code> monad seems to be a list monad but without <code>concat</code></strong>.</p>
<h1 id="retract-and-liftf"><code>retract</code> and <code>liftF</code></h1>
<p>The document says “<code>retract</code> is the left inverse of <code>lift</code> and <code>liftF</code>”. So we explore <code>liftF</code> first.</p>
<p><code>liftF</code> is “A version of lift that can be used with just a Functor for f.” I'm not sure about this, but we can get started from another clue: the type signature <code>liftF :: (Functor f, MonadFree f m) =&gt; f a -&gt; m a</code>.</p>
<p>We choose to stick to our simplification: <code>f = []</code>, so we need to find a suitable <code>m</code> that is an instance of <code>MonadFree [] m</code>.</p>
<p>And this one looks promising:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">MonadFree</span> f (<span class="dt">Free</span> f)</code></pre>
<p>So we can let <code>m = Free f</code>, which gives us the simplified type signature: <code>liftF :: [a] -&gt; Free [] a</code>. We can guess that <strong><code>liftF</code> lifts functors into free monads</strong>. To confirm about this, let's try to lift some functors:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">v7 ::</span> <span class="dt">Free</span> [] <span class="dt">Int</span>
v7 <span class="fu">=</span> liftF [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">8</span>,<span class="dv">8</span>,<span class="dv">8</span>]

<span class="ot">v8 ::</span> <span class="dt">Free</span> <span class="dt">Maybe</span> <span class="dt">String</span>
v8 <span class="fu">=</span> liftF <span class="fu">$</span> <span class="dt">Just</span> <span class="st">&quot;Foo&quot;</span>

<span class="ot">v9 ::</span> <span class="dt">Free</span> ((<span class="ot">-&gt;</span>) <span class="dt">Int</span>) <span class="dt">Int</span>
v9 <span class="fu">=</span> liftF (<span class="fu">+</span> <span class="dv">10</span>)</code></pre>
<p>I don't know if there is an easy way of observing <code>v9</code>, for now we just print <code>v7</code> and <code>v8</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> v7
<span class="dt">Free</span> [<span class="dt">Pure</span> <span class="dv">1</span>,<span class="dt">Pure</span> <span class="dv">2</span>,<span class="dt">Pure</span> <span class="dv">3</span>,<span class="dt">Pure</span> <span class="dv">4</span>,<span class="dt">Pure</span> <span class="dv">8</span>,<span class="dt">Pure</span> <span class="dv">8</span>,<span class="dt">Pure</span> <span class="dv">8</span>]
λ<span class="fu">&gt;</span> v8
<span class="dt">Free</span> (<span class="dt">Just</span> (<span class="dt">Pure</span> <span class="st">&quot;Foo&quot;</span>))</code></pre>
<p>Now we know we can lift any functors, so <strong>we can construct <code>Free f a</code> not only from <code>Pure</code> and <code>Free</code>, but also directly from functors.</strong></p>
<p>Now think about simplified type signature of <code>retract :: Free [] a -&gt; [a]</code>. <strong>it is the reverse of <code>liftF</code></strong>. Let's have a try in code:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">v10 ::</span> [<span class="dt">Int</span>]
v10 <span class="fu">=</span> retract v3

<span class="ot">v11 ::</span> <span class="dt">Maybe</span> <span class="dt">String</span>
v11 <span class="fu">=</span> retract v8

<span class="ot">v12 ::</span> [<span class="dt">String</span>]
v12 <span class="fu">=</span> retract v4

<span class="ot">v13 ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
v13 <span class="fu">=</span> retract v9</code></pre>
<p>Call GHCi for results, now we can observe <code>v9</code> indirectly by using function <code>v13</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> v10
[<span class="dv">10</span>,<span class="dv">10</span>,<span class="dv">10</span>]
λ<span class="fu">&gt;</span> v11
<span class="dt">Just</span> <span class="st">&quot;Foo&quot;</span>
λ<span class="fu">&gt;</span> v12
[<span class="st">&quot;80&quot;</span>,<span class="st">&quot;60&quot;</span>,<span class="st">&quot;80&quot;</span>,<span class="st">&quot;60&quot;</span>,<span class="st">&quot;120&quot;</span>,<span class="st">&quot;80&quot;</span>,<span class="st">&quot;100&quot;</span>,<span class="st">&quot;70&quot;</span>]
λ<span class="fu">&gt;</span> map v13 [<span class="dv">1</span><span class="fu">..</span><span class="dv">5</span>]
[<span class="dv">11</span>,<span class="dv">12</span>,<span class="dv">13</span>,<span class="dv">14</span>,<span class="dv">15</span>]</code></pre>
<p>Therefore <strong><code>retract</code> converts a free monad back to a functor</strong>. (I suspect this conclusion is somehow wrong, but for now I cannot tell what exactly is wrong.)</p>
<h1 id="iter-and-iterm"><code>iter</code> and <code>iterM</code></h1>
<p>Use the same trick we've played before, let <code>f = []</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">iter  ::</span>            ([  a] <span class="ot">-&gt;</span>    a) <span class="ot">-&gt;</span> <span class="dt">Free</span> [] a <span class="ot">-&gt;</span>   a
<span class="ot">iterM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> ([m a] <span class="ot">-&gt;</span> m  a) <span class="ot">-&gt;</span> <span class="dt">Free</span> [] a <span class="ot">-&gt;</span> m a</code></pre>
<p>I guess: <code>iter</code> converts a function who does some sorts of reduction on functors into another function who does the same thing but on free monads, and <code>iterM</code> is the monadic version of <code>iter</code>.</p>
<p>Let's have a try:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">v14 ::</span> <span class="dt">Int</span>
v14 <span class="fu">=</span> iter sum v3

<span class="ot">foo3 ::</span> [<span class="dt">IO</span> <span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Int</span>
foo3 ms <span class="fu">=</span> sum <span class="ot">`fmap`</span> sequence ms

<span class="ot">v15 ::</span> <span class="dt">IO</span> <span class="dt">Int</span>
v15 <span class="fu">=</span> iterM foo3 v7</code></pre>
<p>And look at GHCi:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> v14
<span class="dv">30</span>
λ<span class="fu">&gt;</span> v15
<span class="dv">34</span></code></pre>
<p>Maybe I can say that <strong><code>iter</code> and <code>iterM</code> lift reduction (for functors) into free monads</strong></p>
<h1 id="hoistfree"><code>hoistFree</code></h1>
<p>The type signature contains <code>forall</code>, but I think it's fine to just ignore that part. As we are just trying to get things work:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">hoistFree ::</span> <span class="dt">Functor</span> g <span class="ot">=&gt;</span> (f a <span class="ot">-&gt;</span> g a) <span class="ot">-&gt;</span> <span class="dt">Free</span> f b <span class="ot">-&gt;</span> <span class="dt">Free</span> g b</code></pre>
<p>I guess <strong><code>hoistFree</code> lift a conversion between functors into a conversion between free monads.</strong></p>
<p>I know list and <code>Maybe</code> are good friends:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Maybe</span>
<span class="ot">v16 ::</span> <span class="dt">Maybe</span> <span class="dt">String</span>
v16 <span class="fu">=</span> <span class="dt">Just</span> <span class="st">&quot;Foo&quot;</span>

<span class="ot">v17 ::</span> [<span class="dt">String</span>]
v17 <span class="fu">=</span> retract <span class="fu">$</span> hoistFree maybeToList <span class="fu">$</span> liftF v16</code></pre>
<p>Look at GHCi, we should observe the conversion from <code>Maybe String</code> to <code>[String]</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> v16
<span class="dt">Just</span> <span class="st">&quot;Foo&quot;</span>
λ<span class="fu">&gt;</span> v17
[<span class="st">&quot;Foo&quot;</span>]</code></pre>
<h1 id="pure-and-_free"><code>_Pure</code> and <code>_Free</code></h1>
<p>The type signatures of these two functions are really long, but don't be afraid, we still have some clue:</p>
<ul>
<li>If you look at <a href="http://hackage.haskell.org/package/profunctors-4.0.2/docs/Data-Profunctor.html#t:Choice"><code>Choice</code></a>, we find a simple instance: <code>Choice (-&gt;)</code></li>
<li>Pick up an applicative, I choose <code>m = []</code></li>
<li>Pick up a functor, I choose <code>f = Maybe</code></li>
<li>Ignore <code>forall</code> parts</li>
</ul>
<p>We end up with:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">_<span class="dt">Pure</span><span class="ot"> ::</span> (            a <span class="ot">-&gt;</span> [           a])
      <span class="ot">-&gt;</span> ( <span class="dt">Free</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> [<span class="dt">Free</span> <span class="dt">Maybe</span> a])
_<span class="dt">Free</span><span class="ot"> ::</span> ((<span class="dt">Maybe</span> (<span class="dt">Free</span> <span class="dt">Maybe</span> a)) <span class="ot">-&gt;</span> [<span class="dt">Maybe</span> (<span class="dt">Free</span> <span class="dt">Maybe</span> a)])
      <span class="ot">-&gt;</span> (       (<span class="dt">Free</span> <span class="dt">Maybe</span> a)  <span class="ot">-&gt;</span> [       <span class="dt">Free</span> <span class="dt">Maybe</span> a ])</code></pre>
<p>I really can't figure out what these functions do, but I can still use it by feeding it with values of suitable type.</p>
<p>So for the following part of this section, I provide codes and outputs without explanation.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">v18 ::</span> [<span class="dt">Free</span> <span class="dt">Maybe</span> <span class="dt">String</span>]
v18 <span class="fu">=</span> _<span class="dt">Pure</span> (<span class="fu">:</span>[]) (liftF <span class="fu">$</span> <span class="dt">Just</span> <span class="st">&quot;Haskell&quot;</span>)

<span class="ot">v19 ::</span> [<span class="dt">String</span>]
v19 <span class="fu">=</span> mapMaybe retract v18

<span class="co">-- f = Maybe</span>
<span class="co">-- p = (-&gt;)</span>
<span class="co">-- m = IO</span>
<span class="co">-- _Free :: (Maybe (Free Maybe a) -&gt; IO (Maybe (Free Maybe a)))</span>
<span class="co">--       -&gt; (       Free Maybe a  -&gt; IO        (Free Maybe a) )</span>
<span class="ot">v20 ::</span> <span class="dt">IO</span> (<span class="dt">Free</span> <span class="dt">Maybe</span> <span class="dt">Int</span>)
v20 <span class="fu">=</span> _<span class="dt">Free</span> return (liftF <span class="fu">$</span> <span class="dt">Just</span> <span class="dv">123456</span>)

<span class="ot">v21 ::</span> <span class="dt">IO</span> (<span class="dt">Maybe</span> <span class="dt">Int</span>)
v21 <span class="fu">=</span> retract <span class="ot">`fmap`</span> v20</code></pre>
<p>GHCi:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> v18
[<span class="dt">Free</span> (<span class="dt">Just</span> (<span class="dt">Pure</span> <span class="st">&quot;Haskell&quot;</span>))]
λ<span class="fu">&gt;</span> v19
[<span class="st">&quot;Haskell&quot;</span>]
λ<span class="fu">&gt;</span> v20
<span class="dt">Free</span> (<span class="dt">Just</span> (<span class="dt">Pure</span> <span class="dv">123456</span>))
λ<span class="fu">&gt;</span> v21
<span class="dt">Just</span> <span class="dv">123456</span></code></pre>
<h1 id="wrap-method"><code>wrap</code> method</h1>
<p>This is a method defined for <code>MonadFree</code>s, the document says <strong>“Add a layer.”</strong>, let's see it in action:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">v22 ::</span> <span class="dt">Free</span> <span class="dt">Maybe</span> <span class="dt">Int</span>
v22 <span class="fu">=</span> liftF <span class="fu">$</span> <span class="dt">Just</span> <span class="dv">10</span>

<span class="ot">v23 ::</span> <span class="dt">Free</span> <span class="dt">Maybe</span> <span class="dt">Int</span>
v23 <span class="fu">=</span> wrap (<span class="dt">Just</span> v22)

<span class="ot">v24 ::</span> <span class="dt">Free</span> <span class="dt">Maybe</span> <span class="dt">Int</span>
v24 <span class="fu">=</span> wrap (<span class="dt">Just</span> v23)</code></pre>
<p>GHCi:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> v22
<span class="dt">Free</span> (<span class="dt">Just</span> (<span class="dt">Pure</span> <span class="dv">10</span>))
λ<span class="fu">&gt;</span> v23
<span class="dt">Free</span> (<span class="dt">Just</span> (<span class="dt">Free</span> (<span class="dt">Just</span> (<span class="dt">Pure</span> <span class="dv">10</span>))))
λ<span class="fu">&gt;</span> v24
<span class="dt">Free</span> (<span class="dt">Just</span> (<span class="dt">Free</span> (<span class="dt">Just</span> (<span class="dt">Free</span> (<span class="dt">Just</span> (<span class="dt">Pure</span> <span class="dv">10</span>))))))</code></pre>
<h1 id="call-it-a-day">Call it a day</h1>
<p>This is the first time I attempted to do a “type-tetris”, although I still don't know what is free monad, but I do get some intuitions by using the functions provided. So let's call it a day.</p>
</div>
]]></description>
    <pubDate>Mon, 03 Mar 2014 00:00:00 UT</pubDate>
    <guid>http://javran.github.io//posts/2014-03-03-play-with-free-monad.html</guid>
</item>
<item>
    <title>Add tags to your Hakyll blog</title>
    <link>http://javran.github.io//posts/2014-03-01-add-tags-to-your-hakyll-blog.html</link>
    <description><![CDATA[<span class="blog-date">
    2014-03-01 - 
</span>
<span class="blog-tag">
    
        [ 
        <a href="/tags/hakyll.html">hakyll</a>, <a href="/tags/haskell.html">haskell</a>
        ]
    
</span>
<br />
<br />
<div class="blog-main">
<p>As promised, here is a simple tutorial about adding tag supports to your Hakyll blog.</p>
<p>Few things before we start:</p>
<ul>
<li><p>My Hakyll version used for this article is <code>4.4.3.2</code>, other versions shouldn't have much difference.</p></li>
<li><p>If this article looks too verbose, you can just look at <strong>bold sentences</strong>.</p></li>
<li><p>All the changes done below is contained <a href="/assets/add-tags-mondo.tar.bz2">in this archive</a>. You can download, run it and skip rest of this article.</p></li>
</ul>
<p>Let's start from scratch to keep it as simple as possible.</p>
<p>So we initialize a new Hakyll website.</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="co"># initialize the website under dir `mondo`</span>
$ <span class="kw">hakyll-init</span> mondo
$ <span class="kw">cd</span> mondo
<span class="co"># compile the code necessary,</span>
<span class="co"># in order to see the website.</span>
$ <span class="kw">ghc</span> site</code></pre>
<h1 id="write-tags-in-posts">Write tags in posts</h1>
<p>To create tags, we should first learn how to add tags to our posts, this step is easy, look at <a href="https://hackage.haskell.org/package/hakyll-4.4.3.2/docs/Hakyll-Web-Tags.html">the document for tags</a>, it should begin with <code>tags:</code> followed with a comma-separated list.</p>
<p>Now, let's modify posts from <code>mondo/posts</code>:</p>
<p><code>mondo/posts/2012-08-12-spqr.markdown</code>:</p>
<pre><code>---
title: S.P.Q.R.
tags: foo, bar1, bar2
---</code></pre>
<p><code>mondo/posts/2012-10-07-rosa-rosa-rosam.markdown</code>:</p>
<pre><code>---
title: Rosa Rosa Rosam
author: Ovidius
tags: bar1
---</code></pre>
<p><code>mondo/post/2012-11-28-carpe-diem.markdown</code>:</p>
<pre><code>---
title: Carpe Diem
tags: bar2, foo
---</code></pre>
<p><code>mondo/posts/2012-12-07-tu-quoque.markdown</code>:</p>
<pre><code>---
title: Tu Quoque
author: Julius
tags: bar1, bar2
---</code></pre>
<h1 id="fetch-metadata-from-our-posts">Fetch metadata from our posts</h1>
<p>Now we've assigned tags to the posts, next thing is to make them accessible from Haskell codes.</p>
<p>Before we go through all the posts and generate pages, we should build tags using <a href="https://hackage.haskell.org/package/hakyll-4.4.3.2/docs/Hakyll-Web-Tags.html#v:buildTags"><code>buildTags</code></a>.</p>
<p>Unforuntately this function is not well-documented, a short explanation would be : <code>buildTags pattern makeId</code> finds all tags from posts captured by <code>pattern</code>, converts each tag to a corresponding <a href="https://hackage.haskell.org/package/hakyll-4.4.3.2/docs/Hakyll-Core-Identifier.html#t:Identifier"><code>Identifier</code></a> by using <code>makeId</code> and returns a value of type <a href="https://hackage.haskell.org/package/hakyll-4.4.3.2/docs/Hakyll-Web-Tags.html#t:Tags"><code>Tags</code></a>.</p>
<p>From <code>site.hs</code> file, <strong>find these lines</strong>:</p>
<table class="sourceCode haskell numberLines" startFrom="24"><tr class="sourceCode"><td class="lineNumbers"><pre>24
25
26
27
28
29
</pre></td><td class="sourceCode"><pre><code class="sourceCode haskell">    match <span class="st">&quot;posts/*&quot;</span> <span class="fu">$</span> <span class="kw">do</span>
        route <span class="fu">$</span> setExtension <span class="st">&quot;html&quot;</span>
        compile <span class="fu">$</span> pandocCompiler
            <span class="fu">&gt;&gt;=</span> loadAndApplyTemplate <span class="st">&quot;templates/post.html&quot;</span>    postCtx
            <span class="fu">&gt;&gt;=</span> loadAndApplyTemplate <span class="st">&quot;templates/default.html&quot;</span> postCtx
            <span class="fu">&gt;&gt;=</span> relativizeUrls</code></pre></td></tr></table>
<p>Insert the following code in front of it:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- build up tags</span>
tags <span class="ot">&lt;-</span> buildTags <span class="st">&quot;posts/*&quot;</span> (fromCapture <span class="st">&quot;tags/*.html&quot;</span>)</code></pre>
<p>The code region above says: find all tags by searching the metadata of posts found by pattern <code>posts/*</code>, and the corresponding path for each tag will be of form <code>tags/*.html</code>. (e.g. for tag <code>foo</code>, you can generate a list of all posts that contains tag <code>foo</code> under URL: <code>{your-website}/tags/foo.html</code>.)</p>
<p>After tags are generated, we need to tell the post generator to include the corresponding tag informations for each tag, this is done by modifying <code>postCtx</code>. (for now you don't have to understand the detail of <code>postCtx</code> if you just want to setup up tags.)</p>
<p>Put the following definition somewhere in your <code>site.hs</code>, I choose to put it right after the definition of <code>postCtx</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">postCtxWithTags ::</span> <span class="dt">Tags</span> <span class="ot">-&gt;</span> <span class="dt">Context</span> <span class="dt">String</span>
postCtxWithTags tags <span class="fu">=</span> tagsField <span class="st">&quot;tags&quot;</span> tags <span class="ot">`mappend`</span> postCtx</code></pre>
<p>And then change all the occurrence of <code>postCtx</code> inside the code region mentioned above.</p>
<p>After this change, <strong>the code region should look like</strong>:</p>
<table class="sourceCode haskell numberLines" startFrom="24"><tr class="sourceCode"><td class="lineNumbers"><pre>24
25
26
27
28
29
30
31
32
</pre></td><td class="sourceCode"><pre><code class="sourceCode haskell">    <span class="co">-- build up tags</span>
    tags <span class="ot">&lt;-</span> buildTags <span class="st">&quot;posts/*&quot;</span> (fromCapture <span class="st">&quot;tags/*.html&quot;</span>)

    match <span class="st">&quot;posts/*&quot;</span> <span class="fu">$</span> <span class="kw">do</span>
        route <span class="fu">$</span> setExtension <span class="st">&quot;html&quot;</span>
        compile <span class="fu">$</span> pandocCompiler
            <span class="fu">&gt;&gt;=</span> loadAndApplyTemplate <span class="st">&quot;templates/post.html&quot;</span>    (postCtxWithTags tags)
            <span class="fu">&gt;&gt;=</span> loadAndApplyTemplate <span class="st">&quot;templates/default.html&quot;</span> (postCtxWithTags tags)
            <span class="fu">&gt;&gt;=</span> relativizeUrls</code></pre></td></tr></table>
<h1 id="template-pages">Template pages</h1>
<p>Now we need to add some changes to our templates, to make tags visible.</p>
<p>I think the following changes in this section are self-explanatory even if you knows nothing about how template works. So Let's go though them quickly.</p>
<p><strong>Modify your <code>templates/post.html</code> to make it looks like</strong>:</p>
<pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div</span><span class="ot"> class=</span><span class="st">&quot;info&quot;</span><span class="kw">&gt;</span>
    Posted on $date$
    $if(author)$
        by $author$
    $endif$
<span class="kw">&lt;/div&gt;</span>
<span class="kw">&lt;div</span><span class="ot"> class=</span><span class="st">&quot;info&quot;</span><span class="kw">&gt;</span>
    $if(tags)$
    Tags: $tags$
    $endif$
<span class="kw">&lt;/div&gt;</span>

$body$</code></pre>
<p>Now we create the template for tag pages which lists all posts containing the corresponding tags. Since we already have a template for listing posts(<code>template/post-list.html</code>), we can simply reuse it.</p>
<p>This is done by <strong>creating a new file: <code>templates/tag.html</code>, with the following content</strong>:</p>
<pre class="sourceCode html"><code class="sourceCode html">$partial(&quot;templates/post-list.html&quot;)$</code></pre>
<h1 id="generate-tag-pages">Generate tag pages</h1>
<p>This is the final step, we generate tag pages based on the templates we've written.</p>
<p><strong>Put the following code somewhere after we build up <code>tags</code>,</strong> I choose to place it right after the line <code>tags &lt;- buildTags</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">    tagsRules tags <span class="fu">$</span> \tag pattern <span class="ot">-&gt;</span> <span class="kw">do</span>
        <span class="kw">let</span> title <span class="fu">=</span> <span class="st">&quot;Posts tagged \&quot;&quot;</span> <span class="fu">++</span> tag <span class="fu">++</span> <span class="st">&quot;\&quot;&quot;</span>
        route idRoute
        compile <span class="fu">$</span> <span class="kw">do</span>
            posts <span class="ot">&lt;-</span> recentFirst <span class="fu">=&lt;&lt;</span> loadAll pattern
            <span class="kw">let</span> ctx <span class="fu">=</span> constField <span class="st">&quot;title&quot;</span> title
                      <span class="ot">`mappend`</span> listField <span class="st">&quot;posts&quot;</span> postCtx (return posts)
                      <span class="ot">`mappend`</span> defaultContext

            makeItem <span class="st">&quot;&quot;</span>
                <span class="fu">&gt;&gt;=</span> loadAndApplyTemplate <span class="st">&quot;templates/tag.html&quot;</span> ctx
                <span class="fu">&gt;&gt;=</span> loadAndApplyTemplate <span class="st">&quot;templates/default.html&quot;</span> ctx
                <span class="fu">&gt;&gt;=</span> relativizeUrls</code></pre>
<p>Now it's done, recompile <code>site.hs</code> and have fun!</p>
<h1 id="result">Result</h1>
<p>Few screenshots after we adding tags:</p>
<div class="figure">
<img src="/assets/add-tags-result-1.jpg" alt="Inside posts" /><p class="caption">Inside posts</p>
</div>
<div class="figure">
<img src="/assets/add-tags-result-2.jpg" alt="Tag page" /><p class="caption">Tag page</p>
</div>
<p>I also provide the final version of <code>mondo</code> directory <a href="/assets/add-tags-mondo.tar.bz2">here</a>.</p>
<h1 id="acknowledgement">Acknowledgement</h1>
<p>Thanks for the big help from <a href="https://github.com/eakron/variadic.me">the source code</a> of <a href="https://variadic.me/">variadic.me</a>.</p>
</div>
]]></description>
    <pubDate>Sat, 01 Mar 2014 00:00:00 UT</pubDate>
    <guid>http://javran.github.io//posts/2014-03-01-add-tags-to-your-hakyll-blog.html</guid>
</item>
<item>
    <title>Type tetris and typeclassopedia</title>
    <link>http://javran.github.io//posts/2014-02-28-type-tetris-and-typeclassopedia.html</link>
    <description><![CDATA[<span class="blog-date">
    2014-02-28 - 
</span>
<span class="blog-tag">
    
        [ 
        <a href="/tags/type-tetris.html">type-tetris</a>, <a href="/tags/typeclassopedia.html">typeclassopedia</a>, <a href="/tags/haskell.html">haskell</a>
        ]
    
</span>
<br />
<br />
<div class="blog-main">
<h1 id="lets-make-our-way-to-haskell">Let's make our way to Haskell</h1>
<p>I've become one interested in Haskell for quite a while, but I think the only book I've read about Haskell is <a href="http://learnyouahaskell.com/">LYAH</a>. For more advanced topics, I just read articles from both <a href="http://www.haskell.org/haskellwiki/Introduction">haskell.org</a> and <a href="https://en.wikibooks.org/wiki/Haskell">Haskell wikibooks</a>. But as I dig deeper into more genius concepts and ideas in Haskell, things become complicated and mind-blowing and the biggest obstacle for me is that I have little understanding about types, which is ubiquitous in the world of Haskell.</p>
<p>Today I'd like to share two interesting stuffs which, IMHO, would help you to learn more about Haskell: “type-tetris” and “typeclassopedia”.</p>
<h1 id="type-tetris">Type-tetris</h1>
<p>Just few days ago I came across <a href="http://www.reddit.com/r/haskell/comments/1yvfmc/programming_with_types_not_tutorials/">this link</a>, which eventually gave me an article: <a href="https://www.fpcomplete.com/user/chowells79/types-not-tutorials">Programming With Types, Not Tutorials</a>. In this article, the author shows us how to make Haskell code work as expected while have least understanding about underlying complex mathematical concepts. After reading this article, I realized that it might not be our responsibility to get full knowledge about “how does it work”, but we should really focus on “how to make it work”.</p>
<p>I think this is the beauty of Haskell: thanks to its strong and statical type system, when some Haskell type-checks, we can almost be confident to say that it should work as expected. On the other hand, we should also be as lazy as Haskell in some sense, since no one puts a gun in your head and say “you should figure out how exactly it works”, we can just leave all the underlying math and proofs unexplored until we need it.</p>
<p>Here I collect some comments on the previous Reddit link:</p>
<blockquote>
<p>drb226: This is what I like to call “type tetris.” It's fun, and you end up with correct programs without even having to understand what you just assembled. …</p>
</blockquote>
<blockquote>
<p>camccann: I got through most of my physics courses by relying on dimensional analysis and hoping that if the units were right, so was the equation. It worked surprisingly often.</p>
</blockquote>
<p>If I understand correctly, as I've previous said in my twitter, the type itself is capable of carrying constraints with it, So types have already embeded with properties and proofs, and we can use types happily without knowing too much about what is going on.</p>
<p>I like the idea of “type tetris”: let's just get started by using functions without “eagerly” understanding it. And see if we can grab some ideas when we are playing with it. By doing this, we focus more on “how to make it work” rather than “how it works”.</p>
<h1 id="typeclassopedia">Typeclassopedia</h1>
<p>In addition, I happen to know that there is a totally different way of learning Haskell: <a href="http://www.haskell.org/haskellwiki/Typeclassopedia">Typeclassopedia</a>. This is an article recommended by many people in Stack Overflow, which covers some basic understanding of how types are related to each other. By reading this article, we are trying to answer the question of “how it works” but are less interested in “how to make it work”.</p>
<h1 id="summary">Summary</h1>
<p>So here I've shown you two (potential) ways of learning Haskell and fortunately you can take both ways and hope the experience gained from both sides would help each other and bring you to a higher level understanding of Haskell.</p>
<p>For myself, as a starting point of my type-tetris, I explored a little about <a href="http://stackoverflow.com/questions/13352205/what-are-free-monads">Free Monad</a> few days about, hopefully I'll write up another article in weekends to share the code and my thoughts. For typeclassopedia, I haven't read much. A potential plan would be to play “type-tetris” with stuffs mentioned in the typeclassopedia first, and then read the corresponding chapter to shed some light.</p>
</div>
]]></description>
    <pubDate>Fri, 28 Feb 2014 00:00:00 UT</pubDate>
    <guid>http://javran.github.io//posts/2014-02-28-type-tetris-and-typeclassopedia.html</guid>
</item>
<item>
    <title>Yet another beginning</title>
    <link>http://javran.github.io//posts/2014-02-25-yet-another-beginning.html</link>
    <description><![CDATA[<span class="blog-date">
    2014-02-25 - 
</span>
<span class="blog-tag">
    
        [ 
        <a href="/tags/thought.html">thought</a>
        ]
    
</span>
<br />
<br />
<div class="blog-main">
<p>I think it's not surprising if I say I've made my decision(again) to restart writing blogs and keeping track of my personal pages.</p>
<p>This time I switch from <a href="https://github.com/jekyll/jekyll">jekyll</a> to <a href="http://jaspervdj.be/hakyll/">hakyll</a>. It doesn't mean jekyll is not a good choice, this is just because I feel like becoming a Haskell fans and of course I'd like to get more involved with Haskell stuffs. Hakyll, in this sense, fits me better.</p>
<p>These days I did some sort of work to apply some themes to make my hakyll site looks better. And the final choice I come up with is to use <a href="http://getbootstrap.com/">bootstrap</a> for a basic framework, and use <a href="http://www.lavishbootstrap.com/">lavish</a> to make my own theme.</p>
<p>After I felt good about how the website looks, I moved my past posts from jekyll to hakyll, which is actually quite easy and just quites few lines of changes. It's great that Hakyll uses <a href="http://johnmacfarlane.net/pandoc/">pandoc</a> , which is another fascinating project written in Haskell, to deal with HTML file generating. Pandoc just makes the data migration smooth and in addition makes more source file formats available (I think this is a big win comparing with jekyll).</p>
<p>And then some other stuffs like tags were implemented last weekends, but unfortunately when I start searching for tutorials about how can I enable tags in Hakyll, there is not much documents that I can refer to. Hakyll does have some documents lying in Hackage, but I believe that these documents are incomplete and insufficient to work out all the details.</p>
<p>The most helpful thing provided by Hakyll's website finally turns out to be <a href="http://jaspervdj.be/hakyll/examples.html">these example websites with source codes</a>. I figured out how to add and organize tags by looking at some source codes from these websites.</p>
<p>So the next thing I can think about, is to write a tutorial about how I add tags to my own blog. I believe this will familiarize myself with Hakyll, and make more features available to Hakyll newbies like me.</p>
<p>However, you should never expect that tutorial coming out quickly, as things are getting me really busy these days.</p>
</div>
]]></description>
    <pubDate>Tue, 25 Feb 2014 00:00:00 UT</pubDate>
    <guid>http://javran.github.io//posts/2014-02-25-yet-another-beginning.html</guid>
</item>

    </channel> 
</rss>
