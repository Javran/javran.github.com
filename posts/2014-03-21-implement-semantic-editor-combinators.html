<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content>
    <meta name="author" content>
    <link rel="shortcut icon" href="assets/ico/favicon.ico">

    <title>Javrania - Implement semantic editor combinators</title>

    <!-- Bootstrap core CSS -->
    <link href="../css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom styles for this template -->

    <link href="../css/lavish-bootstrap.css" rel="stylesheet">
    <link href="../css/blog.css" rel="stylesheet">
    <link href="../css/no-transition.css" rel="stylesheet">
    <link href="../css/default.css" rel="stylesheet">
    <link href="../css/hk-pyg.css" rel="stylesheet">
    <!-- Just for debugging purposes. Don't actually copy this line! -->
    <!--[if lt IE 9]><script src="../../assets/js/ie8-responsive-file-warning.js"></script><![endif]-->
    
    <script type="text/javascript">var switchTo5x=true;</script>
    <script type="text/javascript" src="http://w.sharethis.com/button/buttons.js"></script>
    <script type="text/javascript">stLight.options(
      { publisher: "eff44467-2bf3-4542-8683-950d62a7d47d"
      , doNotHash: false
      , doNotCopy: false
      , onhover: false
      , hashAddressBar: false});
    </script>
  </head>

  <body>

    <div class="navbar navbar-inverse navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="../">Javrania</a>
        </div>
        <div class="collapse navbar-collapse no-transition">
          <ul class="nav navbar-nav">
            <!-- <li class="active"><a href="#">Home</a></li> -->
            <li><a href="../">Home</a></li>
            <li><a href="../about.html">About</a></li>
            <li><a href="../archive.html">Archive</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </div>
    <div class="container">

      <div id="content">
        <div class="page-header">
          <h1>Implement semantic editor combinators</h1>
        </div>
        <span class="blog-date">
    2014-03-21 - 
</span>
<span class="blog-tag">
    
        [ 
        <a href="../tags/haskell.html">haskell</a>, <a href="../tags/lens.html">lens</a>
        ]
    
</span>
<br />
<br />
<div class="blog-main">
<h1 id="intro">Intro</h1>
<p>In <a href="http://conal.net/blog/posts/semantic-editor-combinators">Semantic editor combinators</a>, Conal has shown us a simple but powerful trick of walking into a portion of data and then modifying it.</p>
<p>When I saw this simple idea, I persuaded myself to take it for grainted and tried it out. Even though it works well in practice, I'd like to explain to myself what's happening, which is the motivation of this article.</p>
<p>I'll implement <code>first</code>, <code>second</code>, <code>result</code> and other combinators step by step, and come up with the way to walking into user defined <code>data</code>, which is easy but not presented in Conal's post.</p>
<h1 id="editing-a-pair">Editing a pair</h1>
<p>First we need to think about what the type would be for <code>first</code> and <code>second</code>:</p>
<ul>
<li><p>When we reach for the portion of data, we need to modify it, so we need a function <code>f :: a -&gt; b</code></p></li>
<li><p>We also need a pair of data <code>(x,y) :: (c,d)</code> for this editor's input.</p></li>
<li><p>For <code>first</code>, we want type <code>c = a</code>, and the return value should be of type <code>(b,d)</code></p></li>
<li><p>For <code>second</code>, we want type <code>d = a</code>, and the return value should be of type <code>(c,b)</code></p></li>
</ul>
<p>Put them together, we end up with type signature for <code>first</code> and <code>second</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">first  ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a,d) <span class="ot">-&gt;</span> (b,d)
<span class="ot">second ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (c,a) <span class="ot">-&gt;</span> (c,b)</code></pre>
<p>Introduce <code>f</code> and <code>(x,y)</code> for two arguments, and the implementation is straightforward:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">first  ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a,d) <span class="ot">-&gt;</span> (b,d)
first  f (x,y) <span class="fu">=</span> (f x, y)

<span class="ot">second ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (c,a) <span class="ot">-&gt;</span> (c,b)
second f (x,y) <span class="fu">=</span> (x, f y)</code></pre>
<p>Let's bring up GHCi for some tests:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> first (const <span class="dv">1</span>) (<span class="st">&quot;foo&quot;</span>,<span class="st">&quot;bar&quot;</span>) <span class="co">-- (1, &quot;bar&quot;)</span>
(<span class="dv">1</span>,<span class="st">&quot;bar&quot;</span>)
λ<span class="fu">&gt;</span> second (<span class="fu">*</span> <span class="dv">20</span>) (<span class="dt">Just</span> <span class="dv">1</span>, <span class="dv">1</span>) <span class="co">-- (Just 1, 20)</span>
(<span class="dt">Just</span> <span class="dv">1</span>,<span class="dv">20</span>)</code></pre>
<h1 id="editing-a-function">Editing a function</h1>
<p>There's two way of editing a function: we can either modify the return value (the <code>result</code> combinator), or modify the argument (the <code>argument</code> combinator).</p>
<h2 id="the-result-combinator">the <code>result</code> combinator</h2>
<p>Let's think about the type of <code>result</code>:</p>
<ul>
<li>How to modify a function is given by <code>f :: a -&gt; b</code></li>
<li>The function we want to edit is <code>g :: c -&gt; d</code></li>
<li>We want to modify on the return value of <code>g</code>, therefore <code>d = a</code>.</li>
<li>Then the resulting function should be of type <code>c -&gt; b</code></li>
</ul>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">result ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (c <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (c <span class="ot">-&gt;</span> b)</code></pre>
<p>We know that <code>-&gt;</code> is right-associative, (e.g. <code>p -&gt; q -&gt; r</code> and <code>p -&gt; (q -&gt; r)</code> are equivalent) so we can also think <code>result</code> as a function that accepts 3 arguments, and its type signature becomes:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">result ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (c <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> b</code></pre>
<p>Introduce <code>f</code> <code>g</code> <code>x</code> for these 3 arguments, and we want a value of type <code>b</code>.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">result ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (c <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> b
result f g x <span class="fu">=</span> undefined</code></pre>
<ul>
<li>To produce a value of <code>b</code>, we might need <code>f :: a -&gt; b</code>.</li>
<li>To produce a value of <code>a</code>, we might need <code>g :: c -&gt; a</code>.</li>
<li><code>x</code> is of type <code>c</code></li>
</ul>
<p>Chaining these facts together, we yield the implementation of <code>result</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">result ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (c <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> b
result f g x <span class="fu">=</span> f (g x)</code></pre>
<p>This is exactly the definition of <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/src/GHC-Base.html#."><code>(.)</code></a>, function composition.</p>
<p>So we end up with:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">result ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (c <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> b
result <span class="fu">=</span> (<span class="fu">.</span>)</code></pre>
<p>Test it:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> result (<span class="fu">+</span><span class="dv">2</span>) (<span class="fu">*</span><span class="dv">5</span>) <span class="dv">1</span> <span class="co">-- 1 * 5 + 2 = 7</span>
<span class="dv">7</span></code></pre>
<h2 id="the-argument-combinator">the <code>argument</code> combinator</h2>
<p>Use the same approach, let’s implement <code>argument</code> combinator:</p>
<ul>
<li><code>f :: a -&gt; b</code> to modify the argument</li>
<li><code>g :: c -&gt; d</code> the function to be modified</li>
<li><code>b = c</code> so that the type of <code>f</code> and <code>g</code> matches.</li>
<li>the resulting function should be of type <code>a -&gt; d</code>.</li>
</ul>
<p>Write down the type signature, introduce <code>f</code>, <code>g</code>, <code>x</code>, the goal is to produce a value of type <code>d</code></p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">argument ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> d
argument f g x <span class="fu">=</span> undefined</code></pre>
<ul>
<li>To produce a value of <code>d</code>, we might need <code>g :: b -&gt; d</code>.</li>
<li>To produce a value of <code>b</code>, we might need <code>f :: a -&gt; b</code>.</li>
<li><code>x</code> is of type <code>a</code></li>
</ul>
<p>Therefore the definition of <code>argument</code> is:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">argument ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> d
argument f g x <span class="fu">=</span> g (f x)</code></pre>
<p>To simplify this, we do some transformations:</p>
<pre><code>  g (f x)
&gt; (g . f) x           -- definition of (.)
&gt; (.) g f x           -- infix operator
&gt; ((.) g f) x         -- property of curried function
&gt; ((flip (.)) f g) x  -- flip
&gt; flip (.) f g x      -- rule of function application</code></pre>
<p>Finally:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">argument ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> d
<span class="co">-- point-free style of: argument f g x = flip (.) f g x</span>
argument <span class="fu">=</span> flip (<span class="fu">.</span>)</code></pre>
<p>Test it:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> argument show (\x <span class="ot">-&gt;</span> x <span class="fu">++</span> <span class="st">&quot;!&quot;</span>) <span class="dv">2048</span> <span class="co">-- 2048!</span>
<span class="st">&quot;2048!&quot;</span></code></pre>
<h1 id="walking-into-data">Walking into data</h1>
<p>For now we have <code>first</code> and <code>second</code> to work with pairs, and <code>argument</code> and <code>result</code> with functions, but sometimes we want to go deeper inside data, say:</p>
<ul>
<li>Goal 1: we want <code>2</code> to be <code>5</code> in <code>(7,(2,1))</code></li>
<li>Goal 2: we want <code>a+b</code> to be <code>(a+b)*2</code> in <code>\a -&gt; (a+1 ,\b -&gt; (a+b, 1))</code></li>
</ul>
<p>Here I try to give some explanation of how to do this.</p>
<h2 id="goal-1">Goal 1</h2>
<p>To modify <code>d</code> in <code>(a,(c,d))</code>, that means we need to first focus on <code>(c,d)</code>, this can be achieved by <code>second</code>, let’s pass a const function <code>const &quot;Focus&quot;</code> to <code>second</code>, so we know we are focusing on which portion of the data:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> <span class="kw">let</span> d1 <span class="fu">=</span> (<span class="dv">7</span>,(<span class="dv">2</span>,<span class="dv">1</span>))
λ<span class="fu">&gt;</span> <span class="kw">let</span> toFocus <span class="fu">=</span> const <span class="st">&quot;Focus&quot;</span>
λ<span class="fu">&gt;</span> second toFocus d1
(<span class="dv">7</span>,<span class="st">&quot;Focus&quot;</span>)</code></pre>
<p>We now know that missing <code>(2,1)</code> is passed to <code>toFocus</code>, we can use a lambda expression to capture it:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> second (\x <span class="ot">-&gt;</span> x) d1
(<span class="dv">7</span>,(<span class="dv">2</span>,<span class="dv">1</span>))</code></pre>
<p>Let's do something more interesting:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> second (\x <span class="ot">-&gt;</span> <span class="kw">let</span> (a,b) <span class="fu">=</span> x <span class="kw">in</span> (a<span class="fu">+</span><span class="dv">1</span>,b,b)) d1
(<span class="dv">7</span>,(<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">1</span>))</code></pre>
<p>The observation is: inside the body of lambda expression <code>\x -&gt; ...</code>, we can do something to <code>(2,1)</code>. That means we can apply semantic editor combinators on it!</p>
<p>Now assume we are dealing with <code>(2,1)</code>, to reach the goal, we apply <code>const 5</code> to its <code>fst</code> part:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> first (const <span class="dv">5</span>) (<span class="dv">2</span>,<span class="dv">1</span>)
(<span class="dv">5</span>,<span class="dv">1</span>)</code></pre>
<p>Now replace the body of <code>\x -&gt; ...</code> with what we want:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> second (\x <span class="ot">-&gt;</span> first (const <span class="dv">5</span>) x) d1
(<span class="dv">7</span>,(<span class="dv">5</span>,<span class="dv">1</span>))</code></pre>
<p>Done!</p>
<h2 id="some-intuition">Some intuition</h2>
<p>Let's not hurry to Goal 2, I’ll show you some transformations:</p>
<pre><code>  second (\x -&gt; first (const 5) x) d1
&gt; second (first (const 5)) d1         -- eta reduction / point-free
&gt; (second (first (const 5))) d1       -- rule of function application
&gt; ((second . first) (const 5)) d1     -- definition of (.)</code></pre>
<p>I don’t simplify it to <code>(second . first) (const 5) d1</code> on purpose, and I’m going to show you why.</p>
<p>It might not be straightforward at first glance, since function composition is usually “right to left”, that is, <code>(g . f)</code> means “first apply <code>f</code>, on its result, apply <code>g</code>. But here, <code>second . first</code> can be read as”walk to the <code>snd</code> part, and then <code>fst</code> part of it“.</p>
<p>My explanation is: <strong>the function does compose from right to left, but what’s “carrying” with the composition is not the data</strong>.</p>
<p>The observation is: no matter how many functions are composed together, the resulting function just takes one argument:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> <span class="kw">let</span> u <span class="fu">=</span> undefined
λ<span class="fu">&gt;</span> <span class="fu">:</span>t u <span class="fu">.</span> u
u <span class="fu">.</span><span class="ot"> u ::</span> a <span class="ot">-&gt;</span> c
λ<span class="fu">&gt;</span> <span class="fu">:</span>t u <span class="fu">.</span> u <span class="fu">.</span> u <span class="fu">.</span> u
u <span class="fu">.</span> u <span class="fu">.</span> u <span class="fu">.</span><span class="ot"> u ::</span> a <span class="ot">-&gt;</span> c
λ<span class="fu">&gt;</span> <span class="fu">:</span>t u <span class="fu">.</span> u <span class="fu">.</span> u <span class="fu">.</span> u <span class="fu">.</span> u
u <span class="fu">.</span> u <span class="fu">.</span> u <span class="fu">.</span> u <span class="fu">.</span><span class="ot"> u ::</span> a <span class="ot">-&gt;</span> c</code></pre>
<p>So what is the argument taken by this resulting function? In our Goal 1, it is <code>const 5</code>, the “how we modify it” part. So despite that <code>(second . first) (const 5) d1</code> is simple, to understand it, what you really need would be: <code>((second . first) (const 5)) d1</code></p>
<p>The observation is: <strong>functions are composed from right to left and the mutator is buried more deeply as the composition goes</strong>.</p>
<p>To see this, let's just pick up combinators randomly to form a chain of function composition, and check its type:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> <span class="fu">:</span>t first (const <span class="dv">5</span>)
first (const <span class="dv">5</span>)<span class="ot"> ::</span> <span class="dt">Num</span> b <span class="ot">=&gt;</span> (a, d) <span class="ot">-&gt;</span> (b, d)
λ<span class="fu">&gt;</span> <span class="fu">:</span>t (second <span class="fu">.</span> first) (const <span class="dv">5</span>)
(second <span class="fu">.</span> first) (const <span class="dv">5</span>)<span class="ot"> ::</span> <span class="dt">Num</span> b <span class="ot">=&gt;</span> (c, (a, d)) <span class="ot">-&gt;</span> (c, (b, d))
λ<span class="fu">&gt;</span> <span class="fu">:</span>t (result <span class="fu">.</span> second <span class="fu">.</span> first) (const <span class="dv">5</span>)
(result <span class="fu">.</span> second <span class="fu">.</span> first) (const <span class="dv">5</span>)
<span class="ot">  ::</span> <span class="dt">Num</span> b <span class="ot">=&gt;</span> (c <span class="ot">-&gt;</span> (c1, (a, d))) <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> (c1, (b, d))
λ<span class="fu">&gt;</span> <span class="fu">:</span>t (second <span class="fu">.</span> result <span class="fu">.</span> second <span class="fu">.</span> first) (const <span class="dv">5</span>)
(second <span class="fu">.</span> result <span class="fu">.</span> second <span class="fu">.</span> first) (const <span class="dv">5</span>)
<span class="ot">  ::</span> <span class="dt">Num</span> b <span class="ot">=&gt;</span> (c, c1 <span class="ot">-&gt;</span> (c2, (a, d))) <span class="ot">-&gt;</span> (c, c1 <span class="ot">-&gt;</span> (c2, (b, d)))
λ<span class="fu">&gt;</span> <span class="fu">:</span>t (first <span class="fu">.</span> second <span class="fu">.</span> result <span class="fu">.</span> second <span class="fu">.</span> first) (const <span class="dv">5</span>)
(first <span class="fu">.</span> second <span class="fu">.</span> result <span class="fu">.</span> second <span class="fu">.</span> first) (const <span class="dv">5</span>)
<span class="ot">  ::</span> <span class="dt">Num</span> b <span class="ot">=&gt;</span>
     ((c, c1 <span class="ot">-&gt;</span> (c2, (a, d1))), d) <span class="ot">-&gt;</span> ((c, c1 <span class="ot">-&gt;</span> (c2, (b, d1))), d)</code></pre>
<p>Reading the composition from right to left, <strong>we are constructing / definiting the “shape” of the data this combinator would like to work on</strong>. In contrast, reading from left to right, <strong>we are deconstructing the data until we reach for the position that we want to modify</strong>. These two views does not conflict with each other.</p>
<p>Therefore, IMHO, when we are thinking about how to walking into the interesting portion, it's helpful thinking about build up combinator from left to right. But to answer the question about why, we should instead read from right to left.</p>
<p>In addition, here is another interesting observation:</p>
<pre><code>    (&lt;comb1&gt; . &lt;comb2&gt;) (&lt;comb3&gt; . &lt;mutator&gt;) d1
&lt;=&gt; (&lt;comb1&gt; . &lt;comb2&gt; . &lt;comb3&gt;) &lt;mutator&gt; d1</code></pre>
<p>The shape of semantic editor combinators are always: <code>{comb} {mut} {dat}</code></p>
<p>So if we see a combinator appear as the head of the <code>(.)</code> chain in <code>{mut}</code>, we can move it to the tail of the <code>(.)</code> chain in <code>{comb}</code>, and the other way around also holds true.</p>
<h2 id="goal-2">Goal 2</h2>
<p>Recall Goal 2: we want <code>a+b</code> to be <code>(a+b)*2</code> in <code>\a -&gt; (a+1, \b -&gt; (a+b, 1))</code></p>
<p>Based on the previous understand, we need to:</p>
<ul>
<li>walk into <code>(a+1, \b -&gt; (a+b, 1))</code>, using <code>result</code></li>
<li>walk into <code>\b -&gt; (a+b, 1)</code>, using <code>second</code></li>
<li>walk into <code>(a+b, 1)</code>, using <code>result</code></li>
<li>walk into <code>(a+b)</code>, using <code>first</code></li>
<li>apply <code>(* 2)</code></li>
</ul>
<p>Try it out:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> <span class="kw">let</span> d2 <span class="fu">=</span> \a <span class="ot">-&gt;</span> (a<span class="fu">+</span><span class="dv">1</span>, \b <span class="ot">-&gt;</span> (a<span class="fu">+</span>b, <span class="dv">1</span>))
λ<span class="fu">&gt;</span> <span class="kw">let</span> m2 <span class="fu">=</span> (result <span class="fu">.</span> second <span class="fu">.</span> result <span class="fu">.</span> first) (<span class="fu">*</span><span class="dv">2</span>) d2
λ<span class="fu">&gt;</span> (snd (d2 <span class="dv">10</span>)) <span class="dv">20</span>
(<span class="dv">30</span>,<span class="dv">1</span>)
λ<span class="fu">&gt;</span> (snd (m2 <span class="dv">10</span>)) <span class="dv">20</span>
(<span class="dv">60</span>,<span class="dv">1</span>)
λ<span class="fu">&gt;</span> fst ((snd (d2 <span class="dv">10</span>)) <span class="dv">20</span>)
<span class="dv">30</span>
λ<span class="fu">&gt;</span> fst ((snd (m2 <span class="dv">10</span>)) <span class="dv">20</span>)
<span class="dv">60</span>
λ<span class="fu">&gt;</span> (fst <span class="fu">.</span> (<span class="fu">$</span> <span class="dv">20</span>) <span class="fu">.</span> snd <span class="fu">.</span> (<span class="fu">$</span> <span class="dv">10</span>)) d2
<span class="dv">30</span>
λ<span class="fu">&gt;</span> (fst <span class="fu">.</span> (<span class="fu">$</span> <span class="dv">20</span>) <span class="fu">.</span> snd <span class="fu">.</span> (<span class="fu">$</span> <span class="dv">10</span>)) m2
<span class="dv">60</span></code></pre>
<p>Last two programs are just rewriting the two programs right before it, Do you notice the symmetry between <code>fst . ($ 20) . snd . ($ 10)</code> and <code>result . second . result . first</code>?</p>
<p>I believe this is not an accident, but to explain it might beyond my reach, this is what I have for now:</p>
<p>With the help of <a href="http://www.haskell.org/haskellwiki/Lambdabot">Lambdabot</a>:</p>
<pre><code>   (fst . ($ 20) . snd . ($ 10)) (result . second . result . first) (*2) d2
&gt;  fst (snd (result (second (result (first 10)))) 20) (2 *) d2</code></pre>
<p>I guess when <code>fst</code> and <code>first</code> meet together, or when <code>($ 10)</code> and <code>result</code> meet together, etc. they will be somehow “cancelled”. If someone knows how to finish this explanation, please let me know.</p>
<h1 id="play-with-lists">Play with lists</h1>
<p>Conal has shown us <code>element</code>, which walks into every element of a list.</p>
<p>It’s easy to work out its type signature:</p>
<ul>
<li>how to modify: <code>f :: a -&gt; b</code></li>
<li>data to be modified: <code>[a]</code></li>
<li>resulting data: <code>[b]</code></li>
</ul>
<p>and this is exactly <code>map</code>.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">element ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]
element <span class="fu">=</span> map</code></pre>
<p>Here I show you 3 extra combinators:</p>
<p><em>inHead</em> modifies the head of a list:</p>
<ul>
<li>how to modify: <code>f :: a -&gt; a</code> (list can only contain elements of same types)</li>
<li>data to be modified: <code>[a]</code></li>
<li>resulting data: <code>[a]</code></li>
</ul>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">inHead ::</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]
inHead f [] <span class="fu">=</span> []
inHead f (x<span class="fu">:</span>xs) <span class="fu">=</span> f x <span class="fu">:</span> xs</code></pre>
<p><em>inTail</em> modifies the tail of a list:</p>
<ul>
<li>how to modify: <code>f :: [a] -&gt; [a]</code></li>
<li>data to be modified: <code>[a]</code></li>
<li>resulting data: <code>[a]</code></li>
</ul>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">inTail ::</span> ([a] <span class="ot">-&gt;</span> [a]) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]
inTail f [] <span class="fu">=</span> []
inTail f (x<span class="fu">:</span>xs) <span class="fu">=</span> x <span class="fu">:</span> f xs</code></pre>
<p><em>inPos</em> modifies the element at a given position:</p>
<ul>
<li>we first need the position: <code>Int</code></li>
<li>how to modify: <code>f :: a -&gt; a</code></li>
<li>data to be modified: <code>[a]</code></li>
<li>resulting data: <code>[a]</code></li>
</ul>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">inPos ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]
inPos n f xs
      <span class="fu">|</span> null xs    <span class="fu">=</span> xs
      <span class="fu">|</span> n <span class="fu">&lt;</span> <span class="dv">0</span>      <span class="fu">=</span> xs
      <span class="fu">|</span> n <span class="fu">==</span> <span class="dv">0</span>     <span class="fu">=</span> <span class="kw">let</span> (y<span class="fu">:</span>ys) <span class="fu">=</span> xs
                     <span class="kw">in</span> f y <span class="fu">:</span> ys
      <span class="fu">|</span> otherwise  <span class="fu">=</span> <span class="kw">let</span> (y<span class="fu">:</span>ys) <span class="fu">=</span> xs
                     <span class="kw">in</span> y <span class="fu">:</span> inPos (n <span class="fu">-</span> <span class="dv">1</span>) f ys</code></pre>
<p><em>inSome</em> is like <code>inPos</code>, but modifies multiple positions:</p>
<ul>
<li>we first need the indices: <code>[Int]</code></li>
<li>how to modify: <code>f :: a -&gt; a</code></li>
<li>data to be modified: <code>[a]</code></li>
<li>resulting data: <code>[a]</code></li>
</ul>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">inSome ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]
inSome ixs f xs <span class="fu">=</span> foldl (\acc i <span class="ot">-&gt;</span> inPos i f acc) xs ixs</code></pre>
<p>Some examples:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> <span class="kw">let</span> d1 <span class="fu">=</span> (<span class="st">&quot;foo&quot;</span>,[<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>])
λ<span class="fu">&gt;</span> (second <span class="fu">.</span> element) (<span class="fu">+</span> <span class="dv">1</span>) d1
(<span class="st">&quot;foo&quot;</span>,[<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>,<span class="dv">11</span>])
λ<span class="fu">&gt;</span> (first <span class="fu">.</span> element) ord d1
([<span class="dv">102</span>,<span class="dv">111</span>,<span class="dv">111</span>],[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>])
λ<span class="fu">&gt;</span> (second <span class="fu">.</span> inTail) (take <span class="dv">2</span>) d1
(<span class="st">&quot;foo&quot;</span>,[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>])
λ<span class="fu">&gt;</span> (second <span class="fu">.</span> inHead) (<span class="fu">*</span> <span class="dv">200</span>) d1
(<span class="st">&quot;foo&quot;</span>,[<span class="dv">200</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>])
λ<span class="fu">&gt;</span> (second <span class="fu">.</span> inPos <span class="dv">3</span>) (<span class="fu">*</span> <span class="dv">200</span>) d1
(<span class="st">&quot;foo&quot;</span>,[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">800</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>])
λ<span class="fu">&gt;</span> <span class="kw">let</span> d2 <span class="fu">=</span> replicate <span class="dv">3</span> (replicate <span class="dv">4</span> <span class="dv">0</span>)
λ<span class="fu">&gt;</span> (inPos <span class="dv">1</span> <span class="fu">.</span> inPos <span class="dv">2</span>) (const <span class="dv">255</span>) d2
[[<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>],[<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">255</span>,<span class="dv">0</span>],[<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>]]</code></pre>
<h1 id="walking-into-user-defined-data">Walking into user defined data</h1>
<p>Suppose user has defined a binary tree:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">BinTree</span> a <span class="fu">=</span> <span class="dt">Node</span> a
               <span class="fu">|</span> <span class="dt">Tree</span> (<span class="dt">BinTree</span> a) (<span class="dt">BinTree</span> a) a
                 <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Functor</span>)</code></pre>
<p>To write a combinator is easy, just follow the pattern <code>&lt;combinator&gt; &lt;mutator&gt; &lt;data&gt; = &lt;modified-data&gt;</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">treeV ::</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">BinTree</span> a <span class="ot">-&gt;</span> <span class="dt">BinTree</span> a
treeV f (<span class="dt">Node</span> x) <span class="fu">=</span> <span class="dt">Node</span> (f x)
treeV f (<span class="dt">Tree</span> l r x) <span class="fu">=</span> <span class="dt">Tree</span> l r (f x)

<span class="ot">treeElement ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">BinTree</span> a <span class="ot">-&gt;</span> <span class="dt">BinTree</span> b
treeElement <span class="fu">=</span> fmap

<span class="ot">treeLeft ::</span> (<span class="dt">BinTree</span> a <span class="ot">-&gt;</span> <span class="dt">BinTree</span> a) <span class="ot">-&gt;</span> <span class="dt">BinTree</span> a <span class="ot">-&gt;</span> <span class="dt">BinTree</span> a
treeLeft f (<span class="dt">Tree</span> l r e) <span class="fu">=</span> <span class="dt">Tree</span> (f l) r e
treeLeft f r <span class="fu">=</span> r

<span class="ot">treeRight ::</span> (<span class="dt">BinTree</span> a <span class="ot">-&gt;</span> <span class="dt">BinTree</span> a) <span class="ot">-&gt;</span> <span class="dt">BinTree</span> a <span class="ot">-&gt;</span> <span class="dt">BinTree</span> a
treeRight f (<span class="dt">Tree</span> l r e) <span class="fu">=</span> <span class="dt">Tree</span> l (f r) e
treeRight f r <span class="fu">=</span> r

<span class="ot">treeNonLeaf ::</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">BinTree</span> a <span class="ot">-&gt;</span> <span class="dt">BinTree</span> a
treeNonLeaf f (<span class="dt">Tree</span> l r e) <span class="fu">=</span> <span class="dt">Tree</span> (treeNonLeaf f l) (treeNonLeaf f r) (f e)
treeNonLeaf f r <span class="fu">=</span> r

<span class="ot">treeLeaf ::</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">BinTree</span> a <span class="ot">-&gt;</span> <span class="dt">BinTree</span> a
treeLeaf f (<span class="dt">Node</span> x) <span class="fu">=</span> <span class="dt">Node</span> (f x)
treeLeaf f (<span class="dt">Tree</span> l r x) <span class="fu">=</span> <span class="dt">Tree</span> (treeLeaf f l) (treeLeaf f r) x</code></pre>
<p>Here <code>treeElement</code> walks into the data part of each node to do the modification. Since <code>treeElement = fmap</code>, we can generalize <code>element = fmap</code>, to make it work for not only lists and <code>BinTree</code>s, but also any other Functors.</p>
<p><code>treeLeft</code> and <code>treeRight</code> walks into left subtree and right subtree, respectively. But to target at the value of a <code>BinTree</code>, we need <code>treeV</code>, which takes care of walking into the data field of a tree.</p>
<p><code>treeNonLeaf</code> and <code>treeLeaf</code> are just like <code>treeElement</code> but works merely on non-leaf nodes and leaf nodes, respectively.</p>
<p>See them in action:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> <span class="kw">let</span> d1 <span class="fu">=</span> <span class="dt">Tree</span> (<span class="dt">Tree</span> (<span class="dt">Node</span> (<span class="dv">1</span>,<span class="dv">1</span>)) (<span class="dt">Node</span> (<span class="dv">1</span>,<span class="dv">2</span>)) (<span class="dv">2</span>,<span class="dv">2</span>)) (<span class="dt">Node</span> (<span class="dv">3</span>,<span class="dv">4</span>)) (<span class="dv">5</span>,<span class="dv">6</span>)
λ<span class="fu">&gt;</span> (treeElement <span class="fu">.</span> first) even d1 <span class="co">-- test for each node, if the `fst` part is an even?</span>
<span class="dt">Tree</span> (<span class="dt">Tree</span> (<span class="dt">Node</span> (<span class="dt">False</span>,<span class="dv">1</span>)) (<span class="dt">Node</span> (<span class="dt">False</span>,<span class="dv">2</span>)) (<span class="dt">True</span>,<span class="dv">2</span>)) (<span class="dt">Node</span> (<span class="dt">False</span>,<span class="dv">4</span>)) (<span class="dt">False</span>,<span class="dv">6</span>)
λ<span class="fu">&gt;</span> (treeLeft <span class="fu">.</span> treeV <span class="fu">.</span> first) (<span class="fu">*</span> <span class="dv">4</span>) d1 <span class="co">-- walk into left subtree, multiple `fst` part of its value by 4</span>
<span class="dt">Tree</span> (<span class="dt">Tree</span> (<span class="dt">Node</span> (<span class="dv">1</span>,<span class="dv">1</span>)) (<span class="dt">Node</span> (<span class="dv">1</span>,<span class="dv">2</span>)) (<span class="dv">2</span>,<span class="dv">2</span>)) (<span class="dt">Node</span> (<span class="dv">3</span>,<span class="dv">4</span>)) (<span class="dv">5</span>,<span class="dv">6</span>)
λ<span class="fu">&gt;</span> (treeLeft <span class="fu">.</span> treeRight <span class="fu">.</span> treeV <span class="fu">.</span> first) (<span class="fu">*</span> <span class="dv">4</span>) d1 <span class="co">-- walk into the right subtree of the left subtree, ..</span>
<span class="dt">Tree</span> (<span class="dt">Tree</span> (<span class="dt">Node</span> (<span class="dv">1</span>,<span class="dv">1</span>)) (<span class="dt">Node</span> (<span class="dv">4</span>,<span class="dv">2</span>)) (<span class="dv">2</span>,<span class="dv">2</span>)) (<span class="dt">Node</span> (<span class="dv">3</span>,<span class="dv">4</span>)) (<span class="dv">5</span>,<span class="dv">6</span>)
λ<span class="fu">&gt;</span> (treeNonLeaf <span class="fu">.</span> first) (const <span class="dv">100</span>) d1 <span class="co">-- for each value of the `fst` part of each non-leaf node</span>
<span class="dt">Tree</span> (<span class="dt">Tree</span> (<span class="dt">Node</span> (<span class="dv">1</span>,<span class="dv">1</span>)) (<span class="dt">Node</span> (<span class="dv">1</span>,<span class="dv">2</span>)) (<span class="dv">100</span>,<span class="dv">2</span>)) (<span class="dt">Node</span> (<span class="dv">3</span>,<span class="dv">4</span>)) (<span class="dv">100</span>,<span class="dv">6</span>)
λ<span class="fu">&gt;</span> (treeLeaf <span class="fu">.</span> second) (const <span class="dv">100</span>) d1 <span class="co">-- for each value of the `snd` part of each leaf node</span>
<span class="dt">Tree</span> (<span class="dt">Tree</span> (<span class="dt">Node</span> (<span class="dv">1</span>,<span class="dv">100</span>)) (<span class="dt">Node</span> (<span class="dv">1</span>,<span class="dv">100</span>)) (<span class="dv">2</span>,<span class="dv">2</span>)) (<span class="dt">Node</span> (<span class="dv">3</span>,<span class="dv">100</span>)) (<span class="dv">5</span>,<span class="dv">6</span>)</code></pre>
<h1 id="combining-semantic-editor-combinators">Combining semantic editor combinators</h1>
<p>The semantic editor combinators can also be chained together.</p>
<p>Suppose we have some combinators:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> <span class="kw">let</span> c13 <span class="fu">=</span> (inPos <span class="dv">1</span>) (const <span class="dv">3</span>)
λ<span class="fu">&gt;</span> <span class="kw">let</span> c05 <span class="fu">=</span> (inPos <span class="dv">0</span>) (const <span class="dv">5</span>)
λ<span class="fu">&gt;</span> <span class="kw">let</span> c06 <span class="fu">=</span> (inPos <span class="dv">0</span>) (const <span class="dv">6</span>)
λ<span class="fu">&gt;</span> <span class="kw">let</span> cf1 <span class="fu">=</span> first (const <span class="dv">1</span>)</code></pre>
<p>For a given list, we want to apply <code>c13</code> and <code>c05</code>:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> <span class="kw">let</span> d <span class="fu">=</span> replicate <span class="dv">5</span> <span class="dv">0</span>
λ<span class="fu">&gt;</span> c06 (c13 d)
[<span class="dv">6</span>,<span class="dv">3</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>]
λ<span class="fu">&gt;</span> (c06 <span class="fu">.</span> c13) d
[<span class="dv">6</span>,<span class="dv">3</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>]</code></pre>
<p>So we can use function composition to compose semantic editors:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> <span class="kw">let</span> d2 <span class="fu">=</span> (<span class="dv">10</span>,replicate <span class="dv">5</span> <span class="dv">0</span>)
λ<span class="fu">&gt;</span> (cf1 <span class="fu">.</span> (second c13)) d2
(<span class="dv">1</span>,[<span class="dv">0</span>,<span class="dv">3</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>])
λ<span class="fu">&gt;</span> (cf1 <span class="fu">.</span> (second c13) <span class="fu">.</span> (second c05)) d2
(<span class="dv">1</span>,[<span class="dv">5</span>,<span class="dv">3</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>])
λ<span class="fu">&gt;</span> (cf1 <span class="fu">.</span> (second (c13 <span class="fu">.</span> c05))) d2
(<span class="dv">1</span>,[<span class="dv">5</span>,<span class="dv">3</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>])</code></pre>
<p>The last example says “apply <code>1</code>, (back to the top level and then) walk into the <code>snd</code> part, apply <code>c05</code> and then <code>c13</code>”. I think this “distributive property” will make things extremely flexible.</p>
<p>Since the function composition happens from right to left, if some combinators are trying to modify the same field, the “leftmost” one take effect:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> (c05 <span class="fu">.</span> c06) [<span class="dv">0</span>,<span class="dv">1</span>]
[<span class="dv">5</span>,<span class="dv">1</span>]
λ<span class="fu">&gt;</span> (c06 <span class="fu">.</span> c05) [<span class="dv">0</span>,<span class="dv">1</span>]
[<span class="dv">6</span>,<span class="dv">1</span>]</code></pre>
</div>

<br /><br />
<div class="pull-right">
<span class="st_blogger_large" displayText="Blogger"></span>
<span class="st_delicious_large" displayText="Delicious"></span>
<span class="st_facebook_large" displayText="Facebook"></span>
<span class="st_reddit_large" displayText="Reddit"></span>
<span class="st_sina_large" displayText="Sina"></span>
<span class="st_twitter_large" displayText="Tweet"></span>
<span class="st_wordpress_large" displayText="WordPress"></span>
</div>
<div id="disqus_thread"></div>
<script type="text/javascript">
/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
var disqus_shortname = 'javrania'; // required: replace example with your forum shortname

/* * * DON'T EDIT BELOW THIS LINE * * */
(function() {
 var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
 dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
 (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
 })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

      </div>
      

    </div><!-- /.container -->


    <div class="blog-footer">
        Site proudly generated by
        <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        <br />
        Powered by
        <a href="http://getbootstrap.com/">Bootstrap</a>
        <br />
        Colorized by
        <a href="http://www.lavishbootstrap.com/">Lavish</a>
        <br />
                <span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text" property="dct:title" rel="dct:type">Javrania</span>
        by <a xmlns:cc="http://creativecommons.org/ns#" href="https://github.com/Javran" property="cc:attributionName" rel="cc:attributionURL">Javran Cheng</a>
        is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/deed.en_US">Creative Commons Attribution 4.0 International License</a>.
        <br /><br />
        <a rel="license" href="http://creativecommons.org/licenses/by/4.0/deed.en_US">
            <img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by/4.0/88x31.png" /></a><br />

    </div>
    <!-- Bootstrap core JavaScript
         ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://code.jquery.com/jquery-1.10.2.min.js"></script>
    <script src="../js/bootstrap.min.js"></script>
  </body>
</html>
